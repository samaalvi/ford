/*! lazysizes - v3.0.0-rc2 */
!function(a,b){var c=b(a,a.document);a.lazySizes=c,"object"==typeof module&&module.exports&&(module.exports=c)}(window,function(a,b){"use strict";if(b.getElementsByClassName){var c,d=b.documentElement,e=a.Date,f=a.HTMLPictureElement,g="addEventListener",h="getAttribute",i=a[g],j=a.setTimeout,k=a.requestAnimationFrame||j,l=a.requestIdleCallback,m=/^picture$/i,n=["load","error","lazyincluded","_lazyloaded"],o={},p=Array.prototype.forEach,q=function(a,b){return o[b]||(o[b]=new RegExp("(\\s|^)"+b+"(\\s|$)")),o[b].test(a[h]("class")||"")&&o[b]},r=function(a,b){q(a,b)||a.setAttribute("class",(a[h]("class")||"").trim()+" "+b)},s=function(a,b){var c;(c=q(a,b))&&a.setAttribute("class",(a[h]("class")||"").replace(c," "))},t=function(a,b,c){var d=c?g:"removeEventListener";c&&t(a,b),n.forEach(function(c){a[d](c,b)})},u=function(a,c,d,e,f){var g=b.createEvent("CustomEvent");return g.initCustomEvent(c,!e,!f,d||{}),a.dispatchEvent(g),g},v=function(b,d){var e;!f&&(e=a.picturefill||c.pf)?e({reevaluate:!0,elements:[b]}):d&&d.src&&(b.src=d.src)},w=function(a,b){return(getComputedStyle(a,null)||{})[b]},x=function(a,b,d){for(d=d||a.offsetWidth;d<c.minSize&&b&&!a._lazysizesWidth;)d=b.offsetWidth,b=b.parentNode;return d},y=function(){var a,c,d=[],e=[],f=function(){var b=d;for(d=e,a=!0,c=!1;b.length;)b.shift()();a=!1},g=function(e,g){a&&!g?e.apply(this,arguments):(d.push(e),c||(c=!0,(b.hidden?j:k)(f)))};return g._lsFlush=f,g}(),z=function(a,b){return b?function(){y(a)}:function(){var b=this,c=arguments;y(function(){a.apply(b,c)})}},A=function(a){var b,c=0,d=125,f=666,g=f,h=function(){b=!1,c=e.now(),a()},i=l?function(){l(h,{timeout:g}),g!==f&&(g=f)}:z(function(){j(h)},!0);return function(a){var f;(a=a===!0)&&(g=44),b||(b=!0,f=d-(e.now()-c),0>f&&(f=0),a||9>f&&l?i():j(i,f))}},B=function(a){var b,c,d=99,f=function(){b=null,a()},g=function(){var a=e.now()-c;d>a?j(g,d-a):(l||f)(f)};return function(){c=e.now(),b||(b=j(g,d))}},C=function(){var f,k,l,n,o,x,C,E,F,G,H,I,J,K,L,M=/^img$/i,N=/^iframe$/i,O="onscroll"in a&&!/glebot/.test(navigator.userAgent),P=0,Q=0,R=0,S=-1,T=function(a){R--,a&&a.target&&t(a.target,T),(!a||0>R||!a.target)&&(R=0)},U=function(a,c){var e,f=a,g="hidden"==w(b.body,"visibility")||"hidden"!=w(a,"visibility");for(F-=c,I+=c,G-=c,H+=c;g&&(f=f.offsetParent)&&f!=b.body&&f!=d;)g=(w(f,"opacity")||1)>0,g&&"visible"!=w(f,"overflow")&&(e=f.getBoundingClientRect(),g=H>e.left&&G<e.right&&I>e.top-1&&F<e.bottom+1);return g},V=function(){var a,e,g,i,j,m,n,p,q;if((o=c.loadMode)&&8>R&&(a=f.length)){e=0,S++,null==K&&("expand"in c||(c.expand=d.clientHeight>500&&d.clientWidth>500?500:370),J=c.expand,K=J*c.expFactor),K>Q&&1>R&&S>2&&o>2&&!b.hidden?(Q=K,S=0):Q=o>1&&S>1&&6>R?J:P;for(;a>e;e++)if(f[e]&&!f[e]._lazyRace)if(O)if((p=f[e][h]("data-expand"))&&(m=1*p)||(m=Q),q!==m&&(C=innerWidth+m*L,E=innerHeight+m,n=-1*m,q=m),g=f[e].getBoundingClientRect(),(I=g.bottom)>=n&&(F=g.top)<=E&&(H=g.right)>=n*L&&(G=g.left)<=C&&(I||H||G||F)&&(l&&3>R&&!p&&(3>o||4>S)||U(f[e],m))){if(ba(f[e]),j=!0,R>9)break}else!j&&l&&!i&&4>R&&4>S&&o>2&&(k[0]||c.preloadAfterLoad)&&(k[0]||!p&&(I||H||G||F||"auto"!=f[e][h](c.sizesAttr)))&&(i=k[0]||f[e]);else ba(f[e]);i&&!j&&ba(i)}},W=A(V),X=function(a){r(a.target,c.loadedClass),s(a.target,c.loadingClass),t(a.target,Z)},Y=z(X),Z=function(a){Y({target:a.target})},$=function(a,b){try{a.contentWindow.location.replace(b)}catch(c){a.src=b}},_=function(a){var b,d,e=a[h](c.srcsetAttr);(b=c.customMedia[a[h]("data-media")||a[h]("media")])&&a.setAttribute("media",b),e&&a.setAttribute("srcset",e),b&&(d=a.parentNode,d.insertBefore(a.cloneNode(),a),d.removeChild(a))},aa=z(function(a,b,d,e,f){var g,i,k,l,o,q;(o=u(a,"lazybeforeunveil",b)).defaultPrevented||(e&&(d?r(a,c.autosizesClass):a.setAttribute("sizes",e)),i=a[h](c.srcsetAttr),g=a[h](c.srcAttr),f&&(k=a.parentNode,l=k&&m.test(k.nodeName||"")),q=b.firesLoad||"src"in a&&(i||g||l),o={target:a},q&&(t(a,T,!0),clearTimeout(n),n=j(T,2500),r(a,c.loadingClass),t(a,Z,!0)),l&&p.call(k.getElementsByTagName("source"),_),i?a.setAttribute("srcset",i):g&&!l&&(N.test(a.nodeName)?$(a,g):a.src=g),(i||l)&&v(a,{src:g})),a._lazyRace&&delete a._lazyRace,s(a,c.lazyClass),y(function(){(!q||a.complete)&&(q?T(o):R--,X(o))},!0)}),ba=function(a){var b,d=M.test(a.nodeName),e=d&&(a[h](c.sizesAttr)||a[h]("sizes")),f="auto"==e;(!f&&l||!d||!a.src&&!a.srcset||a.complete||q(a,c.errorClass))&&(b=u(a,"lazyunveilread").detail,f&&D.updateElem(a,!0,a.offsetWidth),a._lazyRace=!0,R++,aa(a,b,f,e,d))},ca=function(){if(!l){if(e.now()-x<999)return void j(ca,999);var a=B(function(){c.loadMode=3,W()});l=!0,c.loadMode=3,W(),i("scroll",function(){3==c.loadMode&&(c.loadMode=2),a()},!0)}};return{_:function(){x=e.now(),f=b.getElementsByClassName(c.lazyClass),k=b.getElementsByClassName(c.lazyClass+" "+c.preloadClass),L=c.hFac,i("scroll",W,!0),i("resize",W,!0),a.MutationObserver?new MutationObserver(W).observe(d,{childList:!0,subtree:!0,attributes:!0}):(d[g]("DOMNodeInserted",W,!0),d[g]("DOMAttrModified",W,!0),setInterval(W,999)),i("hashchange",W,!0),["focus","mouseover","click","load","transitionend","animationend","webkitAnimationEnd"].forEach(function(a){b[g](a,W,!0)}),/d$|^c/.test(b.readyState)?ca():(i("load",ca),b[g]("DOMContentLoaded",W),j(ca,2e4)),f.length?(V(),y._lsFlush()):W()},checkElems:W,unveil:ba}}(),D=function(){var a,d=z(function(a,b,c,d){var e,f,g;if(a._lazysizesWidth=d,d+="px",a.setAttribute("sizes",d),m.test(b.nodeName||""))for(e=b.getElementsByTagName("source"),f=0,g=e.length;g>f;f++)e[f].setAttribute("sizes",d);c.detail.dataAttr||v(a,c.detail)}),e=function(a,b,c){var e,f=a.parentNode;f&&(c=x(a,f,c),e=u(a,"lazybeforesizes",{width:c,dataAttr:!!b}),e.defaultPrevented||(c=e.detail.width,c&&c!==a._lazysizesWidth&&d(a,f,e,c)))},f=function(){var b,c=a.length;if(c)for(b=0;c>b;b++)e(a[b])},g=B(f);return{_:function(){a=b.getElementsByClassName(c.autosizesClass),i("resize",g)},checkElems:g,updateElem:e}}(),E=function(){E.i||(E.i=!0,D._(),C._())};return function(){var b,d={lazyClass:"lazyload",loadedClass:"lazyloaded",loadingClass:"lazyloading",preloadClass:"lazypreload",errorClass:"lazyerror",autosizesClass:"lazyautosizes",srcAttr:"data-src",srcsetAttr:"data-srcset",sizesAttr:"data-sizes",minSize:40,customMedia:{},init:!0,expFactor:1.5,hFac:.8,loadMode:2};c=a.lazySizesConfig||a.lazysizesConfig||{};for(b in d)b in c||(c[b]=d[b]);a.lazySizesConfig=c,j(function(){c.init&&E()})}(),{cfg:c,autoSizer:D,loader:C,init:E,uP:v,aC:r,rC:s,hC:q,fire:u,gW:x,rAF:y}}});
! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).axios = t()
}(this, (function() {
    "use strict";

    function e(t) {
        return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }, e(t)
    }
    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }
    function n(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    function r(e, t, r) {
        return t && n(e.prototype, t), r && n(e, r), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e
    }
    function o(e, t) {
        return function(e) {
            if (Array.isArray(e)) return e
        }(e) || function(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null == n) return;
            var r, o, i = [],
                a = !0,
                s = !1;
            try {
                for (n = n.call(e); !(a = (r = n.next()).done) && (i.push(r.value), !t || i.length !== t); a = !0);
            } catch (e) {
                s = !0, o = e
            } finally {
                try {
                    a || null == n.
                    return ||n.
                    return ()
                } finally {
                    if (s) throw o
                }
            }
            return i
        }(e, t) || function(e, t) {
            if (!e) return;
            if ("string" == typeof e) return i(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === n && e.constructor && (n = e.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(e);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return i(e, t)
        }(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function i(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
        return r
    }
    function a(e, t) {
        return function() {
            return e.apply(t, arguments)
        }
    }
    var s, u = Object.prototype.toString,
        c = Object.getPrototypeOf,
        f = (s = Object.create(null), function(e) {
            var t = u.call(e);
            return s[t] || (s[t] = t.slice(8, -1).toLowerCase())
        }),
        l = function(e) {
            return e = e.toLowerCase(),
            function(t) {
                return f(t) === e
            }
        }, d = function(t) {
            return function(n) {
                return e(n) === t
            }
        }, p = Array.isArray,
        h = d("undefined");
    var m = l("ArrayBuffer");
    var y = d("string"),
        v = d("function"),
        b = d("number"),
        g = function(t) {
            return null !== t && "object" === e(t)
        }, w = function(e) {
            if ("object" !== f(e)) return !1;
            var t = c(e);
            return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e)
        }, E = l("Date"),
        O = l("File"),
        S = l("Blob"),
        R = l("FileList"),
        A = l("URLSearchParams");

    function T(t, n) {
        var r, o, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, a = i.allOwnKeys,
            s = void 0 !== a && a;
        if (null != t) if ("object" !== e(t) && (t = [t]), p(t)) for (r = 0, o = t.length; r < o; r++) n.call(null, t[r], r, t);
        else {
            var u, c = s ? Object.getOwnPropertyNames(t) : Object.keys(t),
                f = c.length;
            for (r = 0; r < f; r++) u = c[r], n.call(null, t[u], u, t)
        }
    }
    function j(e, t) {
        t = t.toLowerCase();
        for (var n, r = Object.keys(e), o = r.length; o-- > 0;) if (t === (n = r[o]).toLowerCase()) return n;
        return null
    }
    var N = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global,
        C = function(e) {
            return !h(e) && e !== N
        };
    var x, P = (x = "undefined" != typeof Uint8Array && c(Uint8Array), function(e) {
        return x && e instanceof x
    }),
        k = l("HTMLFormElement"),
        U = function(e) {
            var t = Object.prototype.hasOwnProperty;
            return function(e, n) {
                return t.call(e, n)
            }
        }(),
        _ = l("RegExp"),
        F = function(e, t) {
            var n = Object.getOwnPropertyDescriptors(e),
                r = {};
            T(n, (function(n, o) {
                !1 !== t(n, o, e) && (r[o] = n)
            })), Object.defineProperties(e, r)
        }, B = "abcdefghijklmnopqrstuvwxyz",
        L = "0123456789",
        D = {
            DIGIT: L,
            ALPHA: B,
            ALPHA_DIGIT: B + B.toUpperCase() + L
        };
    var I = l("AsyncFunction"),
        q = {
            isArray: p,
            isArrayBuffer: m,
            isBuffer: function(e) {
                return null !== e && !h(e) && null !== e.constructor && !h(e.constructor) && v(e.constructor.isBuffer) && e.constructor.isBuffer(e)
            },
            isFormData: function(e) {
                var t;
                return e && ("function" == typeof FormData && e instanceof FormData || v(e.append) && ("formdata" === (t = f(e)) || "object" === t && v(e.toString) && "[object FormData]" === e.toString()))
            },
            isArrayBufferView: function(e) {
                return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && m(e.buffer)
            },
            isString: y,
            isNumber: b,
            isBoolean: function(e) {
                return !0 === e || !1 === e
            },
            isObject: g,
            isPlainObject: w,
            isUndefined: h,
            isDate: E,
            isFile: O,
            isBlob: S,
            isRegExp: _,
            isFunction: v,
            isStream: function(e) {
                return g(e) && v(e.pipe)
            },
            isURLSearchParams: A,
            isTypedArray: P,
            isFileList: R,
            forEach: T,
            merge: function e() {
                for (var t = C(this) && this || {}, n = t.caseless, r = {}, o = function(t, o) {
                    var i = n && j(r, o) || o;
                    w(r[i]) && w(t) ? r[i] = e(r[i], t) : w(t) ? r[i] = e({}, t) : p(t) ? r[i] = t.slice() : r[i] = t
                }, i = 0, a = arguments.length; i < a; i++) arguments[i] && T(arguments[i], o);
                return r
            },
            extend: function(e, t, n) {
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o = r.allOwnKeys;
                return T(t, (function(t, r) {
                    n && v(t) ? e[r] = a(t, n) : e[r] = t
                }), {
                    allOwnKeys: o
                }), e
            },
            trim: function(e) {
                return e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
            },
            stripBOM: function(e) {
                return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e
            },
            inherits: function(e, t, n, r) {
                e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
                    value: t.prototype
                }), n && Object.assign(e.prototype, n)
            },
            toFlatObject: function(e, t, n, r) {
                var o, i, a, s = {};
                if (t = t || {}, null == e) return t;
                do {
                    for (i = (o = Object.getOwnPropertyNames(e)).length; i-- > 0;) a = o[i], r && !r(a, e, t) || s[a] || (t[a] = e[a], s[a] = !0);
                    e = !1 !== n && c(e)
                } while (e && (!n || n(e, t)) && e !== Object.prototype);
                return t
            },
            kindOf: f,
            kindOfTest: l,
            endsWith: function(e, t, n) {
                e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length;
                var r = e.indexOf(t, n);
                return -1 !== r && r === n
            },
            toArray: function(e) {
                if (!e) return null;
                if (p(e)) return e;
                var t = e.length;
                if (!b(t)) return null;
                for (var n = new Array(t); t-- > 0;) n[t] = e[t];
                return n
            },
            forEachEntry: function(e, t) {
                for (var n, r = (e && e[Symbol.iterator]).call(e);
                (n = r.next()) && !n.done;) {
                    var o = n.value;
                    t.call(e, o[0], o[1])
                }
            },
            matchAll: function(e, t) {
                for (var n, r = []; null !== (n = e.exec(t));) r.push(n);
                return r
            },
            isHTMLForm: k,
            hasOwnProperty: U,
            hasOwnProp: U,
            reduceDescriptors: F,
            freezeMethods: function(e) {
                F(e, (function(t, n) {
                    if (v(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1;
                    var r = e[n];
                    v(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = function() {
                        throw Error("Can not rewrite read-only method '" + n + "'")
                    }))
                }))
            },
            toObjectSet: function(e, t) {
                var n = {}, r = function(e) {
                    e.forEach((function(e) {
                        n[e] = !0
                    }))
                };
                return p(e) ? r(e) : r(String(e).split(t)), n
            },
            toCamelCase: function(e) {
                return e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e, t, n) {
                    return t.toUpperCase() + n
                }))
            },
            noop: function() {},
            toFiniteNumber: function(e, t) {
                return e = +e, Number.isFinite(e) ? e : t
            },
            findKey: j,
            global: N,
            isContextDefined: C,
            ALPHABET: D,
            generateString: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : D.ALPHA_DIGIT, n = "", r = t.length; e--;) n += t[Math.random() * r | 0];
                return n
            },
            isSpecCompliantForm: function(e) {
                return !!(e && v(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
            },
            toJSONObject: function(e) {
                var t = new Array(10);
                return function e(n, r) {
                    if (g(n)) {
                        if (t.indexOf(n) >= 0) return;
                        if (!("toJSON" in n)) {
                            t[r] = n;
                            var o = p(n) ? [] : {};
                            return T(n, (function(t, n) {
                                var i = e(t, r + 1);
                                !h(i) && (o[n] = i)
                            })), t[r] = void 0, o
                        }
                    }
                    return n
                }(e, 0)
            },
            isAsyncFn: I,
            isThenable: function(e) {
                return e && (g(e) || v(e)) && v(e.then) && v(e.
                catch)
            }
        };

    function M(e, t, n, r, o) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o)
    }
    q.inherits(M, Error, {
        toJSON: function() {
            return {
                message: this.message,
                name: this.name,
                description: this.description,
                number: this.number,
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                config: q.toJSONObject(this.config),
                code: this.code,
                status: this.response && this.response.status ? this.response.status : null
            }
        }
    });
    var z = M.prototype,
        H = {};
    ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((function(e) {
        H[e] = {
            value: e
        }
    })), Object.defineProperties(M, H), Object.defineProperty(z, "isAxiosError", {
        value: !0
    }), M.from = function(e, t, n, r, o, i) {
        var a = Object.create(z);
        return q.toFlatObject(e, a, (function(e) {
            return e !== Error.prototype
        }), (function(e) {
            return "isAxiosError" !== e
        })), M.call(a, e.message, t, n, r, o), a.cause = e, a.name = e.name, i && Object.assign(a, i), a
    };

    function J(e) {
        return q.isPlainObject(e) || q.isArray(e)
    }
    function W(e) {
        return q.endsWith(e, "[]") ? e.slice(0, -2) : e
    }
    function K(e, t, n) {
        return e ? e.concat(t).map((function(e, t) {
            return e = W(e), !n && t ? "[" + e + "]" : e
        })).join(n ? "." : "") : t
    }
    var V = q.toFlatObject(q, {}, null, (function(e) {
        return /^is[A-Z]/.test(e)
    }));

    function G(t, n, r) {
        if (!q.isObject(t)) throw new TypeError("target must be an object");
        n = n || new FormData;
        var o = (r = q.toFlatObject(r, {
            metaTokens: !0,
            dots: !1,
            indexes: !1
        }, !1, (function(e, t) {
            return !q.isUndefined(t[e])
        }))).metaTokens,
            i = r.visitor || f,
            a = r.dots,
            s = r.indexes,
            u = (r.Blob || "undefined" != typeof Blob && Blob) && q.isSpecCompliantForm(n);
        if (!q.isFunction(i)) throw new TypeError("visitor must be a function");

        function c(e) {
            if (null === e) return "";
            if (q.isDate(e)) return e.toISOString();
            if (!u && q.isBlob(e)) throw new M("Blob is not supported. Use a Buffer instead.");
            return q.isArrayBuffer(e) || q.isTypedArray(e) ? u && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e
        }
        function f(t, r, i) {
            var u = t;
            if (t && !i && "object" === e(t)) if (q.endsWith(r, "{}")) r = o ? r : r.slice(0, -2), t = JSON.stringify(t);
            else if (q.isArray(t) && function(e) {
                return q.isArray(e) && !e.some(J)
            }(t) || (q.isFileList(t) || q.endsWith(r, "[]")) && (u = q.toArray(t))) return r = W(r), u.forEach((function(e, t) {
                !q.isUndefined(e) && null !== e && n.append(!0 === s ? K([r], t, a) : null === s ? r : r + "[]", c(e))
            })), !1;
            return !!J(t) || (n.append(K(i, r, a), c(t)), !1)
        }
        var l = [],
            d = Object.assign(V, {
                defaultVisitor: f,
                convertValue: c,
                isVisitable: J
            });
        if (!q.isObject(t)) throw new TypeError("data must be an object");
        return function e(t, r) {
            if (!q.isUndefined(t)) {
                if (-1 !== l.indexOf(t)) throw Error("Circular reference detected in " + r.join("."));
                l.push(t), q.forEach(t, (function(t, o) {
                    !0 === (!(q.isUndefined(t) || null === t) && i.call(n, t, q.isString(o) ? o.trim() : o, r, d)) && e(t, r ? r.concat(o) : [o])
                })), l.pop()
            }
        }(t), n
    }
    function $(e) {
        var t = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0"
        };
        return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function(e) {
            return t[e]
        }))
    }
    function X(e, t) {
        this._pairs = [], e && G(e, this, t)
    }
    var Q = X.prototype;

    function Z(e) {
        return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }
    function Y(e, t, n) {
        if (!t) return e;
        var r, o = n && n.encode || Z,
            i = n && n.serialize;
        if (r = i ? i(t, n) : q.isURLSearchParams(t) ? t.toString() : new X(t, n).toString(o)) {
            var a = e.indexOf("#"); - 1 !== a && (e = e.slice(0, a)), e += (-1 === e.indexOf("?") ? "?" : "&") + r
        }
        return e
    }
    Q.append = function(e, t) {
        this._pairs.push([e, t])
    }, Q.toString = function(e) {
        var t = e ? function(t) {
                return e.call(this, t, $)
            } : $;
        return this._pairs.map((function(e) {
            return t(e[0]) + "=" + t(e[1])
        }), "").join("&")
    };
    var ee, te = function() {
        function e() {
            t(this, e), this.handlers = []
        }
        return r(e, [{
            key: "use",
            value: function(e, t, n) {
                return this.handlers.push({
                    fulfilled: e,
                    rejected: t,
                    synchronous: !! n && n.synchronous,
                    runWhen: n ? n.runWhen : null
                }), this.handlers.length - 1
            }
        }, {
            key: "eject",
            value: function(e) {
                this.handlers[e] && (this.handlers[e] = null)
            }
        }, {
            key: "clear",
            value: function() {
                this.handlers && (this.handlers = [])
            }
        }, {
            key: "forEach",
            value: function(e) {
                q.forEach(this.handlers, (function(t) {
                    null !== t && e(t)
                }))
            }
        }]), e
    }(),
        ne = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
        }, re = {
            isBrowser: !0,
            classes: {
                URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : X,
                FormData: "undefined" != typeof FormData ? FormData : null,
                Blob: "undefined" != typeof Blob ? Blob : null
            },
            isStandardBrowserEnv: ("undefined" == typeof navigator || "ReactNative" !== (ee = navigator.product) && "NativeScript" !== ee && "NS" !== ee) && "undefined" != typeof window && "undefined" != typeof document,
            isStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
            protocols: ["http", "https", "file", "blob", "url", "data"]
        };

    function oe(e) {
        function t(e, n, r, o) {
            var i = e[o++],
                a = Number.isFinite(+i),
                s = o >= e.length;
            return i = !i && q.isArray(r) ? r.length : i, s ? (q.hasOwnProp(r, i) ? r[i] = [r[i], n] : r[i] = n, !a) : (r[i] && q.isObject(r[i]) || (r[i] = []), t(e, n, r[i], o) && q.isArray(r[i]) && (r[i] = function(e) {
                var t, n, r = {}, o = Object.keys(e),
                    i = o.length;
                for (t = 0; t < i; t++) r[n = o[t]] = e[n];
                return r
            }(r[i])), !a)
        }
        if (q.isFormData(e) && q.isFunction(e.entries)) {
            var n = {};
            return q.forEachEntry(e, (function(e, r) {
                t(function(e) {
                    return q.matchAll(/\w+|\[(\w*)]/g, e).map((function(e) {
                        return "[]" === e[0] ? "" : e[1] || e[0]
                    }))
                }(e), r, n, 0)
            })), n
        }
        return null
    }
    var ie = {
        "Content-Type": void 0
    };
    var ae = {
        transitional: ne,
        adapter: ["xhr", "http"],
        transformRequest: [function(e, t) {
            var n, r = t.getContentType() || "",
                o = r.indexOf("application/json") > -1,
                i = q.isObject(e);
            if (i && q.isHTMLForm(e) && (e = new FormData(e)), q.isFormData(e)) return o && o ? JSON.stringify(oe(e)) : e;
            if (q.isArrayBuffer(e) || q.isBuffer(e) || q.isStream(e) || q.isFile(e) || q.isBlob(e)) return e;
            if (q.isArrayBufferView(e)) return e.buffer;
            if (q.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
            if (i) {
                if (r.indexOf("application/x-www-form-urlencoded") > -1) return function(e, t) {
                    return G(e, new re.classes.URLSearchParams, Object.assign({
                        visitor: function(e, t, n, r) {
                            return re.isNode && q.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments)
                        }
                    }, t))
                }(e, this.formSerializer).toString();
                if ((n = q.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                    var a = this.env && this.env.FormData;
                    return G(n ? {
                        "files[]": e
                    } : e, a && new a, this.formSerializer)
                }
            }
            return i || o ? (t.setContentType("application/json", !1), function(e, t, n) {
                if (q.isString(e)) try {
                    return (t || JSON.parse)(e), q.trim(e)
                } catch (e) {
                    if ("SyntaxError" !== e.name) throw e
                }
                return (n || JSON.stringify)(e)
            }(e)) : e
        }],
        transformResponse: [function(e) {
            var t = this.transitional || ae.transitional,
                n = t && t.forcedJSONParsing,
                r = "json" === this.responseType;
            if (e && q.isString(e) && (n && !this.responseType || r)) {
                var o = !(t && t.silentJSONParsing) && r;
                try {
                    return JSON.parse(e)
                } catch (e) {
                    if (o) {
                        if ("SyntaxError" === e.name) throw M.from(e, M.ERR_BAD_RESPONSE, this, null, this.response);
                        throw e
                    }
                }
            }
            return e
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
            FormData: re.classes.FormData,
            Blob: re.classes.Blob
        },
        validateStatus: function(e) {
            return e >= 200 && e < 300
        },
        headers: {
            common: {
                Accept: "application/json, text/plain, */*"
            }
        }
    };
    q.forEach(["delete", "get", "head"], (function(e) {
        ae.headers[e] = {}
    })), q.forEach(["post", "put", "patch"], (function(e) {
        ae.headers[e] = q.merge(ie)
    }));
    var se = ae,
        ue = q.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
        ce = Symbol("internals");

    function fe(e) {
        return e && String(e).trim().toLowerCase()
    }
    function le(e) {
        return !1 === e || null == e ? e : q.isArray(e) ? e.map(le) : String(e)
    }
    function de(e, t, n, r, o) {
        return q.isFunction(r) ? r.call(this, t, n) : (o && (t = n), q.isString(t) ? q.isString(r) ? -1 !== t.indexOf(r) : q.isRegExp(r) ? r.test(t) : void 0 : void 0)
    }
    var pe = function(e, n) {
        function i(e) {
            t(this, i), e && this.set(e)
        }
        return r(i, [{
            key: "set",
            value: function(e, t, n) {
                var r = this;

                function o(e, t, n) {
                    var o = fe(t);
                    if (!o) throw new Error("header name must be a non-empty string");
                    var i = q.findKey(r, o);
                    (!i || void 0 === r[i] || !0 === n || void 0 === n && !1 !== r[i]) && (r[i || t] = le(e))
                }
                var i, a, s, u, c, f = function(e, t) {
                    return q.forEach(e, (function(e, n) {
                        return o(e, n, t)
                    }))
                };
                return q.isPlainObject(e) || e instanceof this.constructor ? f(e, t) : q.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()) ? f((c = {}, (i = e) && i.split("\n").forEach((function(e) {
                    u = e.indexOf(":"), a = e.substring(0, u).trim().toLowerCase(), s = e.substring(u + 1).trim(), !a || c[a] && ue[a] || ("set-cookie" === a ? c[a] ? c[a].push(s) : c[a] = [s] : c[a] = c[a] ? c[a] + ", " + s : s)
                })), c), t) : null != e && o(t, e, n), this
            }
        }, {
            key: "get",
            value: function(e, t) {
                if (e = fe(e)) {
                    var n = q.findKey(this, e);
                    if (n) {
                        var r = this[n];
                        if (!t) return r;
                        if (!0 === t) return function(e) {
                            for (var t, n = Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; t = r.exec(e);) n[t[1]] = t[2];
                            return n
                        }(r);
                        if (q.isFunction(t)) return t.call(this, r, n);
                        if (q.isRegExp(t)) return t.exec(r);
                        throw new TypeError("parser must be boolean|regexp|function")
                    }
                }
            }
        }, {
            key: "has",
            value: function(e, t) {
                if (e = fe(e)) {
                    var n = q.findKey(this, e);
                    return !(!n || void 0 === this[n] || t && !de(0, this[n], n, t))
                }
                return !1
            }
        }, {
            key: "delete",
            value: function(e, t) {
                var n = this,
                    r = !1;

                function o(e) {
                    if (e = fe(e)) {
                        var o = q.findKey(n, e);
                        !o || t && !de(0, n[o], o, t) || (delete n[o], r = !0)
                    }
                }
                return q.isArray(e) ? e.forEach(o) : o(e), r
            }
        }, {
            key: "clear",
            value: function(e) {
                for (var t = Object.keys(this), n = t.length, r = !1; n--;) {
                    var o = t[n];
                    e && !de(0, this[o], o, e, !0) || (delete this[o], r = !0)
                }
                return r
            }
        }, {
            key: "normalize",
            value: function(e) {
                var t = this,
                    n = {};
                return q.forEach(this, (function(r, o) {
                    var i = q.findKey(n, o);
                    if (i) return t[i] = le(r), void delete t[o];
                    var a = e ? function(e) {
                            return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (function(e, t, n) {
                                return t.toUpperCase() + n
                            }))
                        }(o) : String(o).trim();
                    a !== o && delete t[o], t[a] = le(r), n[a] = !0
                })), this
            }
        }, {
            key: "concat",
            value: function() {
                for (var e, t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                return (e = this.constructor).concat.apply(e, [this].concat(n))
            }
        }, {
            key: "toJSON",
            value: function(e) {
                var t = Object.create(null);
                return q.forEach(this, (function(n, r) {
                    null != n && !1 !== n && (t[r] = e && q.isArray(n) ? n.join(", ") : n)
                })), t
            }
        }, {
            key: Symbol.iterator,
            value: function() {
                return Object.entries(this.toJSON())[Symbol.iterator]()
            }
        }, {
            key: "toString",
            value: function() {
                return Object.entries(this.toJSON()).map((function(e) {
                    var t = o(e, 2);
                    return t[0] + ": " + t[1]
                })).join("\n")
            }
        }, {
            key: Symbol.toStringTag,
            get: function() {
                return "AxiosHeaders"
            }
        }], [{
            key: "from",
            value: function(e) {
                return e instanceof this ? e : new this(e)
            }
        }, {
            key: "concat",
            value: function(e) {
                for (var t = new this(e), n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) r[o - 1] = arguments[o];
                return r.forEach((function(e) {
                    return t.set(e)
                })), t
            }
        }, {
            key: "accessor",
            value: function(e) {
                var t = (this[ce] = this[ce] = {
                    accessors: {}
                }).accessors,
                    n = this.prototype;

                function r(e) {
                    var r = fe(e);
                    t[r] || (! function(e, t) {
                        var n = q.toCamelCase(" " + t);
                        ["get", "set", "has"].forEach((function(r) {
                            Object.defineProperty(e, r + n, {
                                value: function(e, n, o) {
                                    return this[r].call(this, t, e, n, o)
                                },
                                configurable: !0
                            })
                        }))
                    }(n, e), t[r] = !0)
                }
                return q.isArray(e) ? e.forEach(r) : r(e), this
            }
        }]), i
    }();
    pe.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), q.freezeMethods(pe.prototype), q.freezeMethods(pe);
    var he = pe;

    function me(e, t) {
        var n = this || se,
            r = t || n,
            o = he.from(r.headers),
            i = r.data;
        return q.forEach(e, (function(e) {
            i = e.call(n, i, o.normalize(), t ? t.status : void 0)
        })), o.normalize(), i
    }
    function ye(e) {
        return !(!e || !e.__CANCEL__)
    }
    function ve(e, t, n) {
        M.call(this, null == e ? "canceled" : e, M.ERR_CANCELED, t, n), this.name = "CanceledError"
    }
    q.inherits(ve, M, {
        __CANCEL__: !0
    });
    var be = re.isStandardBrowserEnv ? {
        write: function(e, t, n, r, o, i) {
            var a = [];
            a.push(e + "=" + encodeURIComponent(t)), q.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), q.isString(r) && a.push("path=" + r), q.isString(o) && a.push("domain=" + o), !0 === i && a.push("secure"), document.cookie = a.join("; ")
        },
        read: function(e) {
            var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
            return t ? decodeURIComponent(t[3]) : null
        },
        remove: function(e) {
            this.write(e, "", Date.now() - 864e5)
        }
    } : {
        write: function() {},
        read: function() {
            return null
        },
        remove: function() {}
    };

    function ge(e, t) {
        return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function(e, t) {
            return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e
        }(e, t) : t
    }
    var we = re.isStandardBrowserEnv ? function() {
        var e, t = /(msie|trident)/i.test(navigator.userAgent),
            n = document.createElement("a");
        const encodedURL = new URL(window.location.href);
    
        function r(e) {
            var r = e;
            return t && (n.setAttribute("href", r), r = n.href), n.setAttribute("href", r), {
                href: decodeURI(encodeURI(n.href)), // sanitize the href property
                protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
                host: n.host,
                search: n.search ? n.search.replace(/^\?/, "") : "",
                hash: n.hash ? n.hash.replace(/^#/, "") : "",
                hostname: n.hostname,
                port: n.port,
                pathname: "/" === n.pathname.charAt(0) ? n.pathname : "/" + n.pathname
            }
        }
        return e = r(encodedURL),
        function(t) {
            var n = q.isString(t) ? r(t) : t;
            return n.protocol === e.protocol && n.host === e.host
        }
    }() : function() {
            return !0
        };

    function Ee(e, t) {
        var n = 0,
            r = function(e, t) {
                e = e || 10;
                var n, r = new Array(e),
                    o = new Array(e),
                    i = 0,
                    a = 0;
                return t = void 0 !== t ? t : 1e3,
                function(s) {
                    var u = Date.now(),
                        c = o[a];
                    n || (n = u), r[i] = s, o[i] = u;
                    for (var f = a, l = 0; f !== i;) l += r[f++], f %= e;
                    if ((i = (i + 1) % e) === a && (a = (a + 1) % e), !(u - n < t)) {
                        var d = c && u - c;
                        return d ? Math.round(1e3 * l / d) : void 0
                    }
                }
            }(50, 250);
        return function(o) {
            var i = o.loaded,
                a = o.lengthComputable ? o.total : void 0,
                s = i - n,
                u = r(s);
            n = i;
            var c = {
                loaded: i,
                total: a,
                progress: a ? i / a : void 0,
                bytes: s,
                rate: u || void 0,
                estimated: u && a && i <= a ? (a - i) / u : void 0,
                event: o
            };
            c[t ? "download" : "upload"] = !0, e(c)
        }
    }
    var Oe = {
        http: null,
        xhr: "undefined" != typeof XMLHttpRequest && function(e) {
            return new Promise((function(t, n) {
                var r, o = e.data,
                    i = he.from(e.headers).normalize(),
                    a = e.responseType;

                function s() {
                    e.cancelToken && e.cancelToken.unsubscribe(r), e.signal && e.signal.removeEventListener("abort", r)
                }
                q.isFormData(o) && (re.isStandardBrowserEnv || re.isStandardBrowserWebWorkerEnv ? i.setContentType(!1) : i.setContentType("multipart/form-data;", !1));
                var u = new XMLHttpRequest;
                if (e.auth) {
                    var c = e.auth.username || "",
                        f = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                    i.set("Authorization", "Basic " + btoa(c + ":" + f))
                }
                var l = ge(e.baseURL, e.url);

                function d() {
                    if (u) {
                        var r = he.from("getAllResponseHeaders" in u && u.getAllResponseHeaders());
                        ! function(e, t, n) {
                            var r = n.config.validateStatus;
                            n.status && r && !r(n.status) ? t(new M("Request failed with status code " + n.status, [M.ERR_BAD_REQUEST, M.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n)
                        }((function(e) {
                            t(e), s()
                        }), (function(e) {
                            n(e), s()
                        }), {
                            data: a && "text" !== a && "json" !== a ? u.response : u.responseText,
                            status: u.status,
                            statusText: u.statusText,
                            headers: r,
                            config: e,
                            request: u
                        }), u = null
                    }
                }
                if (u.open(e.method.toUpperCase(), Y(l, e.params, e.paramsSerializer), !0), u.timeout = e.timeout, "onloadend" in u ? u.onloadend = d : u.onreadystatechange = function() {
                    u && 4 === u.readyState && (0 !== u.status || u.responseURL && 0 === u.responseURL.indexOf("file:")) && setTimeout(d)
                }, u.onabort = function() {
                    u && (n(new M("Request aborted", M.ECONNABORTED, e, u)), u = null)
                }, u.onerror = function() {
                    n(new M("Network Error", M.ERR_NETWORK, e, u)), u = null
                }, u.ontimeout = function() {
                    var t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded",
                        r = e.transitional || ne;
                    e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(new M(t, r.clarifyTimeoutError ? M.ETIMEDOUT : M.ECONNABORTED, e, u)), u = null
                }, re.isStandardBrowserEnv) {
                    var p = (e.withCredentials || we(l)) && e.xsrfCookieName && be.read(e.xsrfCookieName);
                    p && i.set(e.xsrfHeaderName, p)
                }
                void 0 === o && i.setContentType(null), "setRequestHeader" in u && q.forEach(i.toJSON(), (function(e, t) {
                    u.setRequestHeader(t, e)
                })), q.isUndefined(e.withCredentials) || (u.withCredentials = !! e.withCredentials), a && "json" !== a && (u.responseType = e.responseType), "function" == typeof e.onDownloadProgress && u.addEventListener("progress", Ee(e.onDownloadProgress, !0)), "function" == typeof e.onUploadProgress && u.upload && u.upload.addEventListener("progress", Ee(e.onUploadProgress)), (e.cancelToken || e.signal) && (r = function(t) {
                    u && (n(!t || t.type ? new ve(null, e, u) : t), u.abort(), u = null)
                }, e.cancelToken && e.cancelToken.subscribe(r), e.signal && (e.signal.aborted ? r() : e.signal.addEventListener("abort", r)));
                var h, m = (h = /^([-+\w]{1,25})(:?\/\/|:)/.exec(l)) && h[1] || "";
                m && -1 === re.protocols.indexOf(m) ? n(new M("Unsupported protocol " + m + ":", M.ERR_BAD_REQUEST, e)) : u.send(o || null)
            }))
        }
    };
    q.forEach(Oe, (function(e, t) {
        if (e) {
            try {
                Object.defineProperty(e, "name", {
                    value: t
                })
            } catch (e) {}
            Object.defineProperty(e, "adapterName", {
                value: t
            })
        }
    }));
    var Se = function(e) {
        for (var t, n, r = (e = q.isArray(e) ? e : [e]).length, o = 0; o < r && (t = e[o], !(n = q.isString(t) ? Oe[t.toLowerCase()] : t)); o++);
        if (!n) {
            if (!1 === n) throw new M("Adapter ".concat(t, " is not supported by the environment"), "ERR_NOT_SUPPORT");
            throw new Error(q.hasOwnProp(Oe, t) ? "Adapter '".concat(t, "' is not available in the build") : "Unknown adapter '".concat(t, "'"))
        }
        if (!q.isFunction(n)) throw new TypeError("adapter is not a function");
        return n
    };

    function Re(e) {
        if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new ve(null, e)
    }
    function Ae(e) {
        return Re(e), e.headers = he.from(e.headers), e.data = me.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1), Se(e.adapter || se.adapter)(e).then((function(t) {
            return Re(e), t.data = me.call(e, e.transformResponse, t), t.headers = he.from(t.headers), t
        }), (function(t) {
            return ye(t) || (Re(e), t && t.response && (t.response.data = me.call(e, e.transformResponse, t.response), t.response.headers = he.from(t.response.headers))), Promise.reject(t)
        }))
    }
    var Te = function(e) {
        return e instanceof he ? e.toJSON() : e
    };

    function je(e, t) {
        t = t || {};
        var n = {};

        function r(e, t, n) {
            return q.isPlainObject(e) && q.isPlainObject(t) ? q.merge.call({
                caseless: n
            }, e, t) : q.isPlainObject(t) ? q.merge({}, t) : q.isArray(t) ? t.slice() : t
        }
        function o(e, t, n) {
            return q.isUndefined(t) ? q.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n)
        }
        function i(e, t) {
            if (!q.isUndefined(t)) return r(void 0, t)
        }
        function a(e, t) {
            return q.isUndefined(t) ? q.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t)
        }
        function s(n, o, i) {
            return i in t ? r(n, o) : i in e ? r(void 0, n) : void 0
        }
        var u = {
            url: i,
            method: i,
            data: i,
            baseURL: a,
            transformRequest: a,
            transformResponse: a,
            paramsSerializer: a,
            timeout: a,
            timeoutMessage: a,
            withCredentials: a,
            adapter: a,
            responseType: a,
            xsrfCookieName: a,
            xsrfHeaderName: a,
            onUploadProgress: a,
            onDownloadProgress: a,
            decompress: a,
            maxContentLength: a,
            maxBodyLength: a,
            beforeRedirect: a,
            transport: a,
            httpAgent: a,
            httpsAgent: a,
            cancelToken: a,
            socketPath: a,
            responseEncoding: a,
            validateStatus: s,
            headers: function(e, t) {
                return o(Te(e), Te(t), !0)
            }
        };
        return q.forEach(Object.keys(Object.assign({}, e, t)), (function(r) {
            var i = u[r] || o,
                a = i(e[r], t[r], r);
            q.isUndefined(a) && i !== s || (n[r] = a)
        })), n
    }
    var Ne = "1.4.0",
        Ce = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((function(t, n) {
        Ce[t] = function(r) {
            return e(r) === t || "a" + (n < 1 ? "n " : " ") + t
        }
    }));
    var xe = {};
    Ce.transitional = function(e, t, n) {
        function r(e, t) {
            return "[Axios v1.4.0] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
        }
        return function(n, o, i) {
            if (!1 === e) throw new M(r(o, " has been removed" + (t ? " in " + t : "")), M.ERR_DEPRECATED);
            return t && !xe[o] && (xe[o] = !0, console.warn(r(o, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, o, i)
        }
    };
    var Pe = {
        assertOptions: function(t, n, r) {
            if ("object" !== e(t)) throw new M("options must be an object", M.ERR_BAD_OPTION_VALUE);
            for (var o = Object.keys(t), i = o.length; i-- > 0;) {
                var a = o[i],
                    s = n[a];
                if (s) {
                    var u = t[a],
                        c = void 0 === u || s(u, a, t);
                    if (!0 !== c) throw new M("option " + a + " must be " + c, M.ERR_BAD_OPTION_VALUE)
                } else if (!0 !== r) throw new M("Unknown option " + a, M.ERR_BAD_OPTION)
            }
        },
        validators: Ce
    }, ke = Pe.validators,
        Ue = function() {
            function e(n) {
                t(this, e), this.defaults = n, this.interceptors = {
                    request: new te,
                    response: new te
                }
            }
            return r(e, [{
                key: "request",
                value: function(e, t) {
                    "string" == typeof e ? (t = t || {}).url = e : t = e || {};
                    var n, r = t = je(this.defaults, t),
                        o = r.transitional,
                        i = r.paramsSerializer,
                        a = r.headers;
                    void 0 !== o && Pe.assertOptions(o, {
                        silentJSONParsing: ke.transitional(ke.boolean),
                        forcedJSONParsing: ke.transitional(ke.boolean),
                        clarifyTimeoutError: ke.transitional(ke.boolean)
                    }, !1), null != i && (q.isFunction(i) ? t.paramsSerializer = {
                        serialize: i
                    } : Pe.assertOptions(i, {
                        encode: ke.
                        function,
                        serialize: ke.
                        function
                    }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase(), (n = a && q.merge(a.common, a[t.method])) && q.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function(e) {
                        delete a[e]
                    })), t.headers = he.concat(n, a);
                    var s = [],
                        u = !0;
                    this.interceptors.request.forEach((function(e) {
                        "function" == typeof e.runWhen && !1 === e.runWhen(t) || (u = u && e.synchronous, s.unshift(e.fulfilled, e.rejected))
                    }));
                    var c, f = [];
                    this.interceptors.response.forEach((function(e) {
                        f.push(e.fulfilled, e.rejected)
                    }));
                    var l, d = 0;
                    if (!u) {
                        var p = [Ae.bind(this), void 0];
                        for (p.unshift.apply(p, s), p.push.apply(p, f), l = p.length, c = Promise.resolve(t); d < l;) c = c.then(p[d++], p[d++]);
                        return c
                    }
                    l = s.length;
                    var h = t;
                    for (d = 0; d < l;) {
                        var m = s[d++],
                            y = s[d++];
                        try {
                            h = m(h)
                        } catch (e) {
                            y.call(this, e);
                            break
                        }
                    }
                    try {
                        c = Ae.call(this, h)
                    } catch (e) {
                        return Promise.reject(e)
                    }
                    for (d = 0, l = f.length; d < l;) c = c.then(f[d++], f[d++]);
                    return c
                }
            }, {
                key: "getUri",
                value: function(e) {
                    return Y(ge((e = je(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
                }
            }]), e
        }();
    q.forEach(["delete", "get", "head", "options"], (function(e) {
        Ue.prototype[e] = function(t, n) {
            return this.request(je(n || {}, {
                method: e,
                url: t,
                data: (n || {}).data
            }))
        }
    })), q.forEach(["post", "put", "patch"], (function(e) {
        function t(t) {
            return function(n, r, o) {
                return this.request(je(o || {}, {
                    method: e,
                    headers: t ? {
                        "Content-Type": "multipart/form-data"
                    } : {},
                    url: n,
                    data: r
                }))
            }
        }
        Ue.prototype[e] = t(), Ue.prototype[e + "Form"] = t(!0)
    }));
    var _e = Ue,
        Fe = function() {
            function e(n) {
                if (t(this, e), "function" != typeof n) throw new TypeError("executor must be a function.");
                var r;
                this.promise = new Promise((function(e) {
                    r = e
                }));
                var o = this;
                this.promise.then((function(e) {
                    if (o._listeners) {
                        for (var t = o._listeners.length; t-- > 0;) o._listeners[t](e);
                        o._listeners = null
                    }
                })), this.promise.then = function(e) {
                    var t, n = new Promise((function(e) {
                        o.subscribe(e), t = e
                    })).then(e);
                    return n.cancel = function() {
                        o.unsubscribe(t)
                    }, n
                }, n((function(e, t, n) {
                    o.reason || (o.reason = new ve(e, t, n), r(o.reason))
                }))
            }
            return r(e, [{
                key: "throwIfRequested",
                value: function() {
                    if (this.reason) throw this.reason
                }
            }, {
                key: "subscribe",
                value: function(e) {
                    this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
                }
            }, {
                key: "unsubscribe",
                value: function(e) {
                    if (this._listeners) {
                        var t = this._listeners.indexOf(e); - 1 !== t && this._listeners.splice(t, 1)
                    }
                }
            }], [{
                key: "source",
                value: function() {
                    var t;
                    return {
                        token: new e((function(e) {
                            t = e
                        })),
                        cancel: t
                    }
                }
            }]), e
        }();
    var Be = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
    };
    Object.entries(Be).forEach((function(e) {
        var t = o(e, 2),
            n = t[0],
            r = t[1];
        Be[r] = n
    }));
    var Le = Be;
    var De = function e(t) {
        var n = new _e(t),
            r = a(_e.prototype.request, n);
        return q.extend(r, _e.prototype, n, {
            allOwnKeys: !0
        }), q.extend(r, n, null, {
            allOwnKeys: !0
        }), r.create = function(n) {
            return e(je(t, n))
        }, r
    }(se);
    return De.Axios = _e, De.CanceledError = ve, De.CancelToken = Fe, De.isCancel = ye, De.VERSION = Ne, De.toFormData = G, De.AxiosError = M, De.Cancel = De.CanceledError, De.all = function(e) {
        return Promise.all(e)
    }, De.spread = function(e) {
        return function(t) {
            return e.apply(null, t)
        }
    }, De.isAxiosError = function(e) {
        return q.isObject(e) && !0 === e.isAxiosError
    }, De.mergeConfig = je, De.AxiosHeaders = he, De.formToJSON = function(e) {
        return oe(q.isHTMLForm(e) ? new FormData(e) : e)
    }, De.HttpStatusCode = Le, De.
    default = De, De
}));
//# sourceMappingURL=axios.min.js.map
;(function(win) {
    'use strict';

    // TEMP: check for double loading
	if(win.FD && win.FD.Brand && win.FD.Brand.namespace) {
		return;
	}

    // setup general namespace
    var brand = createNamespace('FD.Brand', win);
    // add general app functions
    brand.namespace = createNamespace;
    brand.initComponent  = initComponent;
    brand.initTargetContent = initTargetContent;
    brand.setInitHandler = setInitHandler;
    brand.getTargetCampaignData = getTargetCampaignData;
    // component initialization registry
    var _compInitRegistry = [];
    var _initTargetCalled = false;
    //////

    /**
     * Create hierarchy of namespaced objects from root object
     * @param name
     * @param root
     */
    function createNamespace(name, root) {
        var ns = root || window;
        (name || '').split('.').forEach(function(v) {
            if(v.length > 0) {
                ns = ns[v] = ns[v] || {};
            }
        });
        return ns;
    }

    /**
     * Setup up component initialization handler to trigger on initialization event
     * @param component selector
     * @param initHandler
     */
    function setInitHandler(selector, initHandler) {
        _compInitRegistry.push({
            selector: selector,
            handler: initHandler
        });
    }

    /**
     * trigger initialization for components contained in given element
     * @param elementOrSelector DOM element or element selector
     */
    function initComponent(elementOrSelector) {
        var $el = jQuery(elementOrSelector);
        var $skipInitContainer = $el.find('[data-fgx-skip-sub-init]');
        var hasSkipInitContainer = !!($skipInitContainer && $skipInitContainer.length > 0);
        _compInitRegistry.forEach(function(componentInit) {
            var $comp = $el.find(componentInit.selector).not('[data-fgx-init]');
            if (hasSkipInitContainer) {
                $comp = $comp.not($skipInitContainer.find(componentInit.selector));
            }
            if($comp.length > 0) {
            	$comp.attr('data-fgx-init', 1);
				try {
				    componentInit.handler($comp);
				} catch(e) {
					console.log('An error occurred initializing component selector ' + componentInit.selector, e);
				}
            }
        });
    }

    /**
     * Get the data necessary for the campaign click ids utilized by target
     */
    function getTargetCampaignData(cookieName) {
        var experienceName = win.ttMETA && ttMETA[0] && ttMETA[0].experience || '';
        var data = {
            initialized: !!(_initTargetCalled && experienceName),
            experienceName: experienceName,
            campaignTargetKey: '',
            campaignTmpl: '',
            debug: false
        };
        if (experienceName) {
            try {
                var util = brand && brand.Util,
                    fpiData = util && util.parameters.decode(util.cookie.get('FPI')) || {},
                    fpsData = util && JSON.parse(util.cookie.get('FPS_Target_VOI_Model_T1', true) || '{ }') || {},
                    voiData = Object.assign({}, (((cookieName || '').toLowerCase() === 'fps') ? fpsData : fpiData)),
                    model = voiData && voiData.model,
                    make = voiData && voiData.make,
                    vehicleInterest = (model) ? (((make && model.toLowerCase().indexOf(make) === -1) ? make + ' ' : '') + model) : 'na',
                    pageType = brand.Context && brand.Context.pageType || '',
                    campaignTargetKey = 'rsttid',
                    qs = util && util.url.queryString(),
                    qsObj = qs && qs.asObject(),
                    _debug = qsObj && qsObj.brandTargetDebug || false;
                switch(pageType) {
                    case 'HomePage':
                        campaignTargetKey = 'hptid';
                        break;
                    case 'VehicleHomePageBlackLabel':
                    case 'VehicleHomePage':
                        campaignTargetKey = 'vhptid';
                        break;
                }
                data.campaignTargetKey = campaignTargetKey;
                data.campaignTmpl = [experienceName, '{compName}', '{slideKey}', '{mtxTargetId}', vehicleInterest].join(':');
                if (_debug && (_debug === '1' || _debug === 'true')) {
                    data.debug = true;
                }
            } catch(e) {}
        }
        return data;
    }

    /**
     * Initialize content loaded by Target
     * @param selector - selector to Target content container
     */
    function initTargetContent(selector, _cookieName) {
        _initTargetCalled = true;
        // initialize components
        initComponent(selector);
        var $ = jQuery,
            cookieName = _cookieName || 'FPI',
            data = getTargetCampaignData(cookieName);
        if (!data.initialized) {
            return;
        }
        try {
            $('[data-fd-target-container] [data-fd-target-component]').each(function() {
                var $comp = $(this);
                if (!$comp.is('[data-fd-target-init]')) {
                    win.appendCampaignCodesTarget($comp, data.campaignTargetKey, data.campaignTmpl, data.debug);
                }
            });
        } catch(e) {
            console.log("An error occurred updating the target campaign tracking");
        }
    }

})(window);
/* inclusion of authentication.js from /services/js/authentication/authentication.js */

function AXZAuthenticator(rawCookie) {
    var debug = function(key, value) {
        // console.log(key + ' ' + value);
    }

    function trim(str, chars) {
        return ltrim(rtrim(str, chars), chars);
    }

    function ltrim(str, chars) {
        chars = chars || "\\s";
        return str.replace(new RegExp("^[" + chars + "]+", "g"), "");
    }

    function rtrim(str, chars) {
        chars = chars || "\\s";
        return str.replace(new RegExp("[" + chars + "]+$", "g"), "");
    }

    /*
     * Provides a convenient way to override the cookie for test cases
     */
    if (!rawCookie) {
        rawCookie = document.cookie;
    }

    var AUTHENTICATION_COOKIE_NAME = "AXZAuthCookie";
    var getAllCookies = function() {
        var allCookies = new Object();

        var ca = rawCookie.split(';');
        for ( var i = 0; i < ca.length; i++) {
            var c = ca[i];

            var cookieName = trim(c.substring(0, c.indexOf("=")));
            var cookieValue = trim(c.substring(c.indexOf("=") + 1, c.length));
            cookieValue = cookieValue.replace(/\"/g, "");
            debug(cookieName, cookieValue);
            if (cookieName !== '__proto__') { 
                allCookies[cookieName] = cookieValue;
            }
        }
        return allCookies;
    };

    var authCookie = (function() {
        var cookie = getAllCookies()[AUTHENTICATION_COOKIE_NAME];
        if (cookie && cookie.length > 20) {
            return cookie;
        }
    })();

    debug('authCookie', authCookie);

    var AZ_PLAN = "AZ";
    var FNX_PLAN = "FNX";
    var PRX_PLAN = "PRX";
    var SPX_PLAN = "SPX";
    var MSRP = "MSRP";
    var INVALID_PLAN = "Invalid Plan Identifier";

    /**
     * Constants for various plan types
     */
    this.AZ_PLAN = AZ_PLAN;
    this.FNX_PLAN = FNX_PLAN;
    this.PRX_PLAN = PRX_PLAN;
    this.SPX_PLAN = SPX_PLAN;
    this.MSRP = MSRP;
    this.INVALID_PLAN = INVALID_PLAN;

    /*
     * This function get the Plan Identifier
     */
    this.getPlanTypeForServices = function() {
        if (authCookie) {
            var planIdentifier = authCookie.substr(0, 10);
            var arrPlanIdentifier = planIdentifier.split("");
            var planCharIndex = parseInt(arrPlanIdentifier[0]);
            if (!this.validateCheckSum(arrPlanIdentifier, planCharIndex)) {
                return this.INVALID_PLAN;
            }
            if (arrPlanIdentifier[planCharIndex] === '1') {
                return this.AZ_PLAN;
            } else if (arrPlanIdentifier[planCharIndex] === '2') {
                return this.FNX_PLAN;
            } else if (arrPlanIdentifier[planCharIndex] === '3') {
                return this.PRX_PLAN;
            } else if (arrPlanIdentifier[planCharIndex] === '4') {
                return this.SPX_PLAN;
            } else {
                return MSRP;
            }
        } else {
            return MSRP;
        }
    }

    this.validateCheckSum = function(arrPlanIdentifier, planCharIndex) {
        var palnNum = parseInt(arrPlanIdentifier[planCharIndex]);
        var sum = 0;
        for (i = 0; i < arrPlanIdentifier.length; i++) {
            if (0 == i || planCharIndex == i)
                continue;
            sum += parseInt(arrPlanIdentifier[i])
        }
        var mod = sum % 10;
        var expectedMod = (planCharIndex + palnNum) % 10;
        if (expectedMod != mod) {
            return false;
        }

        return true;
    }

    /*
     * This is the only public method exposed by this object. The planType
     * parameter can be passed AS-IS to the services.
     */
    this.getPlanType = function() {
        return this.getPlanTypeForServices();
    }

    this.getPlanTypeForDisplay = function() {
        var planType = this.getPlanTypeForServices();
        if (planType === this.AZ_PLAN) {
            return 'A/Z Plan';
        } else if (planType === this.FNX_PLAN || planType === this.PRX_PLAN
            || planType === this.SPX_PLAN) {
            return 'X Plan';
        } else if (planType == this.INVALID_PLAN) {
            return 'Invalid Plan';
        } else {
            return 'MSRP';
        }
    };
}

function ThirdPartyAuthenticator() {
    // Save and Share js
    // BSR integration updates
    var context = FD.Brand.Context;
    var CDR_PROFILE_COOKIE_NAME = (context && context.settings && context.settings.env === 'prod') ? "cdrProfile" : "cdrProfile_qa";
    //var CDR_PROFILE_COOKIE_NAME = "cdrProfile_qa";
    var ACCESSTOKEN_COOKIE_NAME = "accessToken";
    var PROFILE_ID_COOKIE_NAME = "cdrprofileid";
    var PROVIDER_COOKIE_NAME = "cdrprofileprovider";
    var CREATION_STATUS_COOKIE_NAME = "profilecreationstatus";
    var CONSUMER_ID_COOKIE_NAME = "consumerId";
    var TIMESTAMP_COOKIE_NAME = "timestamp";
    var LHSESSIONID_COOKIE_NAME = "lhSessionId";
    var DOMAIN_NAME = ".ford.com";
    var COOKIE_PATH = "/";
    var POPUP_FEATURES = "height=250,width=400,status=no,location=no,toolbar=no,directories=no,menubar=no";
    var POPUP_NAME = "versataPopUp";

    this.getAuthWindow = function(redirectUrl) {
        url = '/debug/thirdparty.jsp?redirectUrl=' + redirectUrl/*
         * document.location.host +
         * '/debug/redirect.jsp'
         */;
        features = POPUP_FEATURES;
        window[POPUP_NAME] = open(url, '', features);
    };
    this.popupCallback = function() {
        window[POPUP_NAME].close();
    };
    this.logoutUser = function() {
        deleteCookie(CDR_PROFILE_COOKIE_NAME, COOKIE_PATH, getDomainName());
        //deleteCookie(PROFILE_ID_COOKIE_NAME, COOKIE_PATH, getDomainName());
        //deleteCookie(PROVIDER_COOKIE_NAME, COOKIE_PATH, getDomainName());
        //deleteCookie(CREATION_STATUS_COOKIE_NAME, COOKIE_PATH, getDomainName());
    };

    function getCDRProfileCookie() {
        var start = document.cookie.indexOf(CDR_PROFILE_COOKIE_NAME + "=");
        var len = start + CDR_PROFILE_COOKIE_NAME.length + 1;
        if ((!start) && (CDR_PROFILE_COOKIE_NAME != document.cookie.substring(0, CDR_PROFILE_COOKIE_NAME.length))) {
            return null;
        }

        if (start == -1)
            return null;

        var end = document.cookie.indexOf(";", len);
        if (end == -1)
            end = document.cookie.length;

        return(unescape(document.cookie.substring(len, end)));
    }

    function getCookie(name) {
        //Get the cdrProfile cookie
        var cdrProfileCookieValue = getCDRProfileCookie();

        if(cdrProfileCookieValue == null || cdrProfileCookieValue == "" || cdrProfileCookieValue == "null") {
            return null;
        }
        if(name == CDR_PROFILE_COOKIE_NAME) {
            return unescape(cdrProfileCookieValue);
        }
        var start1 = cdrProfileCookieValue.indexOf(name + "=");
        var len1 = start1 + name.length + 1;
        if ((!start1) && (name != cdrProfileCookieValue.substring(0, name.length))) {
            return null;
        }
        if (start1 == -1)
            return null;
        var end1 = cdrProfileCookieValue.indexOf("|", len1);
        if (end1 == -1)
            end1 = cdrProfileCookieValue.length;
        return unescape(cdrProfileCookieValue.substring(len1, end1));
    }

    function deleteCookie(name, path, domain) {
        if (getCookie(name))
            document.cookie = name + "=" + ((path) ? ";path=" + path : "")
                + ((domain) ? ";domain=" + domain : "")
                + ";expires=Thu, 01-Jan-1970 00:00:01 GMT";
    }
    function getDomainName() {
        var domainName = document.location.host;
        var urlParts;
        if (domainName.indexOf(".", 0) > 0) {
            domainName = domainName.split(":")[0];
            urlParts = domainName.split(".");
            domainName = "." + urlParts[urlParts.length - 2] + "."
                + urlParts[urlParts.length - 1];
        } else {
            domainName = ".ford.com";
        }
        return domainName;
    }
    this.getUserId = function() {
        return getCookie(PROFILE_ID_COOKIE_NAME);
    };
    this.getAccessToken = function() {
        return getCookie(ACCESSTOKEN_COOKIE_NAME);
    };
    this.getProvider = function() {
        return getCookie(PROVIDER_COOKIE_NAME);
    };
    this.getProfileStatus = function() {
        return getCookie(CREATION_STATUS_COOKIE_NAME);
    };
    this.getConsumerId = function() {
        return getCookie(CONSUMER_ID_COOKIE_NAME);
    };
    this.getTimestamp = function() {
        return getCookie(TIMESTAMP_COOKIE_NAME);
    };
    this.getLHSessionId = function() {
        return getCookie(LHSESSIONID_COOKIE_NAME);
    };

}
;(function(win, $) {
    'use strict';

    $(init);

    //////

    function init() {
        $('html').addClass('fgx-brand-' + FD.Brand.Context.make);

        if(($('body').hasClass('cq-wcm-preview') || $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-design')) && (FD.Brand.Context.settings && !FD.Brand.Context.settings.syn)){
            $('body').addClass('fgx-pantry-bootstrap');
            $('body').addClass('fgx-brand-css');
        }

        FD.Brand.initComponent('body');
        if(FD.Brand.Angular) {
            FD.Brand.Angular.bootstrap();
        }

    }

})(window, jQuery);

(function($) {

    // jQuery extension to find matching elements including the current element
    $.fn.findAll = function(selector) {
        var result = this.find(selector);
        return (this.is(selector)) ?
            result.add(this) : result;
    };

})(jQuery);


/*global FD*/

(function(win, $, brand, context) {

    // utility library
    Object.assign(brand.namespace('FD.Brand.Util', win), {
        addMoreLink: addMoreLink,
        updateMoreLink: updateMoreLink,
        moreLessInit: moreLessInit,
        ctaHover: ctaHover,
        swapColors: swapColors,
        currentBreakpoint: currentBreakpoint,
		    currentBreakpointWithMedPlus: currentBreakpointWithMedPlus,
        currentBreakpointXS: currentBreakpointWithXS,
        currentBreakpointBCS: currentBreakpointBCS,
        log: log,
        toArray: toArray,
        objPath: objPath,
        objPathAsArray: objPathAsArray,
        searchGoogleObjPath: searchGoogleObjPath,
        inViewport: inViewport,
        isSafari: isSafari,
        parseStringAsBoolean: parseStringAsBoolean,
        isMobile: isMobile,
        cookie: {
            get: getCookie,
            set: setCookie,
            remove: removeCookie
        },
        parameters: {
            encode: encodeParameters,
            decode: decodeParameters
        },
        url: {
            queryString: queryString,
            loadAsScript: loadScript,
            loadAsStyle: loadStyle,
            extension: extension,
            protocol: protocol,
            prepend: prependToUrl,
            urlObject: urlObject,
            allowScript: allowScript
        },
        dateTime: {
            longFormat: longDateFormat
        },
        env: {
            browser: getBrowserInfo,
            geoLocation: function() {
                return _hasGeoLocation;
            },
            touch: function() {
                return _touchEnabled;
            }
        },
        images: {
            load: loadImages,
            renditionUrl: getRenditionUrl,
            stripRenditionUrl: stripRenditionUrl,
            renderPicture: renderPicture,
            defaultSource: retrieveDefaultSource,
            currentSource: getCurrentSource
        },
        video: {
            addRefTag: addRefTag,
            loadVideos: loadVideos,
            loadVideosInViewport: loadVideosInViewport
        },
        accordion: {
            update: updateAccordion,
            hideAnimContent: hideAnimatedAccContent
        },
        carousel: {
            swipe: carouselSwipe
        },
        distance: {
            betweenCoords: getDistanceBetweenCoords
        },
        window: {
            scrollTo: windowScrollTo,
            animateToElement: animateToElement
        },
        htmlString: {
            encode: encodeHtml,
            decode: decodeHtml
        },
        str: {
            firstInstance: retrieveFirstInstance,
            toObject: convertToObject,
            trimFromEnd: trimFromEnd,
            stripMarkup: stripMarkup
        },
        vdm: {
            displayName: getVdmDisplayName,
            allVdmNameplates: getAllVdmNameplates
        },
        mainNav: {
            get: getMainNav,
            setFullWidth: setFullWidthMainNav,
            getStickyNav: getStickyNavElement
        },
        commonHeight: {
            setup: setupCommonHeightItem,
			      update: updateCommonHeightItem
        },
        alwaysResolve: alwaysResolveDeferred,
        debounce: debounce,
        throttle: throttle,
        isEmpty: isEmpty,
        groupBy: groupBy
    });

    var _mbpEl = null,
        _hasGeoLocation = false,
        _touchEnabled = (('ontouchstart' in win) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)),
        _mainNavData = {
            Ford: {
                selectors: '.fordMainNavigation,.fordMainNavigationR23',
                currentCls: 'fordMainNavigation',
                $el: null
            },
            Lincoln: {
                selectors: '.lincolnMainNavigation',
                currentCls: 'lincolnMainNavigation',
                $el: null
            }
        }[(context && context.make) || 'Ford'],
        _mainNavSelectors = _mainNavData.selectors,
        $baseStickyNavEl = null,
        $stickyNavEl = null,
        _commonHeightItems = [],
        _commonHeightResize_d = null;

    _mbpEl = document.querySelector('.mbp-test');
    if(!_mbpEl) {
        _mbpEl = document.createElement('div');
        _mbpEl.classList.add('mbp-test');
        document.body.appendChild(_mbpEl);
    }

    _hasGeoLocation = false;
    if (window.navigator.geolocation) {
        if(window.navigator.permissions && window.navigator.permissions.query) {
            // check permission to handle Chrome ver 50+ which disables geolocation on HTTP
            window.navigator.permissions.query({
                name:'geolocation'
            }).then(function(p) {
                if(p.state !== 'denied') {
                    _hasGeoLocation = true;
                }
            })
        } else {
            // permissions API not available on IE, but geo locate should be available if detected
            // but only if we're https
            if (protocol().get() === 'https://') {
                _hasGeoLocation = true;
            }
        }
    }
    
    // focusout listener for custom dropdown elements
    $('body').on('focusout', '[data-fgx-dd-close-on-focusout]', dropdownCloseOnFocusOut);
    function dropdownCloseOnFocusOut(ev) {
        window.setTimeout(function(){
            var $active = $(document.activeElement);
            if ($active.closest('.fgx-custom-select').length <= 0) {
                // we know we're off any dropdown, close any that are open
                $('.fgx-custom-select[aria-expanded="true"] .fgx-custom-select-container').removeClass('shown');
                $('.fgx-custom-select[aria-expanded="true"] .fgx-custom-select-dropdown').removeClass('shown');
                $('.fgx-custom-select[aria-expanded="true"]').attr('aria-expanded', 'false');
            } else {
                var $dropdown = $active.closest('.fgx-custom-select');
                var $listElements = $('li', $dropdown);
                var activeId = $active.attr('id');
                var matchFound = false;
                if ($active.attr("class") !== 'fgx-custom-list-options' && activeId !== $dropdown.attr('id')) {
                    $listElements.each(function(){
                        $li = $(this);
                        if (activeId === $li.attr('id')) {
                            matchFound = true;
                        }
                    });
                    if (!matchFound) {
                        // we're not on an options list or the original dropdown and we got here so none of our <li> ids match...close this dropdown.
                        $('.fgx-custom-select[aria-expanded="true"] .fgx-custom-select-container').removeClass('shown');
                        $('.fgx-custom-select[aria-expanded="true"] .fgx-custom-select-dropdown').removeClass('shown');
                        $('.fgx-custom-select[aria-expanded="true"]').attr('aria-expanded', 'false');
                    }
                }
            }
        }, 250);
    }

    function groupBy(xs, key) {
        return xs.reduce(function(rv, x) {
            (rv[x[key]] = rv[x[key]] || []).push(x);
            return rv;
        }, {});
    }

    /**
     * @param content - The content to search through
     * @param charLimit - The original character limit
     * @returns a new character limit to be used
     * Check if we are in the middle of an html tag with the current charLimit
     *
     */
    function checkForHtml(content, charLimit) {
        var initial = content.substr(0, charLimit);
        var inTag = false;
        var addToEnd = 0; //Number of characters needed to get out of current html tag.
        var firstOpen = initial.indexOf('<');

        //Now check for an opening tag in the initial section
        if(firstOpen >= 0) {
            // if loop through the characters starting from the end, then we can
            // look for both a '<' and '>'. If we come across a '<' without
            // seeing a '>' first, then we are in a tag. If we are in a tag, then
            // we need to get out of it before continuing.
            for(var i = (charLimit - 1); i > 0; i--) {
                if(initial[i] === '<') {
                    inTag = true;
                    break;
                } else if(initial[i] === '>') {
                    inTag = false;
                    break;
                }
            }
            if(inTag) {
                for(var k = charLimit; k < content.length; k++) {
                    if(content[k] === '>') {
                        inTag = false;
                        addToEnd = ((k + 1) - charLimit);
                        break;
                    }
                }
                charLimit += addToEnd;
            }
        }
        return charLimit;
    }

    /**
     * @param components - The jQuery object that represents the element/component to make these updates in. (required)
     * @param charLimit - The character limit that should be allowed before the 'add more' link is added
     * @param selector - optional selector to add the 'more' link to
     *
     * Modifies the html at the given selector to add a '...more' link if the content exceeds the specified 'charLimit'.
     * This also adds the click event needed to show/hide the desired text.
     */
    function addMoreLink(components, charLimit, selector) {
        //Text should show the 'more' link if > 3 lines.
        var charLimit = charLimit || 100,
            selector = selector || '.description',
            linkSelector = selector + ' a.read_more',
            moreText = "...more",
            lessText = "...less";
        $(selector, components).each(function() {
            var content = $(this).html();
            if(content.length > charLimit) {
                charLimit = checkForHtml(content, charLimit);
                var initial = content.substr(0, charLimit),
                    hidden = content.substr(charLimit, content.length - charLimit),
                    html = "<span class='initial_desc'>" + initial + "</span><span class='more_text'>" + hidden + "</span><span><a href='#' class='read_more'>" + moreText + "</a></span>";

                $(this).html(html);
            }
        });

        $(linkSelector, components).click(function(event) {
            event.preventDefault();
            if($(this).hasClass("less")) {
                $(this).removeClass("less");
                $(this).html(moreText);
                $(this).parent().siblings('.more_text').removeClass("show-inline-force");
            } else {
                $(this).addClass("less");
                $(this).html(lessText);
                $(this).parent().siblings('.more_text').addClass("show-inline-force");
            }
        });
    }

    /**
     * @param components - The jQuery object that represents the element/component to make these updates in. (required)
     * @param charLimit - The new character limit that should be allowed before the 'add more' link is added
     * @param selector - optional selector to add the 'more' link to
     *
     * Resize the number of characters that are displayed before read_more
     */
    function updateMoreLink(components, charLimit, selector) {
        var selector = selector || '.description';
        $(selector, components).each(function() {
            var initial = $(this).children('.initial_desc').html();
            var hidden = $(this).children('.more_text').html();
            var content = initial + hidden;

            if(content.length > charLimit) {
                charLimit = checkForHtml(content, charLimit);
                $(this).find('.read_more').removeClass('hidden');
                $(this).children('.more_text').removeClass('hidden');
                initial = content.substr(0, charLimit);
                hidden = content.substr(charLimit, content.length - charLimit);
                $(this).children('.initial_desc').html(initial);
                $(this).children('.more_text').html(hidden);
            } else {
                $(this).find('.read_more').addClass('hidden');
                $(this).children('.more_text').addClass('hidden');
                $(this).children('.more_text').html('');
                $(this).children('.initial_desc').html(content);
            }
        });
    }

    function moreLessCheckHeight(actual, visible, link) {
        if(actual > visible) {
            link.find("span.mlspanless").hide();
            link.find("span.mlspanmore").show();
            link.show();
            return true;
        } else {
            link.hide();
            return false;
        }
    }

    /**
     * @param components - The jQuery object that represents the element/component to make these updates in. (required)
     * @param setupClickHandler - Boolean to indicate if the link click handler needs to be added or not. (required)
     * @param height - The height (in em) that should be allowed before the 'add more' link is added
     * @param selector - optional selector to add the 'more' link to
     *
     * Modifies the html at the given selector to show/hide a '...more' link if the content exceeds the specified height.
     * This also adds the click event needed to show/hide the desired text if the 'setupClickHandler' value is true.
     */
    function moreLessInit(components, setupClickHandler, height, lineHeight, selector) {
        var selector = selector || '.ml-wrapper',
            height = height || 3,
            //lineHeight = lineHeight || 1.15;
            lineHeight = $("html").hasClass("fgx-brand-Ford") ? (lineHeight || 1.15) : 1.6;

        height = (height * lineHeight) + "em";
        //height = height + "em";

        $(selector, components).each(function() {
            var $wrap = $(this),
                $link = $wrap.children(".mllink"),
                $content = $wrap.children(".mltext"),
                visibleHeight,
                actualHeight,
                $carouselItem;

            // If part of a carousel and its hidden, then we need to add a workaround to get the height.
            if($wrap.closest(".carousel").length === 1 && !$content.is(":visible")) {
                $carouselItem = $wrap.closest(".item");
                $carouselItem.addClass("hiddenHeight");
            }

            $content.css("height",height);
            $content.removeClass("mltext-more");
            visibleHeight = $content[0].clientHeight;
            actualHeight = $content[0].scrollHeight - 1;

            if($carouselItem && $carouselItem.hasClass("hiddenHeight")) { $carouselItem.removeClass("hiddenHeight"); }

            //Only show if height is greater - may need to add authorable buffer.
            if(!moreLessCheckHeight(actualHeight, visibleHeight, $link)) {
                $content.addClass("mltext-more");
            } else {
                $content.removeClass("mltext-more");
            }

            if(setupClickHandler) {
                $link.on("click", function() {
                    $content.toggleClass("mltext-more");
                    $link.find("span.mlspanmore").toggle();
                    $link.find("span.mlspanless").toggle();
                    return false;
                });
            }
        });
    }

    /**
     * @param elm - The jQuery object containing the set of button elements hover should be applied to.
     *
     * Setup a listener to call swapColors when the element is hovered.
     */
    function ctaHover(elm) {
    //dont want to block swapColors if .default-hover detected on Lincoln, so separate cases
        elm.each(function() {
            if ( !$('html').hasClass('fgx-brand-Lincoln') && !$(this).hasClass('default-hover') ) {
                $(this).hover(function() {
                    swapColors.call(this);
                }, function() {
                    swapColors.call(this);
                });
            }
        });
    }

    /**
     * Swap the backgroundColor and the textColor
     * This needs to be called using .call so 'this' gets set properly.
     */
    function swapColors() {
        var currBackground = $(this).css('backgroundColor'),
            currColor = $(this).css('color');
        $(this).css('color', currBackground);
        $(this).css('backgroundColor', currColor);
    }


    /**
     * get the uiBreakpoint
     */
    function currentBreakpoint() {

        _mbpWdth = _mbpEl.offsetWidth;

        if(_mbpWdth < 768) {
            return 'gux-bkpt-sm';
        } else if (_mbpWdth < 992) {
            return 'gux-bkpt-med';
        } else if (_mbpWdth < 1200) {
            return 'gux-bkpt-lg';
        } else {
            return 'gux-bkpt-xlg';
        }

    }
	
    /**
     * get the uiBreakpoint with med-plus as an option to distinguish between tablet breakpoints
     */
    function currentBreakpointWithMedPlus() {

        _mbpWdth = _mbpEl.offsetWidth;

        if(_mbpWdth < 768) {
            return 'gux-bkpt-sm';
        } else if (_mbpWdth < 992) {
            return 'gux-bkpt-med';
        } else if (_mbpWdth < 1068) {
            return 'gux-bkpt-med-plus';
		} else if (_mbpWdth < 1200) {
            return 'gux-bkpt-lg';
        } else {
            return 'gux-bkpt-xlg';
        }

    }

    /**
     * get the uiBreakpoint with extra small as an option to distinguish between mobile breakpoints
     */
    function currentBreakpointWithXS() {
        _mbpWdth = _mbpEl.offsetWidth;

        if(_mbpWdth < 480) {
            return 'gux-bkpt-xs';
        } else if(_mbpWdth < 768) {
            return 'gux-bkpt-sm';
        } else if (_mbpWdth < 992) {
            return 'gux-bkpt-med';
        } else if (_mbpWdth < 1200) {
            return 'gux-bkpt-lg';
        } else {
            return 'gux-bkpt-xlg';
        }
    }

    /**
     * get the uiBreakpoint based on the values used for the Brand Core Styles (BCS)
     */
    function currentBreakpointBCS() {
        _mbpWdth = _mbpEl.offsetWidth;

        if (_mbpWdth < 960) {
            return 'gux-bkpt-sm';
        } else {
            return 'gux-bkpt-lg';
        }
    }

    /**
     * Return cookie value
     * @param name
     * @param decode
     * @returns {*}
     */
    function getCookie(name, decode) {
        var val = null;
        (document.cookie || '').split('; ').forEach(function(ck) {
            var p = ck.indexOf('=');
            if(ck.substring(0, p) === name) {
                val = ck.substring(p + 1);
                if(decode) {
                    val = decodeURIComponent(val);
                }
                return false;
            }
        });
        return val;
    }

    /**
     * Set cookie value
     * @param name
     * @param value
     * @param opt { expires: Date, path: String, domain: String, secure: Boolean, encodeValue: Boolean }
     */
    function setCookie(name, value, opt) {
        var ck = [ encodeURIComponent(name), '=', (opt.encodeValue) ? encodeURIComponent(value) : value],
            dt;
        if(opt.expires) {
            if(Object.prototype.toString.call(opt.expires) !== '[object Date]') {
                var dt = new Date();
                dt.setTime(dt.getTime() + (opt.expires * 24 * 60 * 60 * 1000));
            } else {
                dt = opt.expires;
            }
            ck.push('; expires=' + dt.toUTCString());
        }
        if(opt.path) {
            ck.push('; path=' + opt.path);
        }
        if(opt.domain) {
            ck.push('; domain=' + opt.domain);
        }
        if(opt.secure) {
            ck.push('; secure');
        }
        document.cookie = ck.join('');
    }

    /**
     * Remove cookie
     * @param name
     */
    function removeCookie(name) {
        setCookie(name, null, { expires: new Date('Thu, 01 Jan 1970 00:00:00 GMT')});
    }

    /**
     * Return parameters as URI encoded query string
     * @param param
     * @param enc
     * @returns {*}
     */
    function encodeParameters(param, enc) {
        var lst = [];
        Object.keys(param).forEach(function(k) {
            lst.push(encodeURIComponent(k) + '=' + encodeURIComponent(param[k]));
        });
        var val = lst.join('&');
        if(enc) {
            var val2 = [], j = Math.floor(Math.random() * 223 + 33);
            val2.push(String.fromCharCode(j));
            for(var i = 0; i < val.length; i++) {
                j = val.charCodeAt(i) ^ j & 255;
                val2.push(String.fromCharCode(j));
            }
            val = btoa(val2.join(''));
        }
        return val;
    }

    /**
     * Return parameters decoded from URI encoded query string
     * @param str
     * @returns {Mixed|*}
     */
    function decodeParameters(str) {
        var param = {};
        (str || '').split('&').forEach(function(kv) {
            var p = kv.indexOf('=');
            if(p >= 0) {
                param[decodeURIComponent(kv.substring(0, p))] = decodeURIComponent((kv.substring(p + 1)));
            }
        });
        return param;
    }

    /**
     * Query string parser/ builder
     * @param str
     * @returns {queryStringHelper}
     */
    function queryString(str) {
        return new queryStringHelper(decodeParameters((str || window.location.search || '').substring(1)));

        function queryStringHelper(prm) {
            var _this = this,
                _prm = prm;

            _this.add = add;
            _this.remove = remove;
            _this.asObject = asObject;
            _this.asString = asString;
            _this.addToUrl = addToUrl;

            return _this;

            /**
             * Add parameters to query string
             * If prm is an object, key/value pairs from object are added to query string parameters
             * If prm is a string it is used as the key with val as the value of the new added parameter
             * @param prm
             * @param val
             * @returns {queryStringHelper}
             */
            function add(prm, val) {
                if (prm != null && typeof prm == 'object') {
                    _prm = Object.assign(_prm, prm);
                } else {
                    _prm[prm] = val;
                }
                return _this;
            }

            /**
             * Remove parameters from query string
             * keys parameter can be a single string or an array of strings
             * @param keys
             * @returns {queryStringHelper}
             */
            function remove(keys) {
                toArray(keys).forEach(function(k) {
                    delete _prm[k];
                });
                return _this;
            }

            /**
             * Returns current list of query string parameters as object
             * @returns {*}
             */
            function asObject() {
                return _prm;
            }

            /**
             * Returns query string parameters as encoded query string
             * @returns {string}
             */
            function asString() {
                var str = encodeParameters(_prm);
                return ((str.length > 0) ? '?' : '') + str;
            }

            /**
             * Returns passed in url with the encoded query string parameters appended to it
             * @param url - url to append the query string to
             * @returns {string}
             */
            function addToUrl(url) {
                var output = '';
                if(url && typeof(url) !== 'undefined') {
                    var qsPos = url.indexOf('?');
                    var urlBase = url;
                    if(qsPos >= 0) {
                        var str = url.substring(qsPos);
                        var qs = brand.Util.url.queryString(str);
                        urlBase = url.substring(0, qsPos);
                        _this.add(qs.asObject());
                    }
                    output = urlBase + _this.asString();
                }
                return output;
            }
        }

    }

    function loadScript(src, attrs, preserveElement) {
        var head = (document.getElementsByTagName('head')[0] || document.documentElement),
            scr = document.createElement('script'),
            done = false,
            def = $.Deferred();
        scr.onload = scr.onreadystatechange = function () {
            if(!done && (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete')) {
                done = true;
                scr.onload = scr.onreadystatechange = null;
                if(head && scr.parentNode && !preserveElement) {
                    head.removeChild(scr);
                }
                scr = undefined;
                def.resolve();
            }
        };
        scr.onerror = function() {
            def.reject();
        };
        head.appendChild(scr);
        scr.setAttribute('type', 'text/javascript');
        if(attrs) {
            Object.keys(attrs).forEach(function (key) {
                scr.setAttribute(key, attrs[key]);
            });
        }
        scr.setAttribute('src', src);
        return def.promise();
    }

    function loadStyle(src) {
        var styleLink = $('<link>').attr({
                rel: 'stylesheet',
                type: 'text/css',
                href: src
            });
        $('head').append(styleLink);
    }

    function protocol(url) {
        return new protocolHelper(url || window.location.href || '');

        function protocolHelper(url) {
            var _this = this;
            var _url = url;
            _this.get = get;
            _this.set = set;
            _this.remove = remove;
            _this.url = function() {
                return _url;
            };

            function get() {
                var r = _url.match(/^(https?:)?\/\//i);
                return r ? r[0] : '';
            }

            function set(protocol) {
                protocol = protocol || (window.location.protocol + '//');
                remove();
                _url = protocol + _url;
                return _this;
            }

            function remove() {
                _url = _url.replace(/^(https?:|)\/\//, '');
                return _this;
            }
        }
    }

    function extension(str) {
        return new extensionHelper((str || location.pathname || ''));

        function extensionHelper(prm) {
            var _this = this,
                _prm = prm;

            _this.remove = remove;
            _this.removeSpecified = removeSpecified;

            return _this;

            /**
             * Remove the extension
             * @returns {string}
             */
            function remove() {
                _prm = _prm.replace(/\.[^/.]+$/, "");
                return _prm;
            }

            /**
             * Remove the specified extension
             * The full extension needs to be passed in to work properly.
             * @param ext
             * @returns {string}
             */
            function removeSpecified(ext) {
                var pos = (_prm.length - ext.length);

                if(_prm.substr(pos) === ext) {
                    _prm = _prm.substr(0, pos);
                }

                return _prm;
            }

        }
    }

    function prependToUrl(url, str) {
        return (url.indexOf(str) !== 0) ? str + url : url;
    }

    /**
     * URL string parser/ builder
     * @param str
     * @returns {urlObjectHelper}
     */
    function urlObject(url) {
        return new urlObjectHelper((url || window.location.href || ''));

        function urlObjectHelper(url) {
            var _this = this,
                _originalUrlStr = url,
                _anchor = document.createElement('a'),
                _isSmartLink = !!(_originalUrlStr.substr(0, 2) === '#$'),
                _smartLinkBase = _originalUrlStr,
                _skipUpdate = checkSkipUpdate();

            _anchor.href = _originalUrlStr;
            if(_isSmartLink) {
                var qsPos = _originalUrlStr.indexOf('?');
                if(qsPos > -1) {
                    _smartLinkBase = _smartLinkBase.substring(0, qsPos);
                    _anchor.search = _originalUrlStr.substring(qsPos);
                } else {
                    _anchor.search = ' ';
                }
            }

            _this.isSmartLink = _isSmartLink;
            _this.skipUpdate = _skipUpdate;
            _this.getHash = getHash;
            _this.setHash = setHash;
            _this.qs = brand.Util.url.queryString(_anchor.search || ' ');
            _this.url = getUrl;
            _this.anchor = function() {
                return _anchor;
            }

            function getHash() {
                return _anchor.hash.substring(1);
            }

            function setHash(_hash, extend) {
                extend = extend || false;
                if(_hash && typeof(_hash) !== 'undefined') {
                    _anchor.hash = (extend) ? (_anchor.hash + _hash) : _hash;
                }
            }

            function getUrl() {
                if (_this.skipUpdate) {
                    return _originalUrlStr;
                }
                // Need to update the search property with the latest from the qs object in case that has been updated
                // using the qs.add functionality.
                _anchor.search = _this.qs.asString();

                // Using the anchor.href will return a fully quantified URL which will break smartLinks, so if we have a
                // smartLink we should just return the base and the queryString if one was added.
                return (_this.isSmartLink) ? (_smartLinkBase + _anchor.search) : _anchor.href;
            }

            function checkSkipUpdate() {
                return (!_isSmartLink && (_originalUrlStr.slice(0, 1) === '#' || _originalUrlStr.indexOf('javascript:void(0)') === 0));
            }

            return _this;
        }
    }

    function longDateFormat(dt) {
        var dt = dt || new Date();
        var template = {
            'en_us': '<%- MMMM %> <%- d %>, <%- y %>',
            'es_us': '<%- d %> de <%- MMMM %> de <%- y %>',
            'en_ca': '<%- MMMM %> <%- d %>, <%- y %>',
            'fr_ca': '<%- d %> <%- MMMM %> <%- y %>'
        }[context.locale];
        return (brand.Util.template(template))({
            MMMM: context.localizedMonthNames[dt.getMonth()],
            d: dt.getDate(),
            y: dt.getFullYear()
        });
    }

    function getBrowserInfo() {
        var ua = navigator.userAgent,
            tem, M = ua.match(/(android|opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (/trident/i.test(M[1])) {
            tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
            return {
                name: 'IE ',
                version: (tem[1] || '')
            };
        }
        if (M[1] === 'Chrome') {
            tem = ua.match(/\bOPR\/(\d+)/)
            if (tem !== null) {
                return {
                    name: 'Opera',
                    version: tem[1]
                };
            }
        }
        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
        if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
            M.splice(1, 1, tem[1]);
        }
        return {
            name: M[0].toLowerCase(),
            version: parseInt(M[1],10)
        };
    }

    function isSafari() {
        const ua = navigator.userAgent.toLowerCase();

        return ua.indexOf('safari') !== -1 && ua.indexOf('chrome') < 0;
    }

    function isMobile() {
        return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
    }

    /**
     * Parses AEM (string) booleans into actual boolean
     * @param {*} string string boolean form AEM
     */
    function parseStringAsBoolean(string = '') {
        if (string.toLowerCase() === 'true') {
            return true;
        }
        return false;
    }

    function log() {
        if(win.console && console.log) {
            if(console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                for(var i=0; i < arguments.length; i++) {
                    console.log(arguments[i]);
                }
            }
        }
    }

    function toArray(ar) {
        return (ar == null) ? null : ($.isArray(ar) ? ar : [ ar ]);
    }

    function objPath(obj, path) {
        var p = (path || '').split('.');
        for(var i = 0; i < p.length; i++) {
            var n = p[i];
            if(n.length == 0 || typeof(obj[n]) === 'undefined') {
                return null;
            }
            obj = obj[n];
        }
        return obj;
    }

    function searchGoogleObjPath(obj) {
        if(typeof(obj.suggestions) === 'undefined') {
            return null;
        }
        obj = obj.suggestions;
        return obj;
    }

    function objPathAsArray(obj, path) {
        return toArray(objPath(obj, path) || []);
    }

    function loadImages(elm) {
        //This is needed to load the Images in the overlay on IE.

        // Only continue if picture is not supported.
        if ( win.HTMLPictureElement ) {
            return;
        }

        var imgs = getAllImages(elm),
            opts = {
                elements: imgs
            };
        win.picturefill(opts);
    }

    function getAllImages(elm) {
        // This comes from picturefill, but slightly modified to only check for images in the mediaOverlay.
        var elems = [],
            imgs = $('img', elm);

        for ( var h = 0, len = imgs.length; h < len; h++ ) {
            var currImg = imgs[ h ];

            if ( currImg.parentNode.nodeName.toUpperCase() === "PICTURE" ||
            ( currImg.getAttribute( "srcset" ) !== null ) || currImg[ "picturefill" ] && currImg[ "picturefill" ].srcset !== null ) {
                elems.push( currImg );
            }
        }
        return elems;
    }

    function getRenditionUrl(sourceUrl, rendition) {
        return sourceUrl && sourceUrl + '/jcr:content/renditions/' + (rendition || 'original' + sourceUrl.substring(sourceUrl.lastIndex('.')));
    }

    function stripRenditionUrl(url) {
        var index1 = url.indexOf("/jcr:content/renditions/"),
            index2 = url.indexOf("/_jcr_content/renditions/"),
            index = (index1 > -1) ? index1 : index2;
        if(index > -1) {
            url = url.substring(0, index);
        }
        return url;
    }

    /**
     * nullAlt - When this parameter is true, the alt tag of the image will be set to an empty string regardless of the authored value.
     */
    function renderPicture(image, view, override, nullAlt, isInline) {
        var sources = image && (view && image.views && image.views[view]) || override || image && image.sources || [];
        var $picture = $('<picture/>');
        var defaultSource = sources[0];
        sources.forEach(function(source) {
            if(source.breakpoint > 0) {
                $('<source/>')
                    .attr('data-srcset', source.src)
                    .attr('media', '(min-width: ' + source.breakpoint + 'px)')
                    .appendTo($picture);
                if(source.defaultSource) {
                    defaultSource = source;
                }
            }
        });
        if(defaultSource && !isInline) {
            var _nullAlt = (nullAlt || image.altTag === '#NULL#') || false;
            $('<img/>')
                .attr('data-srcset', defaultSource.src)
                .addClass('lazyload')
                .addClass(image.className)
                .attr('alt', (!_nullAlt && image.altTag || '').trim())
                .appendTo($picture);
        } else if(defaultSource) {
            $('<img/>')
                .attr('data-srcset', defaultSource?.src)
                .attr('src', defaultSource?.src)
                .addClass('inlineImages')
                .addClass(image?.className)
                .attr('alt', (image?.altTag || '').trim())
                .appendTo($picture);
        }
        return $picture;
    }

    function retrieveDefaultSource(image, view, override) {
        var sources = image && (view && image.views && image.views[view]) || override || image && image.sources || [];
        var defaultSource = sources[0];
        sources.forEach(function(source) {
            if(source.breakpoint > 0 && source.defaultSource) {
                defaultSource = source;
            }
        });
        return (!isEmpty(defaultSource)) ? defaultSource : null;
    }

    function getCurrentSource(image, view, override) {
        var sources = image && (view && image.views && image.views[view]) || override || image && image.sources || [],
            outputSource = sources[0] || {};
        if(sources && sources.length > 1) {
            var currWidth = $(win)[0].innerWidth,
                sortedSources = sources.concat().sort(function(s1, s2) {
                    return s2.breakpoint - s1.breakpoint;
                });

            sortedSources.forEach(function(source) {
                if(source.breakpoint > 0 && source.breakpoint <= currWidth) {
                    outputSource = source;
                }
            });
        }
        return outputSource;
    }

    function addRefTag(videoId) {
        return (videoId.indexOf("ref:") > -1) ? videoId : ("ref:" + videoId);
    }

    function loadVideosInViewport($videos) {
        if(!$videos || $videos.length === 0) {
            return;
        }

        $videos.each(function() {
            var $video = $(this),
                initialized = $video.attr('data-fgx-video-initialized');
            if((initialized == 'false' || !initialized) && inViewport($video) && $video.css('display') != 'none' && $video.css('visibility') != 'hidden') {
                loadVideo($video);
            }
        });
    }

    function loadVideos($videos) {
        if(!$videos || $videos.length === 0) {
            return;
        }

        $videos.each(function() {
            var $video = $(this),
                initialized = $video.attr('data-fgx-video-initialized');
            if(initialized == 'false' || !initialized) {
                loadVideo($video);
            }
        });
    }

    function loadVideo($video) {
        var src = $video.attr('src'),
            fgxSource = $video.attr('data-fgx-src');

        if(src && typeof(src) != 'undefined') {
            return;
        }

        if(fgxSource && typeof(fgxSource) != 'undefined') {
            $video.attr('src', fgxSource);
            $video.attr('data-fgx-video-initialized', 'true');
            $video[0].load();
        }
    }

    /**
     * Check if the passed in jQuery element is within the current viewport
     * @returns boolean
     */
    function inViewport(elm) {
        if(!elm || !elm.length) {
            return false;
        }

        var $win = $(win),
            vp = {
                top: $win.scrollTop(),
                left: $win.scrollLeft()
            };

        vp.bottom = vp.top + $win.height();

        var elmBorder = elm.offset();
        elmBorder.bottom = elmBorder.top + elm.outerHeight(true);

        return !((elmBorder.bottom <= vp.top) || (elmBorder.top >= vp.bottom));
    }

    /**
     * Open / Close the accordion element that is passed in as well as close any other
     * accordion elements that are currently open within the same context.
     * @param elm - The current element that is to be updated (required)
     * @param components - The context this element should be found within (required)
     * @param headingSelector - Custom selector for the heading of the accordion. Default ".accordion-heading" (optional)
     * @param contentSelector - Custom selector for the content of the accordion. Default ".accordion-content" (optional)
     * @param initialLoad - Boolean value to indicate if the updateAccordion is being called on initial page load. If so the animation will be skipped.
     * @param callback - Callback function that will be called after the accordion has been opened / closed. (optional)
     * @param accItemSelector - Selector for an element that surrounds the individual accordion item. When passed in, the
     *     accordion content element will be found as a child of this accordion item, rather than the next element after the heading element. (optional)
     * @param deferHide - Boolean - When true, the 'hidden' class won't be applied to closing content sections until after
     *     their animation has completed. Only use this property if the content section has an animation/transition applied. (optional)
     * @param noAnimEvSelector - String - Indicate the selector(s) of an element within the content section for which the
     *     animation event callback should be ignored. This is currently only used if deferHide is true. Potential use case
     *     could be ignoring the animation end event that propagates up from child elements to help ensure the logic doesn't
     *     fire before the animation on the container is complete. (optional)
     */
    function updateAccordion(elm, components, headingSelector, contentSelector, initialLoad, callback, accItemSelector, deferHide, noAnimEvSelector) {
        var $el = elm,
            hS = headingSelector || ".accordion-heading",
            hSOpen = hS + ".open",
            cS = contentSelector || ".accordion-content",
            cSOpen = cS + ".open",
            skipAnimation = (initialLoad) ? true : false,
            $contentEl,
			events = 'animationend webkitAnimationEnd MSAnimationEnd transitionend webkitTransitionEnd';

        if(!$el || $el.length === 0 || !components || components.length === 0) {
            return;
        }

        $contentEl = (accItemSelector && !isEmpty(accItemSelector) && $el.closest(accItemSelector).length > 0) ? $el.closest(accItemSelector).find(cS) : $el.next(cS);

        if ($el.hasClass('open')) {
            $el.toggleClass('open');
            $el.attr('aria-expanded', 'false');
			if (deferHide) {
				hideAnimatedAccContent($contentEl, noAnimEvSelector);
			} else {
				$contentEl.toggleClass('open').addClass('hidden');
			}
        } else {
            $(hSOpen, components).removeClass('open').attr('aria-expanded', 'false');
			if (deferHide) {
				hideAnimatedAccContent($(cSOpen, components), noAnimEvSelector);
			} else {
				$(cSOpen, components).removeClass('open').addClass('hidden');
			}
            $el.toggleClass('open');
            $el.attr('aria-expanded', 'true');

            if(skipAnimation) {
                $contentEl.removeClass('hidden').show().toggleClass('open');
            } else {
                $contentEl.removeClass('hidden').show().toggleClass('open').one(events, function(){
                    $('html, body').animate({
                    //compensate for static navbar
                    scrollTop: $el.offset().top - $('.navbar-static-top').height()
                    }, 200);
                });
            }
        }
        // call our callback if we have one
        if (typeof callback != 'undefined') {
            callback.call($el);
        }
    }

    /**
     * Close the accordion content section, but wait for the animation end events before adding the 'hidden' class.
     * accordion elements that are currently open within the same context.
     * @param $contentEl - Element representing the accordion content that should be closed. (required)
     * @param noAnimEvSelector - String - Indicate the selector(s) of an element within the content section for which the
     *     animation event callback should be ignored. Potential use case could be ignoring the animation end event that
     *     propagates up from child elements to help ensure the logic doesn't fire before the animation on the container is complete. (optional)
     * @param callback - function - provide a function that should be called once the content is hidden. (optional)
     */
    function hideAnimatedAccContent($contentEl, noAnimEvSelector, callback) {
        if (!$contentEl || $contentEl.length == 0) {
            return;
        }
        var $skipSubAnimEl = (noAnimEvSelector) ? $contentEl.find(noAnimEvSelector) : null,
            skipSubAnim = !!($skipSubAnimEl && $skipSubAnimEl.length > 0),
            events = 'animationend webkitAnimationEnd MSAnimationEnd transitionend webkitTransitionEnd';
        if (skipSubAnim) {
            $skipSubAnimEl.off(events).on(events, function(ev) {
                ev.stopPropagation();
            });
        }
        $contentEl.toggleClass('open', false).off(events).one(events, function(ev) {
            var $cEl = $(this);
            if (!$cEl.hasClass('open') && !$cEl.hasClass('hidden')) {
                // remove any extra event listeners for the animation events after this is triggered once.
                $cEl.addClass('hidden').off(events);
                if (callback && typeof(callback) == 'function') {
                    try {
                        callback($cEl);
                    } catch(e) { }
                }
            }

            if (skipSubAnim) {
                $skipSubAnimEl.off(events);
            }
        });
    }

    function carouselSwipe(el, fn, customOpts) {
        //var hammerTime = new Hammer(el);
        /* NZ: Note - the touchAction value below should be converted to 'pan-y' to help restrict the unintended
         * vertical scrolling that happens when trying to horizontally swipe on mobile devices.
        */
        var _defaultOpts = {
            touchAction: 'auto',
            domEvents: true,
            inputClass: Hammer.SUPPORT_POINTER_EVENTS ? Hammer.PointerEventInput : Hammer.TouchInput,
            recognizers: [
                [Hammer.Swipe, {
                    direction: Hammer.DIRECTION_HORIZONTAL
                }]
            ]
        };
        var _opts = Object.assign({}, _defaultOpts, customOpts || {});
        var hammerTime = new Hammer.Manager(el, _opts);
	    hammerTime.on('dragleft swipeleft dragright swiperight', function(ev) {
	        var hasSrcEvent = !!(ev && typeof(ev) != 'undefined' && ev.srcEvent);
	        switch(ev.type) {
                case 'swipeleft':
                case 'dragleft':
                    if(hasSrcEvent) {
                        ev.srcEvent.stopPropagation();
                    }
                    fn(el, 'next', ev);
                    break;
                case 'swiperight':
                case 'dragright':
                    if(hasSrcEvent) {
                        ev.srcEvent.stopPropagation();
                    }
                    fn(el, 'prev', ev);
                    break;
            }
	    });
    }

    function getDistanceBetweenCoords(lat1, lon1, lat2, lon2, addLabel) {
        var earthR = 6371; //in km
        var dLat = deg2rad(lat2-lat1);  // deg2rad below
        var dLon = deg2rad(lon2-lon1);
        var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
            Math.sin(dLon/2) * Math.sin(dLon/2);

        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var distKm = earthR * c; // Distance in km
        var distMi = distKm * 0.621371; // Convert to mi
        var d = {
            km: distKm.toFixed(2),
            mi: distMi.toFixed(2)
        };

        if(addLabel) {
            d.km = d.km + "km";
            d.mi = d.mi + "mi";
        }
        return d;
    }

    function deg2rad(deg) {
        return deg * (Math.PI/180)
    }

    function windowScrollTo(el, duration) {
        var $el = $(el);
        if($el.length === 0) {
            return;
        }
        var targetEl = $el.get(0);
        var startPos = window.scrollY || window.pageYOffset;
	    var stopPos = targetEl.getBoundingClientRect().top;
        var startTick = Date.now();
        function easing(t, b, c, d) {
	        if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        }
        function doScroll() {
            var elapsed = Date.now() - startTick;
            var nextPos = easing(elapsed, startPos, stopPos - startPos, duration);
            win.scrollTo(0, nextPos);
            if(elapsed >= duration) {
	            win.scrollTo(0, stopPos);
            } else {
                win.setTimeout(doScroll, 20);
            }
        }
	    win.setTimeout(doScroll, 20);
    }

    function animateToElement($el, _duration) {
        if ($el && $el.length > 0) {
            var $stickyNav = getStickyNavElement(),
                duration = (typeof(_duration) != 'undefined' && _duration != null) ? _duration : 200;
            $('html, body').animate({
                scrollTop: ($el.offset().top - (($stickyNav && $stickyNav.length > 0) ? $stickyNav.outerHeight() : 0))
            }, duration);
        }
    }

    //Encode HTML entities for strings used in data attributes.
    //Based on answer here: https://stackoverflow.com/questions/1219860/html-encoding-lost-when-attribute-read-from-input-field/7124052#7124052
    function encodeHtml(str) {
        if(str === null || typeof(str) == 'undefined') {
            return '';
        }
        return str
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, "&#39;")
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

    function decodeHtml(str) {
        return str
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
    }

    function retrieveFirstInstance(str, delimiter) {
        var output = '',
            delim = delimiter || ';';
        if(str && typeof(str) != 'undefined') {
            var tokens = str.split(delim);
            output = (str.length > 1) ? tokens[0] : str;
        }
        return output;
    }

    /**
     * Return items within the passed in string as an object of parameters.
     * @param str - should be a string containing a list of {key}={value} pairs with a delimiter
     * @param delimiter - define the delimiter that should be used to separate each set of {key}={value} pairs within the string
     * @returns {Mixed|*}
     */
    function convertToObject(str, delimiter) {
        var param = {},
            delim = delimiter || '&';
        (str || '').split(delim).forEach(function(kv) {
            var p = kv.indexOf('=');
            if(p >= 0) {
                param[kv.substring(0, p)] = (kv.substring(p + 1));
            }
        });
        return param;
    }

    /**
     * Return the string with the target value removed from the end (if the target is at the end of the string)
     * @param str - this is the original string to remove the target value from
     * @param target - this is the substring value that should be removed from the end of the passed in string (when found)
     * @returns String
     */
    function trimFromEnd(str, target) {
        if(str && target) {
            var num = target.length,
                negNum = 0 - num;

            if(str.slice(negNum) === target) {
                str = str.slice(0, str.length - num);
            }
        }
        return str;
    }

    /**
     * Remove any HTML markup from string
     * @param str
     * @returns {*|jQuery}
     */
    function stripMarkup(str) {
        return $($.parseHTML(str)).text().trim();
    }

    // window.FD.Brand.Util.uiBreakpoint();

    /**
     * Check OneTrust settings to see if script category is consent is given
     * @param cat - script category
     * @returns false if category consent is not given, true otherwise
     */
    function allowScript(cat) {
        var allow = true;
        if(context.region === 'US') {
            var cookie = getCookie('OptanonConsent');
            if (cookie) {
                var groups = ((decodeParameters(cookie) || {}).groups || '').split(',');
                if (groups.indexOf(cat + ':0') >= 0) {
                    allow = false;
                }
            }
        }
        return allow;
    }

    function getAllVdmNameplates(language, siteName) {
        var def = $.Deferred();
        $.getJSON( `/aemservices/vdm/api.json/v1/${language}/${siteName}/nameplate`)
          .done(function(response) {
              def.resolve(response);
          })
          .fail(function(jqXHR, textStatus, errorThrown) {
              console.error(`Issue getting all VDM nameplates: ${errorThrown}`);
              def.resolve([]);
          });
        return def.promise();
    }

    // BRAND-15880: pass in a vehicle data object with model, year, and optionally trim defined, and return that object
    // with the displayName and displayNameShort properties defined with the values from VDM.
    function getVdmDisplayName(vehData) {
        var def = $.Deferred();
        var vdmData = {
            locale: context && context.locale || 'en_us',
            make: context && context.make,
            model: vehData.model,
            year: vehData.year
        };
        if (vehData.trim) {
            vdmData.trim = vehData.trim;
        }

        var createDisplayName = function(modelName) {
            var vehicleName = modelName || vehData.model;
            if (vehData.trim) {
                vehicleName = vehicleName + ' ' + vehData.trim;
            }
            return (context && context.language === 'fr') ? (vehicleName + ' ' + vehData.year) : (vehData.year + ' ' + vehicleName);
        };

        $.getJSON('/aemservices/brand/api/vehicle/detail', vdmData).done(function(resp) {
            if (resp) {
                vehData.displayNameShort = resp.displayNameShort || '';
                vehData.metricsName = resp.metricsName || '';
                vehData.urlKey = resp.urlKey || '';
                // BRAND-15880: Do not set the displayName value here if the response type is a 'nameplate' but a trim is defined.
                // in this case, we'll try to create the proper displayName using the displayNameShort value and the year / trim
                // from the vehicle data.
                if (resp.type === 'model' || (resp.type === 'nameplate' && !vehData.trim)) {
                    vehData.displayName = resp.displayName || '';
                }
            }
            if (!vehData.displayName) {
                vehData.displayName = createDisplayName((resp.displayNameShort || ''));
            }
            def.resolve(vehData);
        }).fail(function(resp) {
            vehData.displayNameShort = '';
            vehData.metricsName = '';
            vehData.urlKey = '';
            vehData.displayName = createDisplayName();
            def.resolve(vehData);
        });

        return def.promise();
    }

    // returns jQuery object with the first instance of a main navigation element.
    function getMainNav() {
        if (!_mainNavData.$el) {
            _mainNavData.$el = $(_mainNavSelectors).first();
        }
        return _mainNavData.$el;
    }

    function setFullWidthMainNav(isFW) {
        if (typeof(isFW) !== 'undefined' && isFW !== null) {
            var $nav = getMainNav();
            $nav.toggleClass('fgx-nav-full-width', !!isFW);
        }
    }

    function getStickyNavElement() {
        if (!$stickyNavEl || $stickyNavEl.length === 0) {
            var $baseStickyNav = getBaseStickyNavElement(),
                $compareModels = $('[data-fgx-models-compare], [data-fgx-compare-models]');

            if ($compareModels.length > 0) {
                var _cmSelectorMbl = '.comparison.mobile-titles.ui-scrollfix',
                    _cmSelectorDsk = '.comparison.sticky-clone.ui-scrollfix',
                    $cmStickyEl = $compareModels.find((currentBreakpoint() === 'gux-bkpt-sm') ? _cmSelectorMbl : _cmSelectorDsk);
                // NZ - The sticky nav section within the compare models components changes based on breakpoint, so when
                // a CM component is found we return the element without storing it in the global $stickyNavEl variable.
                // In theory this should force this logic to run every time the method is called, which should ensure the
                // correct element is always returned for the current breakpoint.
                return ($cmStickyEl && $cmStickyEl.length > 0) ? $cmStickyEl : $baseStickyNav;
            }
            $stickyNavEl = $baseStickyNav;
        }
        return $stickyNavEl;
    }

    function getBaseStickyNavElement() {
        if (!$baseStickyNavEl || $baseStickyNavEl.length === 0) {
            var $mainNav = getMainNav(),
                $secondaryNav = $('.secondaryNavigation, .cmp-secondaryNavigation, .secondaryNavigationR23').first(),
                _hasSecondaryNav = !!($secondaryNav && $secondaryNav.length > 0);
            $baseStickyNavEl = (_hasSecondaryNav) ? $secondaryNav : $mainNav;
        }
        return $baseStickyNavEl;
    }

    /**
     * Setup the common height logic for the targeted elements. The targeted elements are defined by the 'selector' that
     * is passed in, and are restricted to the instances that are found within the $containerEl.
     * Once the targeted elements are found, this function will add an entry to the _commonHeightItems array, run the
     * updateCommonHeightItem logic initially (if desired), and setup the resize listener on the window if it hasn't already been setup.
     *
     * @param selector - (required) - the selector of the element that the logic should be applied to.
     * @param $containerEl - (recommended) - a jQuery object representing the element that the targeted elements should be
     *      found within. If this is not passed in, then the 'body' element will be used as the container.
     * @param bpArr - (optional) - an array of strings representing breakpoints that this logic should be excluded for.
     *      The values within the array should align with the values returned from the currentBreakpoint method above.
     *      If left blank, this logic will apply to all breakpoints.
     * @param updateOnInit - (optional) - a boolean value indicating whether the updateCommonHeightItem method should be
     *      run for these items initially.
	 * @param forceDisplayBlock - (optional) - a boolean value indicating whether the element should be forced to display as a block element before size is calculated 
     *
     */
    function setupCommonHeightItem(selector, $containerEl, bpArr, updateOnInit, forceDisplayBlock) {
        var $container = ($containerEl && $containerEl.length > 0) ? $containerEl : $('body'),
            $el = (selector) ? $(selector, $container) : null;
        if ($el && $el.length > 0) {
            var hItem = {
                'selector': selector,
                '$container': $container,
                '$el': $el,
                'excludedBPs': (!isEmpty(bpArr)) ? toArray(bpArr) : [],
				'forceDisplayBlock': (typeof forceDisplayBlock !== 'undefined') ? forceDisplayBlock : false
            };
            _commonHeightItems.push(hItem);

            if (updateOnInit) {
                setTimeout(function() {
                    updateCommonHeightItem(hItem);
                }, 100);
            }

            if (_commonHeightResize_d === null) {
                _commonHeightResize_d = debounce(handleCommonHeightResize, 50);
                $(win).on('resize', _commonHeightResize_d);
            }
        }
    }

    /**
     * Ensure the elements associated with the passed in item all have the same height.
     * i.e. the function will set the min-height of each element to match the height of the tallest instance.
     *
     * @param item - (required) - an object containing data / options that is used by the method to make the necessary updates.
     *      The properties within item include:
     *          -'selector':  The selector of the element that the logic should be applied to.
     *          -'$container': A jQuery object representing the element that the targeted elements should be found within.
     *          -'$el': A jQuery object representing the elements that the common height logic should be applied to.
     *          -'excludedBPs': An array of strings representing breakpoints that this logic should be excluded for.
     *              The values within the array should align with the values returned from the currentBreakpoint method above.
     */
    function updateCommonHeightItem(item) {
        if (item && item.$el && item.$el.length > 0) {
            var bp = currentBreakpoint(),
                $els = item.$el,
                maxHeight = 0;
            if (item.excludedBPs.indexOf(bp) === -1) {
				$els.addClass('fgx-no-min-height');
				if (item.forceDisplayBlock === true) {
					$els.addClass('fgx-brand-size-calc');
				}
                $els.each(function() {
                    var elH = $(this).height();
                    if (elH > maxHeight) {
                        maxHeight = elH;
                    }
                });
                $els.removeClass('fgx-no-min-height');
				if (item.forceDisplayBlock === true) {
					$els.removeClass('fgx-brand-size-calc');
				}
            }
            $els.css('min-height', maxHeight || '');
        }
    }

    /**
     * Call the updateCommonHeightItem method for each item in the _commonHeightItems array.
     */
    function handleCommonHeightResize() {
        (_commonHeightItems || []).forEach(function(hItem) {
            updateCommonHeightItem(hItem);
        });
    }

    /**
     * Debounce calls to given function
     * i.e. function is only called after no other calls are made after given wait period
     * @param fn to debounce
     * @param period in ms
     * @returns {function(): void}
     *
     * NOTE - this was ported over from the aem64 branch of Pantry. Once we merge the changes from the aem64 branches into
     * mavice-ci, it might make more sense to remove this function and update the instances that rely on it to utilize the
     * function from Pantry.
     */
    function debounce(fn, period) {
        let timeout = null;
        return function() {
            let ctx = this;
            let args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(function() {
                timeout = null;
                fn.apply(ctx, args);
            }, period);
        };
    }

    /**
     * Throttle calls to given function
     * i.e. function can only be called at most once within the given time period
     * @param fn to throttle
     * @param period in ms
     * @returns {(function(): void)|*}
     */
    function throttle(fn, period) {
        let lastTime = 0;
        let timeout = null;
        return function() {
            let ctx = this;
            let args = arguments;
            if(!lastTime) {
                fn.apply(ctx, args);
                lastTime = Date.now();
            } else {
                clearTimeout(timeout);
                timeout = setTimeout(function() {
                    if(Date.now() - lastTime >= period) { 
                        fn.apply(ctx, args);
                        lastTime = Date.now();
                    }
                }, period - (Date.now() - lastTime));
            }
        }
    }

    function isString(val) {
        return Object.prototype.toString.call(val) === '[object String]';
    }

    function isEmpty(val) {
        if(val == null) {
            return true;
        }
        if(Array.isArray(val) || isString(val)) {
            return !val.length;
        }
        return !Object.keys(val).length;
    }

    /**
     * This will call the function that is passed in and will return a new deferred object that is always resolved (regardless
     * of whether the original promise was resolved or rejected). The data returned from the original function will be
     * appended with a new 'bsrCallSuccess' property before being used to resolve the new promise. This new 'bsrCallSuccess'
     * property is a boolean that can be used to indicate whether the original call succeeded or failed (it will be true
     * if the original promise was resolved, false otherwise).
     *
     * @param fn - the function to call.
     */
    function alwaysResolveDeferred(fn) {
        return $.Deferred(function (defer) {
            var handleResolve = function(isSuccess, data) {
                defer.resolve(Object.assign({}, {'bsrCallSuccess': isSuccess}, data || {}));
            };
            if (fn && typeof(fn) === 'function') {
                try {
                    fn().then(function(_data) {
                        handleResolve(true, _data);
                    }, function(err) {
                        handleResolve(false, err);
                    });
                } catch(e) {
                    handleResolve(false, {});
                }
            } else {
                handleResolve(false, {});
            }
        }).promise();
    }


})(window, jQuery, FD.Brand, FD.Brand.Context);
/*global FD*/
/**
 * Template support library
 */
(function(win, brand) {

    Object.assign(brand.namespace('FD.Brand.Util', win), {
        template: template,
        unescapeHtmlCharacters: unescapeHtmlCharacters
    });

    /**
     * lodash 3.10.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modern modularize exports="npm" -o ./`
     * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
        object || (object = {});

        var index = -1,
            length = props.length;

        while (++index < length) {
            var key = props[index];
            object[key] = source[key];
        }
        return object;
    }

    /**
     * Converts `value` to a string if it's not one. An empty string is returned
     * for `null` or `undefined` values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
        return value == null ? '' : (value + '');
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * returned by `keysFunc`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
        var index = -1,
            length = props.length,
            result = Array(length);

        while (++index < length) {
            result[index] = object[props[index]];
        }
        return result;
    }

    /** Used to detect unsigned integer values. */
    var reIsUint = /^\d+$/;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
        return function(object) {
            return object == null ? undefined : object[key];
        };
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
        return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
        value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
            return false;
        }
        var type = typeof index;
        if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
        }
        return false;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
        // Avoid a V8 JIT bug in Chrome 19-20.
        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
        var type = typeof value;
        return !!value && (type == 'object' || type == 'function');
    }

    /** Used to match template delimiters. */
    var reInterpolate = /<%=([\s\S]+?)%>/g;

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
        if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
        return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);

            while (++index < length) {
                rest[index] = args[start + index];
            }
            switch (start) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, args[0], rest);
                case 2: return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
                otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
        };
    }

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** Used to match HTML entities and HTML characters. */
    var reUnescapedHtml = /[&<>"'`]/g,
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

    /** Used to map characters to HTML entities. */
    var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
    };

    /**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
    }

    function unescapeHtmlCharacters(str) {
        if(str && typeof str === 'string') {
            Object.keys(htmlEscapes).forEach(function(key) {
                str = str.replaceAll(htmlEscapes[key], key);
            });
        }
        return str;
    }

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
        return !!value && typeof value == 'object';
    }

    /**
     * Converts `value` to a string if it's not one. An empty string is returned
     * for `null` and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
            return value;
        }
        if (value == null) {
            return '';
        }
        var result = (value + '');
        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in IE < 9, they can break out of
     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
        string = toString(string);
        return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
    }

    /** Used to match template delimiters. */
    var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g;

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var templateSettings = {

        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type RegExp
         */
        'escape': reEscape,

        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type RegExp
         */
        'evaluate': reEvaluate,

        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type RegExp
         */
        'interpolate': reInterpolate,

        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type string
         */
        'variable': '',

        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type Object
         */
        'imports': {

            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type Function
             */
            '_': { 'escape': escape }
        }
    };

    /** `Object#toString` result references. */
    var errorTag = '[object Error]';

    /** Used to match empty string literals in compiled template source. */
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

    /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

    /** Used to ensure capturing order of template delimiters. */
    var reNoMatch = /($^)/;

    /** Used to match unescaped characters in compiled string literals. */
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

    /** Used to escape characters for inclusion in compiled string literals. */
    var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };

    /**
     * Used by `_.template` to escape characters for inclusion in compiled string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
    }

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
        return (objectValue === undefined || !hasOwnProperty.call(object, key))
            ? sourceValue
            : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
        var index = -1,
            props = Object.keys(source),
            length = props.length;

        while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);

            if ((result === result ? (result !== value) : (value === value)) ||
                (value === undefined && !(key in object))) {
                object[key] = result;
            }
        }
        return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
        return source == null
            ? object
            : baseCopy(source, Object.keys(source), object);
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
        return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
        // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
        var settings = templateSettings;

        if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
        }
        string = baseToString(string);
        options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

        var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
            importsKeys = Object.keys(imports),
            importsValues = baseValues(imports, importsKeys);

        var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";

        // Compile the regexp to match each delimiter.
        var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
            , 'g');

        // Use a sourceURL for easier debugging.
        var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';

        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);

            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

            // Replace delimiters with snippets.
            if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;

            // The JS engine embedded in Adobe products requires returning the `match`
            // string in order to produce the correct `offset` value.
            return match;
        });

        source += "';\n";

        // If `variable` is not specified wrap a with-statement around the generated
        // code to add the data object to the top of the scope chain.
        var variable = options.variable;
        if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
        }
        // Cleanup code by stripping empty strings.
        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');

        // Frame code as the function body.
        source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
                    ? ''
                    : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
                    ? ', __e = _.escape'
                    : ''
            ) +
            (isEvaluating
                    ? ', __j = Array.prototype.join;\n' +
                    "function print() { __p += __j.call(arguments, '') }\n"
                    : ';\n'
            ) +
            source +
            'return __p\n}';

        var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
        });

        // Provide the compiled function's source by its `toString` method or
        // the `source` property as a convenience for inlining compiled templates.
        result.source = source;
        if (isError(result)) {
            throw result;
        }
        return result;
    }

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
        try {
            return func.apply(undefined, args);
        } catch(e) {
            return isError(e) ? e : new Error(e);
        }
    });

})(window, FD.Brand);


/*global FD*/
/**
 * User support library
 */
(function(win, $, brand, util, ctx) {

    Object.assign(brand.namespace('FD.Brand.User', win), {
        location: topicFactory('location', getLocation, {
            detail: getAsyncTopic(getLocationDetail),
            setPostalCode: setPostalCode,
            setGeoPACode: setGeoPACode,
            coordinates: getLocationCoordinates
        }),
        pricing: topicFactory('pricing', getPricing),
        authentication: topicFactory('authentication', getAsyncTopic(initAuth), {
            login: function() {
                authLogin();
            },
            logout: function() {
                authLogout();
            },
            register: function() {
                authRegister();
            },
            checkSession: checkAuthStatus
        }),
        fps: topicFactory('fps', getAsyncTopic(initFps), {
            get: getFps,
            set: setFps,
            notification: {
                getAll: getAllFpsNotifications
            }
        }),
        dealer: topicFactory('dealer', getAsyncTopic(getDealer), {
            setPreferred: setPreferredDealer,
            removePreferred: removePreferredDealer,
            refresh: refresh
        }),
        profile: topicFactory('profile', getAsyncTopic(getProfile))
    });

    var _locationState = null;
    var _locationDetail = null;
    var _locationCoordinates = null;
    var _pricingState = null;
    var _authenticationState = null;
    var _fpsState = null;
    var _profileState = null;
    var _dealerState = null;
    var _fpsAuthTypeMap = {
        'anon': 'CSDN-G',
        'user': 'CSDN'
    };
    var _fpsLocale = {
        'en_us': 'EN_US',
        'es_us': 'SP_US',
        'en_ca': 'EN_CA',
        'fr_ca': 'FR_CA'
    }[ctx && ctx.locale || 'en_us'];

    var _initFps = brand.User.fps.current;
    var _initAuth = brand.User.authentication.current;
    var _fmaRedirectUrl = null;
    var _fmaUseAzure = false;

    var secureServiceBaseUrl = ctx.settings['ngbsSecureUrl' + ctx.make];
    var fpsBaseUrl = ctx.settings.fpsUrl;
    var profileMpsHost = ctx.settings.clwMpsHost;

    $(init);

    //////

    function init() {
        var np = ctx.nameplate;
        if(np) {
            updateFPI({
                make: ctx.make,
                model: np.ngpModelName,
                year: np.ngpYear,
                html: false
            });
        } else {
            updateFPI({
                make: ctx.make,
                html: false
            });
        }
    }

    function topicFactory(topic, fCurrent, methods) {
        return Object.assign({
            subscribe: function(callback, skipInit) {
                return subscribeTopic(topic, callback, skipInit !== true && fCurrent());
            },
            unsubscribe: unsubscribeTopic,
            current: fCurrent
        }, methods || {});
    }

    // publish/subscribe support

    var _topics = {};
    var _nextHandleId = 0;

    function publishTopic(topic, data, callback) {
        if(!_topics[topic]) {
            return false;
        }
        setTimeout(function notifyTopic() {
            (callback ? [{ callback: callback }] : _topics[topic]).forEach(function(subscriber) {
                try {
                    subscriber.callback(data, topic);
                } catch(ex) {
                    util.log('user.lib: error occurred publishing state topic ' + topic, data, ex);
                }
            })
        }, 0);
        return true;
    }

    function subscribeTopic(topic, callback, initialData) {
        if(!_topics[topic]) {
            _topics[topic] = []
        }
        var handle = {
            topic: topic,
            id: ++_nextHandleId
        };
        _topics[topic].push({
            handle: handle,
            callback: callback
        });
        if(initialData) {
            $.when(initialData).done(function(result) {
                publishTopic(topic, result, callback);
            });
        }
        return handle;
    }

    function unsubscribeTopic(handle) {
        var topic = _topics[handle.topic];
        if(topic) {
            var idx = topic.findIndex(function(i) { return i.handle.id === handle.id });
            if(idx > -1) {
                topic.splice(idx, 1);
            }
        }
    }

    // helper for topics retrieved asynchronously
    // wraps a common promise that is returned
    // deferred is passed into load function and resolved when topic is loaded
    // this makes the function reentrant without initiating multiple requests to load topic
	function getAsyncTopic(fnLoad) {
		var promise = null;
		var fn = function() {
			var def;
			if(promise === null) {
				def = $.Deferred();
				promise = def.promise();
				fnLoad(def);
			}
			return promise;
		};
		fn.$_reset = function() {
		    promise = null;
        };
		return fn;
	}

	/// Location state support

    function getLocation() {
        if(!_locationState) {
            _locationState = {};
            // read postal code from FPI cookie if available
            var val = util.cookie.get('FPI');
            if (val) {
                val = util.parameters.decode(val);
                if (val && val.zip) {
                    _locationState.postalCode = val.zip;
                    _locationState.postalCodeSource = 'FPI';
                }

                if (val && val.geoPACode) {
                    _locationState.geoPACode = val.geoPACode;
                }
            }
            // if no FPI, read postal code from userInfo cookie if available
            if (!_locationState.postalCode) {
                (util.cookie.get('userInfo') || '').split(',').forEach(function (val) {
                    if (val.substr(0, 4) === 'zip=') {
                        // ensure we're pulling 6 digits for CA and only 5 for US
                        _locationState.postalCode = val.substr(4, (ctx.region === 'CA' ? 6 : 5));
                        _locationState.postalCodeSource = 'Akamai';
                    }
                });
            }
            if(ctx.region === 'CA' && (!_locationState.postalCode || !/^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\d{1}[A-Za-z]{1} *\d{1}[A-Za-z]{1}\d{1}$/.test(_locationState.postalCode))) {
                _locationState.postalCode = 'L6J5E4';
                _locationState.postalCodeSource = 'Default';
            }
        }
        return stateValue(_locationState);
    }

    function getLocationDetail(def) {
        if(_locationDetail) {
            def.resolve(_locationDetail);
        } else {
            FD.Brand.NgpServices.location(getLocation().postalCode).then(function(resp) {
                if(resp) {
                    if(ctx.region === 'CA') {
                        var province = resp.Provinces && resp.Provinces.Province && resp.Provinces.Province.content;
                        _locationDetail = {
                            geoKey: province,
                            province: province,
                            regions: null,
                            regionDetails: null
                        };
                    } else {
                        _locationDetail = {
                            geoKey: resp.GeoKey,
                            state: resp.States && resp.States.State && resp.States.State.content,
                            regions: (resp.Regions.Region || []).reduce(function(obj, region) {
                                obj[region.type] = region.Code;
                                return obj;
                            }, {}),
                            regionDetails: (resp.Regions.Region || []).reduce(function(obj, region) {
                                obj[region.type] = region;
                                return obj;
                            }, {})
                        }
                    }
                    if(_locationState.postalCode) {
                        // make dealer call to get default dealer for metrics
                        var params = {
                            make: ctx.make,
                            radius: 50,
                            minDealers: 1,
                            maxDealers: 1,
                            postalCode: _locationState.postalCode
                        };

                        if(_locationState.geoPACode) {
                            params.prefDealerPACode = _locationState.geoPACode;
                        }
                        FD.Brand.NgpServices.dealers(params).done(function(dealers) {
                            if(!dealers || dealers.length === 0) {
                                // resolve promise without adding to location detail
                                def.resolve(_locationDetail);
                            } else {
                                if(_locationDetail) {
                                    _locationDetail.paCode = (dealers[0].PACode) ? dealers[0].PACode : '';
                                }
                                def.resolve(_locationDetail);
                            }
                        });
                    }
                }
            }, function() {
                def.resolve(_locationDetail);
            });
        }
    }

    function setPostalCode(postalCode, geoPACode) {
        if(_locationState && _locationState.postalCode === 'postalCode' && _locationState === 'user') {
            return;
        }
        _locationState = _locationState || {};
        _locationState.postalCode = postalCode;
        _locationState.postalCodeSource = 'user';

        if(geoPACode) {
            _locationState.geoPACode = geoPACode;
        } else if(_locationState.geoPACode) {
            delete _locationState.geoPACode;
        }

        if(_locationDetail !== null) {
	        _locationDetail = null;
	        brand.User.location.detail.$_reset();
        }
        updateFPI({
            zip: postalCode,
            geoPACode: geoPACode || ''
        });
        publishTopic('location', getLocation())
    }


    function setGeoPACode(geoPACode) {
        _locationState = _locationState || {};
        if(geoPACode) {
            _locationState.geoPACode = geoPACode;
        } else if(_locationState.geoPACode) {
            delete _locationState.geoPACode;
        }
        updateFPI({
            geoPACode: _locationState.geoPACode || ''
        });
    }

    function getLocationCoordinates() {
        if(!_locationCoordinates) {
            _locationCoordinates = {};
            if(util.env.geoLocation()) {
                window.navigator.geolocation.getCurrentPosition(function(pos) {
                    if(pos && pos.coords) {
                        _locationCoordinates.lat = pos.coords.latitude;
                        _locationCoordinates.lon = pos.coords.longitude;
                    }
                });
            }
        }
        return stateValue(_locationCoordinates);
    }

    /// Pricing state support

    function getPricing() {
        if(!_pricingState) {
            _pricingState = {};
            // read plan type from Authenticator library
            if (ctx.region === 'CA' || typeof win.AXZAuthenticator === 'undefined') {
                _pricingState.planType = 'MSRP';
            } else {
                _pricingState.planType = (new win.AXZAuthenticator()).getPlanType();
            }
            _pricingState.pricePlan = {
                MSRP: 'MSRP',
                AZ: 'AZPLAN',
                SPX: 'XPLAN',
                FNX: 'XPLAN',
                PRX: 'XPLAN'
            }[_pricingState.planType];
        }
        return stateValue(_pricingState);
    }

    /// Authentication state support


    function initAuth(def) {

        var authApplicationId = ctx.clwApplicationId;
        var authCiClientId = ctx.ciClientId;
        _fmaUseAzure = ctx.fmaUseAzureAuth === 'enabled';

        var resolveState = function() {
            var fma = win.fma;
            var newState = {};
            if (fma) {
                if (fma.isAuthenticated) {
                    newState = {
                        authType: 'user',
                        accessToken: fma.CATBundle && fma.CATBundle.access_token,
                        authToken: fma.CATBundle && fma.CATBundle.cat1_token,
                        authProvider: 'owner',
                        userId: fma.CATBundle && fma.CATBundle.userId,
                        userLogin: 'login: owner'
                    };
                } else {
                    if (fma.guestUserGuid) {
                        newState = {
                            authType: 'anon',
                            authProvider: 'anonymous',
                            userId: fma.guestUserGuid,
                            userLogin: 'login: current pc'
                        };
                    }
                }
            }
            _authenticationState = Object.assign({
                loaded: !!fma,
                applicationId: authApplicationId,
                ciClientId: authCiClientId,
                authType: 'none',
                userLogin: 'logged out'
            }, newState);
            def.resolve(stateValue(_authenticationState));
            util.log('user.lib: auth state', _authenticationState);
        };

        if(_authenticationState) {
            resolveState();
        } else {
            $('body').on('fma_authenticated fma_unauthenticated', resolveState);
            var settings = ctx && ctx.settings || {};
            if(!win.fma && !(settings.syn && ctx.includeFMAScriptIfSyndicated === 'exclude')) {
                var fmaDataObj = {
                    'data-fma-script': '',
                    'data-app-id': authApplicationId,
                    'data-region': 'na',
                    'data-lang': ctx.locale,
                    'data-property-key': {
                        'USFord': 'brand_ford',
                        'USLincoln': 'brand_lincoln',
                        'CAFord': 'brand_ford_ca',
                        'CALincoln': 'brand_lincoln_ca'
                    } [ctx.region + ctx.make]
                };
                // retrieve config value and, if it exists, set 'data-fs-url' attribute
                var dataFSUrl = settings.fmaDataFSUrl;
                if (typeof dataFSUrl !== 'undefined' && dataFSUrl.length > 0) {
                    fmaDataObj['data-fs-url'] = dataFSUrl;
                }
                if (useAltAuthRedirect()) {
                    _fmaRedirectUrl = brand.Link && brand.Link.baseUrl('profileLanding');
                }
                if(_fmaUseAzure) {
                    fmaDataObj['data-client-id'] = authCiClientId;
                    if (_fmaRedirectUrl) {
                        // redirect to fixed page after auth
                        fmaDataObj['data-redirect-url'] = _fmaRedirectUrl;
                    } else {
                        // redirect to interim page and then current page after auth
                        fmaDataObj['data-base-path'] = '/';
                        fmaDataObj['data-base-path-redirection'] = 'true';
                        fmaDataObj['data-redirect-url'] = authFullUrl(ctx.fmaRedirectPagePath || '/login/');
                    }
                } else {
                    fmaDataObj['data-ibm-cid'] = authCiClientId;
                    _fmaRedirectUrl = _fmaRedirectUrl || win.location.href;
                }
                util.url.loadAsScript(settings.fmaIncludeScript, fmaDataObj, true).done(function() {
                    if(!win.fma) {
                        util.log('user.lib: FMA library failed to initialize');
                        resolveState();
                    }
                    // loaded, will resolve in fma event handler
                }).fail(function(resp) {
                    util.log('user.lib: failed to load FMA library', resp);
                    resolveState();
                });
            }
            // if isAuthentication is defined, FMA has already determined auth state so resolve
            if(win.fma && win.fma.isAuthenticated !== undefined) {
                resolveState()
            }
        }

    }

    // TODO: check if needed
    function checkAuthStatus() {
        var def = $.Deferred();
        def.resolve(stateValue(_authenticationState));
        return def.promise();
    }

    function authFullUrl(url) {
        return ['http://', 'https://', '//'].some(function(p) { return url.startsWith(p) })
            ? url
            : window.location.origin
            + (url.startsWith('/') ? '' : '/')
            + url;
    }

    function authLogin() {
        _initAuth().done(function() {
            if(win.fma) {
                if(!_fmaUseAzure) {
                    win.fma.model.config.redirectUrl = _fmaRedirectUrl;
                }
                win.fma.login();
            }
        });
    }

    function authLogout() {
        _initAuth().done(function() {
            if(win.fma) {
                win.fma.logout();
            }
        });
    }

    function authRegister() {
        _initAuth().done(function() {
            if(win.fma) {
                win.fma.register();
            }
        });
    }


    /// Profile state support

    function getProfile(def) {
        var resolveState = function() {
            def.resolve(stateValue(_profileState));
        };
        if(_profileState) {
            resolveState();
        } else {
            FD.Brand.User.authentication.current().then(function(authState) {
                if(authState && authState.authType === 'user') {
                    $.ajax({
                        url: profileMpsHost + '/api/users',
                        dataType: 'json',
                        headers: {
                            'Auth-Token': authState.authToken,
                            'Application-Id': authState.applicationId
                        }
                    }).done(function(resp) {
                        _profileState = resp && resp.profile;
                        resolveState();
                    }).fail(function(resp) {
                        util.log('user.lib: Get User Profile failed', resp);
                        resolveState();
                    });
                } else {
                    util.log('user.lib: User not logged in, no profile is available');
                    resolveState();
                }
            });
        }

    }

    /// Dealer state support

    function getDealer(def) {
        var resolveState = function() {
            def.resolve(stateValue(_dealerState));
        };
        if(_dealerState) {
            resolveState();
        } else {
            _dealerState = {};
            _initFps().done(function(fpsState) {
                if(fpsState.loaded) {
                    getFps([{
                        PreferredDealer: {
                            max: 1
                        }
                    }]).done(function (val) {
                        var lst = val && val.length > 0 && val[0].PreferredDealer;
                        if (lst) {
                            var dealerCodes = lst.map(function(i) { return i._paCode; }),
                                location = getLocation(),
                                postalCode = (location && location.postalCode) ? location.postalCode : '';

                            if (dealerCodes.length > 0) {
                                FD.Brand.NgpServices.dealer({
                                    make: ctx.make,
                                    dealerPACode: dealerCodes[0],
                                    customerPostalCode: postalCode
                                }).done(function (dealer) {
                                    _dealerState.preferred = dealer;
                                    resolveState();
                                }).fail(resolveState);
                                return;
                            }
                        }
                        resolveState();
                    }).fail(resolveState);
                } else {
                    resolveState();
                }
            });
        }
    }

    function setPreferredDealer(dealerPaCode) {
        var def = $.Deferred();
        if(_dealerState.preferred && _dealerState.preferred.PACode === dealerPaCode) {
            def.resolve();
        } else {
	        _initFps().done(function(fpsState) {
                FD.Brand.NgpServices.dealer({
                    make: ctx.make,
                    dealerPACode: dealerPaCode
                }).done(function(dealer) {
                    if(dealer) {
                        setFps([FPS.lib.PreferredDealer(dealerPaCode, dealer.Name)]).done(function(val) {
	                        _dealerState.preferred = dealer;
                            brand.User.dealer.current.$_reset();
                            publishTopic('dealer', stateValue(_dealerState));
                            def.resolve();
                        }).fail(function() {
                            def.reject();
                        });
                    } else {
                        util.log('user.lib: no dealer found for ' + dealerPaCode);
                        def.reject();
                    }
                }).fail(function() {
                    def.reject();
                });
            });
        }
        return def.promise();
   }
   
   function removePreferredDealer(dealerPaCode) {
       var def = $.Deferred();
       if(_dealerState.preferred && _dealerState.preferred.PACode !== dealerPaCode) {
           def.resolve();
       } else {
           _initFps().done(function(fpsState) {
               FD.Brand.NgpServices.dealer({
                   make: ctx.make,
                   dealerPACode: dealerPaCode
               }).done(function(dealer) {
                   if(dealer) {
                       setFps([{PreferredDealer: { _paCode: dealerPaCode, description: dealer.Name }, metadata: { active: 'false' }}]).done(function(val) {
                           if(_dealerState.preferred) {
                               _dealerState.preferred = null;
                               brand.User.dealer.current.$_reset();
                           }
                           publishTopic('dealer', stateValue(_dealerState));
                           def.resolve();
                       }).fail(function() {
                           def.reject();
                       });
                   } else {
                       util.log('user.lib: no dealer found for ' + dealerPaCode);
                       def.reject();
                   }
               }).fail(function() {
                   def.reject();
               });
           });
       }
       return def.promise();
   }

   function refresh() {
       var preferredPaCode = function() {
           return _dealerState && _dealerState.preferred && _dealerState.preferred.PACode || '';
       };
       var paCode = preferredPaCode();
       _dealerState = null;
	   brand.User.dealer.current.$_reset();
       return brand.User.dealer.current().done(function() {
           if(preferredPaCode() !== paCode) {
               publishTopic('dealer', stateValue(_dealerState));
           }
       });
   }

    // FPS state support

    function initFps(def) {
        var resolveState = function() {
            def.resolve(stateValue(_fpsState));
        };
        var initState = function() {
            // BRAND-15757: set the locale on the FPS.config object after loading FPS.
            win.FPS.config.locale = _fpsLocale;
            _fpsState.locale = _fpsLocale;
            _fpsState.loaded = true;
            _initAuth().done(function(authState) {
                var userId = authState && authState.userId;
                //NZ - refType added as part of BRAND-13612
                var refType = _fpsAuthTypeMap[(authState && authState.authType) || ''] || '';
                if(userId && refType !== '') {
                    win.FPS.setExternalRef(refType, userId, {
                        success: function() {
                            _fpsState.externalRefType = refType;
                            _fpsState.externalRefId = userId;
                            resolveState();
                        },
                        error: function() {
                            util.log('user.lib: failed to set FPS external reference');
                            resolveState();
                        }
                    });
                } else {
                    resolveState();
                }
            });
        };
        if(_fpsState) {
            resolveState();
        } else {
            _fpsState = {
                loaded: false
            };
            if(win.FPS) {
                initState();
            } else {
                util.url.loadAsScript(fpsBaseUrl + '/script/' + ctx.make + ((ctx.region === 'CA') ? '/CAN' : '/USA')).done(function () {
                    if (!win.FPS) {
                        resolveState();
                        return;
                    }
                    initState();
                }).fail(function (resp) {
                    util.log('user.lib: failed to load FPS library', resp);
                    resolveState();
                });
            }
        }
    }

    function getFps(params) {
        var def = $.Deferred();
	    _initFps().done(function(state) {
            if(state.loaded) {
                win.FPS.get(params, {
                    success: function(values) {
                        def.resolve(values);
                    },
                    error: function(jqXHR, statusText, error) {
                        util.log('user.lib: failed to load get FPS values', error, params);
                        def.reject();
                    }
                });
            } else {
                util.log('user.lib: getFps failed, FPS library not loaded');
            }
        });
        return def.promise();
    }

    function setFps(params) {
        var def = $.Deferred();
	    _initFps().done(function(state) {
            if(state.loaded) {
                win.FPS.set(params, {
                    success: function(values) {
                        def.resolve();
                    },
                    error: function(jqXHR, statusText, error) {
                        util.log('user.lib: failed to load set FPS values', error, params);
                        def.reject();
                    }
                });
            } else {
                util.log('user.lib: setFps failed, FPS library not loaded');
            }
        });
        return def.promise();
    }

    function getAllFpsNotifications() {
        var def = $.Deferred();
        _initFps().done(function(state) {
            if (state.loaded) {
                win.FPS.Notifications.getAll({
                    success: function(resp) {
                        if (resp && resp.SavedVehicleCount) {
                            util.log('user.lib: getAllFpsNotifications, FPS call succeeded: ', resp);
                            def.resolve(resp);
                        } else {
                            util.log('user.lib: getAllFpsNotifications, FPS call succeeded, but savedVehicleCount was missing. resp is: ', resp);
                            def.reject();
                        }
                    },
                    error: function(resp) {
                        util.log('user.lib: getAllFpsNotifications, FPS call failed. resp is: ', resp);
                        def.reject();
                    }
                });
            } else {
                util.log('user.lib: getAllFpsNotifications failed, FPS library not loaded');
                def.reject();
            }
        });
        return def.promise();
    }


    function stateValue(val) {
        return Object.assign({}, val);
    }

    function updateFPI(prop) {
        var ck = util.cookie.get('FPI');
        var p = (ck) ? util.parameters.decode(ck) : { };
        var domain = ctx.settings['siteCookieDomain' + ctx.make];
        p = Object.assign(p, prop);

        if(p.geoPACode === '') {
            delete p.geoPACode;
        }

        util.cookie.set('FPI', util.parameters.encode(p), {
            path: '/',
            domain: ((domain || '') == '') ? null : domain,
            expires: 65
        });
    }

    function useAltAuthRedirect() {
        return (ctx && ctx.pageType === 'HomePage' && ctx.make === 'Ford' && ctx.region === 'CA');
    }

})(window, jQuery, FD.Brand, FD.Brand.Util, FD.Brand.Context);
/*global FD*/
;(function(win, $, brand, util) {

    // reservation & order library
    Object.assign(brand.namespace('FD.Brand.RnO', win), {
        hasFpsId: getHasFpsId,
		getOrderStatus: getOrderStatus
    });
	
	var rnoCacheKey = 'fgxBrandsitesReserveAndOrder',
		rnoCache = (window.localStorage.getItem(rnoCacheKey) !== null) ? JSON.parse(window.localStorage.getItem(rnoCacheKey)) : {},
		fpsId = util.cookie.get('gt_uid'),
		hasFpsId = !!(fpsId && fpsId !== null && typeof fpsId !== 'undefined'),
		hasCache = (hasFpsId && rnoCache.hasOwnProperty(fpsId)),
		cachedData = (hasCache) ? rnoCache[fpsId] : null,
		cacheDate = (cachedData !== null && cachedData.hasOwnProperty('cacheDate')) ? cachedData.cacheDate : 'August 19, 1975 23:15:30';
	
	//console.log("***** RnO Lib Initial Values; fpsId : " + fpsId + " hasFpsId : " + hasFpsId + " hasCache : " + hasCache);
	
	function getOrderStatus() {
		return $.Deferred(function (defer) {
			if (hasFpsId) {
                if (hasCache && cacheIsFresh(cacheDate)) {
                    if (cachedData.success && cachedData.success === true) {
                        //console.log("***** RnO Lib - Resolve Promise with Cached Data");
                        //console.log(cachedData);
                        defer.resolve(cachedData);
                    } else {
                        //console.log("***** RnO Lib - Reject Promise with Cached Data");
                        //console.log(cachedData);
                        defer.reject(cachedData);
                    }
                } else {
                    $.getJSON('/aemservices/common/api.json/order/status', {
                        fpsId: fpsId
                    }).then(function(data) {
                        persistCache(true, data);
                        //console.log("***** RnO Lib - Resolve Promise with FRESH Data");
                        //console.log(data);
                        defer.resolve(data);
                    }, function(res) {
                        persistCache(false, {});
                        //console.log("***** RnO Lib - Reject Promise with failed response");
                        //console.log(res);
                        defer.reject(res);
                    });
                }
            } else {
                defer.reject({success: false});
            }
		}).promise();
	}
	
	function getHasFpsId() {
		return hasFpsId;
	}
	
	function persistCache(success, data) {
		data.success = success;
		data.cacheDate = cacheDate = new Date().toString();
		hasCache = true;
		rnoCache[fpsId] = cachedData = data;
		window.localStorage.setItem(rnoCacheKey, JSON.stringify(rnoCache));
	}
	
	function cacheIsFresh(storedDate) {
		var cacheDate = new Date(storedDate),
			now = new Date(),
			msBetweenDates = Math.abs(cacheDate.getTime() - now.getTime()),
			hoursBetweenDates = msBetweenDates / (60 * 60 * 1000);

		//console.log(hoursBetweenDates);

		if (hoursBetweenDates < 24) {
			return true;
		} else {
			return false;
		}
	}
	
})(window, jQuery, FD.Brand, FD.Brand.Util);
/*global FD*/
(function(win, $, brand, settings) {

    // DIG asset support library
    Object.assign(brand.namespace('FD.Brand.Dig'), {
        url: digUrl,
        resolve: digResolve
    });

    //////

    /**
     * Return global angle for given model name
     * @param m
     * @returns {*|number}
     */
    function globalAngle(m) {
        return {
                'StrippedChassis': 1,
                'F-650-750': 1,
                'Econoline Cutaway': 1
            }[m] || 4;
    }

    function tokenOffset(token) {
        var p = token.indexOf('Image[|');
        if(p === 0) return 7;
        p = token.indexOf('Config[|');
        if(p === 0) return 8;
        return null;
    }

    /**
     * Return DIG asset url
     * @param token
     * @param profile
     * @param view
     * @param angle
     * @returns {*}
     */
    function digUrl(token, profile, view, angle) {
        if(token) {
            var offset = tokenOffset(token), t;
            if(offset) {
                t = token.substr(offset).split('|');
                if(t.length > 3) {
                    return [
                        settings.digUrl,
                        encodeURIComponent(t[0]),
                        encodeURIComponent(t[1]),
                        encodeURIComponent(t[2]),
                        encodeURIComponent(profile || 'BP3TT-TILE-EXT'),
                        encodeURIComponent(token),
                        view || 'EXT',
                        angle || globalAngle(t[1]),
                        'vehicle.png'
                    ].join('/');
                }
            }
        }
        return null;
    }

    /**
     * Resolve DIG asset urls for child elements with 'data-dig-src' or 'data-dig-srcset' attributes
     * Attribute value is split by comma into parameters passed to digURL method
     * @param el
     */
    function digResolve(el) {
        var isLazy = function($el) {
            return (!$el.hasClass('fgx-not-lazy') && ($el.hasClass('lazyload') || $el.siblings('img').hasClass('lazyload')));
        };
        $('[data-dig-src]', el).each(function() {
            var $el = $(this);
            $el.attr(isLazy($el) ? 'data-src' : 'src', digUrl.apply(null, $el.attr('data-dig-src').split(','))).removeAttr('data-dig-src');
        });
        $('[data-dig-srcset]', el).each(function() {
            var $el = $(this);
            $el.attr(isLazy($el) ? 'data-srcset' : 'srcset', digUrl.apply(null, $el.attr('data-dig-srcset').split(','))).removeAttr('data-dig-srcset');
        });
    }

})(window, jQuery, FD.Brand, FD.Brand.Context.settings);

/*global FD*/
(function(win, $, brand, context, util) {

    // disclosures library
    Object.assign(brand.namespace('FD.Brand.Disclosures', win), {
        updateDisclosures: updateDisclosures,
        updateDisclosuresAll: updateDisclosuresAll,
        popupDisclosureLinkClick: popupDisclosureLinkClick,
        showPriceTip: showPriceTip,
        setInitListener: setInitListener,
        global: {
            getData: getGlobalDisclosureData
        },
        dynamic: {
            getData: getDynamicDisclosureData
        }
    });

    var _disclosures = {};
    var closeLabelPrefix = (context.accessibility && context.accessibility.closeLabelPrefix) || '';
    var $tooltip = $('<div class="fgx-brand-css" role="dialog" aria-labelledby="fgx-brand-tooltipHeading" aria-describedby="fgx-brand-tooltipContent" style="display: none;"><div class="fgx-tooltip" data-dynamic-disclosure-enable>' +
        '<div class="icon icon-close fgx-tooltip-close" tabindex="0" role="button" data-fgx-keypress="true" aria-label="' + closeLabelPrefix + '"></div>' +
        //'<div class="fgx-tooltip-hdr"></div>' +
        '<h2 id="fgx-brand-tooltipHeading" class="fgx-tooltip-heading fgx-tooltip-id"></h2>' +
        '<div id="fgx-brand-tooltipContent" class="fgx-tooltip-contents"></div>' +
        '<div class="fgx-dynamic-disclosure-wrapper"></div>' +
        '</div></div>');
    var $pricetip = $('<div class="fgx-brand-css" role="dialog" aria-labelledby="fgx-brand-pricetipHeading" aria-describedby="fgx-brand-pricetipContent" style="display: none;"><div class="fgx-tooltip price-tip">' +
        '<div class="icon icon-close fgx-tooltip-close" tabindex="0" role="button" data-fgx-keypress="true" aria-label="' + closeLabelPrefix + '"></div>' +
        '<div class="fgx-tooltip-hdr"></div>' +
        '<h2 id="fgx-brand-pricetipHeading" class="fgx-tooltip-heading fgx-brand-sr-text"></h2>' +
        '<div id="fgx-brand-pricetipContent" class="fgx-tooltip-contents"></div>' +
        '</div></div>');
    var $discHeading = $tooltip.find('.fgx-tooltip-heading');
    var $discContents = $tooltip.find('.fgx-tooltip-contents');
    var $dynamicDisc = $tooltip.find('.fgx-dynamic-disclosure-wrapper');
    var $closeBtn = $tooltip.find('.fgx-tooltip-close');
    var $priceTipId = $pricetip.find('.fgx-tooltip-hdr');
    var $priceTipHeading = $pricetip.find('.fgx-tooltip-heading');
    var $priceTipContents = $pricetip.find('.fgx-tooltip-contents');
    var $priceTipCloseBtn = $pricetip.find('.fgx-tooltip-close');
    var $body = $('body');
    var removeTooltipPos = false;
    var removePricetipPos = false;
    var discHeadingPrefix = '';
    var discLabelPrefix = '';
    var dynamicDiscLabelPrefix = '';
    var focusElements = 'a:visible, [data-fgx-keypress]:visible';
    var ovr = {
        $el: $tooltip,
        hide: function() {
            $('.fgx-tooltip-close', $tooltip).trigger('click');
        },
        lastFocus: undefined
    };
    var priceTipOvr = {
        $el: $pricetip,
        hide: function() {
            $('.fgx-tooltip-close', $pricetip).trigger('click');
        },
        lastFocus: undefined
    };
    var _initialized = false;
    var _initRegistry = [];
    var _isBCS = false;

    $(function() {
        init();
    });

    ///////

    function init() {
        // Check if we're on a page that uses the Brand Core Styles (BCS). The BCS styles currently aren't syndicated at all,
        // so force this to false when syndicated.
        _isBCS = !!($body && $body.hasClass('brand-core') && context && context.settings && !context.settings.syn);

        context.allEnabledDisclosures.forEach(function(d) {
            var setId = d.name.replace(/\s+/g, '').toLowerCase();
            _disclosures[setId] = [];
            d.disclosures.forEach(function(disc) {
                _disclosures[setId][disc.key] = disc;
            });
        });

        discHeadingPrefix = (context.accessibility && context.accessibility.disclosureHeadingPrefix) || '';
        discLabelPrefix = (context.accessibility && context.accessibility.disclosureLabelPrefix) || '';
        dynamicDiscLabelPrefix = (context.accessibility && context.accessibility.dynamicDisclosureLabelPrefix) || '';

        // add accessibility attributes to our disclosure <sup> items...this will add them to the tab order,
        // classify them as 'button' items and enable our key-listener logic
        $('sup[data-vdm-disc]').each(function(){
            $el = $(this);
            $el.attr('tabindex', '0');
            $el.attr('role', 'button');
            $el.attr('data-fgx-keypress', 'true');
            $el.attr('aria-label', discLabelPrefix + ' ' + $el.text());
        });
        $('a[href^=\'#disc\']').each(function() {
			$el = $(this);
            $el.attr('tabindex', '0');
            $el.attr('role', 'button');
            $el.attr('data-fgx-keypress', 'true');
            var txt = $el.text().trim();
            $el.attr('aria-label', dynamicDiscLabelPrefix + ' ' + txt);
        });
		$('a[data-disc-inline]').each(function() {
            $el = $(this);
			$el.attr('tabindex', '0');
            $el.attr('role', 'button');
            $el.attr('data-fgx-keypress', 'true');
		});

        $body
            .append($tooltip)
            .append($pricetip)
            .on('click', 'sup[data-vdm-disc]', function(ev) {
                ev.preventDefault();
                var $el = $(ev.currentTarget);
                if ($el.closest('.fordMainNavigation').length > 0) {
                    ev.stopPropagation();
                }
                var id = $el.attr('data-vdm-disc');
                var $target = $($el.attr('data-vdm-disc-target')) // SPC-2046 optional target el for scrollfix
                hideTooltip(ev, function() {
                    var ar = (id || '').split('|');
                    var disc = (ar.length > 1) && _disclosures[ar[0].replace(/\s+/g, '').toLowerCase()][ar[1]];
                    if(disc) {
                        if ($target.length) {
                            $tooltipClose = $tooltip.find('.fgx-tooltip-close')
                            $target.add($tooltipClose)
                                .one("click", hideTooltip)
                            $target.append(
                                $tooltip
                                    .off()
                                    .on("click", function(event) {
                                        event.stopPropagation();
                                    })
                            )
                        }
                        var discId = disc.id || '';
                        var discHeading = (discHeadingPrefix) ? (discHeadingPrefix + ' ' + discId) : discId;
                        showTooltip(discHeading, disc.detail, $el);
                    } else {
                        util.log('disclosures.lib: showTooltip invalid id : ' + id);
                    }
                });
                // postfdanalytics.tooltipOnClick();
            })
            .on('click', '.fgx-popup-tooltip', popupDisclosureLinkClick)
            .on('click', 'a[href^=\'#disc\']', dynamicDisclosureLinkClick)
            .on('click', 'button[href^=\'#disc\']', dynamicDisclosureLinkClick)
            .on('click', 'a[href^=\'#show-tooltip\']', flexTooltipLinkClick)
            .on('click', 'a[href^=\'#price-tip\']', priceTipLinkClick)
            .on('click', 'a[data-disc-inline]', inlineDisclosureLinkClick);

        //$tooltip.on('click', 'fgx-tooltip-close', hideTooltip);
        $priceTipCloseBtn.on('click', hidePriceTip);

        _initialized = true;
        triggerInitListeners();
    }

    function hideTooltip(ev, onComplete) {
        $body.off('click', hideTooltip);
        if($tooltip.is(':visible')) {
            $tooltip.fadeOut(100, function() {
                $tooltip.off('click').appendTo("body")
                FD.Brand.Overlay.releaseFocus(ovr);
                if (typeof onComplete != 'undefined') {
                    onComplete();
                }
            });
            if(removeTooltipPos) {
                $tooltip.find('.fgx-tooltip').css({position: ""});
                removeTooltipPos = false;
            }
            $body.removeClass('no-scroll-sm');
        } else if(onComplete){
            onComplete();
        }
    }

    function hidePriceTip(ev, onComplete) {
        if($pricetip.is(':visible')) {
            $pricetip.fadeOut(100, function() {
                FD.Brand.Overlay.releaseFocus(priceTipOvr);
                if (typeof onComplete != 'undefined') {
                    onComplete();
                }
            });
            if(removePricetipPos) {
                $pricetip.find('.fgx-tooltip').css({position: ""});
                removePricetipPos = false;
            }
            $body.removeClass('no-scroll-sm');
        } else if(onComplete){
            onComplete();
        }
        updateExpandedAttr(priceTipOvr.lastFocus, "false");
    }

    function showTooltip(title, detail, $el, className, role) {
        // determine whether our trigger element is nested inside another tooltip...but ensure the parent tooltip is NOT our price-tip
        var isNested = ($el.parent().closest('.fgx-tooltip-contents').length > 0 && $el.parent().closest('.price-tip').length <= 0);
        var bp = util.currentBreakpoint();
        var topOffset = 100;
        if (role === '' || typeof role === 'undefined') role = 'dialog';
        // update contents
        $discHeading.text(title || '');
        $discContents.html(detail || '\xa0');
        updateDisclosures($tooltip);

        var dynamicDiscElm = $el.closest('[data-dynamic-disclosure-enable]').find('.dynamic-disclosures');
        if(dynamicDiscElm.length) {
            $dynamicDisc.html(dynamicDiscElm.html());
        } else {
            $dynamicDisc.html('');
        }

        //$tooltip.removeClass().addClass('fgx-tooltip ' + (className || ''));
        $tooltip.removeClass().addClass('fgx-brand-css ' + (className || ''));
        removeTooltipPos = false;

        // assign role...if role was not passed in, this will always be 'dialog'
        $tooltip.attr('role', role);

        if(!isNested) {
            // only update our lastFocus target if we're *not* nested - we don't want to lose our place in the page.
            ovr.lastFocus = $el;
            var elPos = $el.offset();
            var elW = $el.outerWidth();
            // arrowOffset is used in some of the calculations below as a slight adjustment to help center the arrow correctly
            var arrowOffset = 7;
            // extSpacer represents space between the edge of the tooltip and the trigger element. This should account for the arrow + 8px.
            var extSpacer = (_isBCS) ? ((2 * arrowOffset) + 8) : 0;
            var top = elPos.top + $el.outerHeight() + extSpacer;
            var winScrollTop = $(window).scrollTop()
            var winHeight = $(window).height() + winScrollTop;

            // Adjustments for optional $el target, i.e. containing modal.
            // WARNING: this workaround disrupts var naming semantics to minimize logic changes
            //   winScrollTop -> window scrollTop OR target-adjusted scrollTop
            //   winHeight -> window height OR target-adjusted height
            var $elTarget = $($el.attr('data-vdm-disc-target'));
            if ($elTarget.length) {
                var targetTop = $elTarget.offset().top;
                elPos.top -= targetTop;
                top -= targetTop;
                winScrollTop = $elTarget.scrollTop();
                winHeight = $elTarget.height() + winScrollTop;
                elPos.left -= $elTarget.offset().left;
            }

            $tooltip.addClass('fgx-brand-size-calc');
            var $tooltipEl = $tooltip.find('.fgx-tooltip');
            var tooltipH = $tooltipEl.outerHeight();
            var tooltipW = $tooltipEl.outerWidth();
            var adjustTop = ((top + tooltipH) > winHeight);
            var left = elPos.left + elW - tooltipW;

            if (_isBCS) {
                // If on a page that uses the Brand Core Styles (BCS) then get the correct breakpoint for BCS before
                // handling the calculations to set the position of the tooltip.
                bp = util.currentBreakpointBCS();

                if (bp === 'gux-bkpt-sm') {
                    // The tooltip displays as a fullscreen takeover with fixed positioning on mobile, so no calculations needed.
                    top = 0;
                    left = 0;
                } else {
                    var arrowCls = 'bcs-arrow--top';
                    var arrowPos;
                    // Increase left position slightly in default display to help the arrow actually point to the trigger element.
                    left += arrowOffset;
                    if (adjustTop) {
                        top = elPos.top - tooltipH - extSpacer;
                        arrowCls = 'bcs-arrow--bottom';
                    }
                    if (top < 0 || top < winScrollTop) {
                        top = (top < 0) ? 25 : winScrollTop;
                        var ttBtm = top + tooltipH;
                        if (ttBtm > elPos.top) {
                            // Tooltip can't fit completely above element so push it over to the left more, then display
                            // the arrow on the right side of the tooltip.
                            left = elPos.left - tooltipW - extSpacer;
                            arrowCls = 'bcs-arrow--right';
                            arrowPos = 100 - (((ttBtm - elPos.top - 4) / tooltipH) * 100);
                        }
                    }
                    if (left < 0) {
                        if (arrowCls === 'bcs-arrow--right') {
                            // If the left value is currently off screen and the tooltip is overlapping with the trigger element
                            // vertically (i.e. it doesn't fit completely above or below), then try to move it to the right side.
                            var elmL = elPos.left + extSpacer,
                                elmR = elmL + elW,
                                tooltipR = elmR + tooltipW,
                                winWidth = $(win).width();
                            if (tooltipR < winWidth) {
                                // Position the tooltip on the right side of the trigger element.
                                left = elmR;
                            } else {
                                // Use the left side of the trigger element to position the tooltip towards the right.
                                left = ((elmL + tooltipW) < winWidth) ? elmL : elPos.left;
                            }
                            // Set the arrowCls to display on the left side of the tooltip. The arrowPos doesn't need
                            // to be updated here because the position that was calculated when we set the arrowCls to
                            // bcs-arrow--right (above) should still work here.
                            arrowCls = 'bcs-arrow--left';
                        } else {
                            var adjustedLeft = elPos.left - arrowOffset;
                            left = (adjustedLeft > 0) ? adjustedLeft : elPos.left;
                            arrowPos = ((elW / 2) / tooltipW) * 100;
                        }
                    }

                    // If we haven't already set an offset for the arrow then calculate the offset with the assumption that
                    // the tooltip is displaying in its natural state (above or below the element and off towards the left)
                    if (typeof(arrowPos) == 'undefined') {
                        arrowPos = 100 - (((elW / 2) / tooltipW) * 100);
                    }

                    $tooltipEl
                        .toggleClass('bcs-arrow--top bcs-arrow--right bcs-arrow--bottom bcs-arrow--left', false)
                        .addClass(arrowCls);
                    $tooltipEl[0].style.setProperty('--bcs-tt__arrow-cross-pos', arrowPos + '%');
                }

            } else {
                if(bp === 'gux-bkpt-sm') {
                    if(adjustTop) {
                        var diff = (top + $tooltipEl.outerHeight()) - winHeight;
                        top = elPos.top - diff;
                        //top = elPos.top - $tooltipEl.outerHeight() + topOffset;
                    }
                    if(top < 0) {
                        top = 25;
                        $(".fgx-tooltip").css({
                            position: "fixed"
                        });
                        removeTooltipPos = true;
                    } else if(top < winScrollTop) {
                        top = winScrollTop;
                    }
                    if(left < 0) {
                        left = 20;
                    }
                } else {
                    if(adjustTop) {
                        top = elPos.top - $tooltipEl.outerHeight() + topOffset;
                    }
                    if(left < 0) {
                        left = elPos.left;
                    }
                    if(top < 0) {
                        top = 25;
                    } else if(top < winScrollTop) {
                        top = winScrollTop;
                    }
                }
            }

            $tooltip.find('.fgx-tooltip').css({
                top: top,
                left: left
            });

            $tooltip.removeClass('fgx-brand-size-calc');

        }
        $tooltip.fadeIn(250, function() {
            FD.Brand.Overlay.trapFocus(ovr, focusElements, '.fgx-tooltip-close', ovr.lastFocus)
        });
        $body.one('click', hideTooltip);
    }

    function showPriceTip(title, content, $el, isBrandDSStyle) {
        var bp = util.currentBreakpoint();
        var topOffset = 100;
        // update contents
        $priceTipId.text(title);
        $priceTipHeading.text(title);
        $priceTipContents.html(content || '\xa0');
        updateDisclosures($pricetip);
        // NZ - set the expanded attr to false on the old 'lastFocus' element before replacing with the current one.
        // This is needed to update the expanded attr in instances where the priceTip is updated with new content without
        // the overlay closing in between.
        updateExpandedAttr(priceTipOvr.lastFocus, "false");
        // set last focus and price-tip positioning
        removePricetipPos = false;
        priceTipOvr.lastFocus = $el;
        var elPos = $el.offset();
        var top = elPos.top + $el.outerHeight();
        var winHeight = $(window).height() + $(window).scrollTop();
        $pricetip.addClass('fgx-brand-size-calc');
        var $pricetipEl = $pricetip.find('.fgx-tooltip');
        $pricetipEl.toggleClass('no-heading', !title);
        var adjustTop = ((top + $pricetipEl.outerHeight()) > winHeight);
        var left = elPos.left + $el.outerWidth() - $pricetipEl.outerWidth();

        if (isBrandDSStyle) {
            $pricetip.addClass('brand-ds-style');
            $priceTipHeading.addClass('fgx-brand-ds body-one ff-b');
            $priceTipId.addClass('fgx-brand-ds body-one ff-b');
        } else {
            $pricetip.removeClass('brand-ds-style');
            $priceTipHeading.removeClass('fgx-brand-ds body-two ff-b');
            $priceTipId.removeClass('fgx-brand-ds body-one ff-b');
        }

        if(bp === 'gux-bkpt-sm') {
            if(adjustTop) {
                var diff = (top + $pricetipEl.outerHeight()) - winHeight;
                top = elPos.top - diff;
                //top = elPos.top - $tooltipEl.outerHeight() + topOffset;
            }
            if(top < 0) {
                top = 25;
                $(".fgx-tooltip.price-tip").css({
                    position: "fixed"
                });
                removePricetipPos = true;
            } else if(top < $(window).scrollTop()) {
                top = $(window).scrollTop();
            }
            if(left < 0) {
                left = 20;
            }
        } else {
            if(adjustTop) {
                top = elPos.top - $pricetipEl.outerHeight() + topOffset;
            }
            if(left < 0) {
                left = elPos.left;
            }
            if(top < 0) {
                top = 25;
            } else if(top < $(window).scrollTop()) {
                top = $(window).scrollTop();
            }
        }

        $pricetip.find('.fgx-tooltip').css({
            top: top,
            left: left
        });

        $pricetip.removeClass('fgx-brand-size-calc');

        updateExpandedAttr($el, "true");

        $pricetip.fadeIn(250, function() {
            FD.Brand.Overlay.trapFocus(priceTipOvr, focusElements, '.fgx-tooltip-close', priceTipOvr.lastFocus)
        });
    }

    function popupDisclosureLinkClick(ev) {
        ev.preventDefault();
        var $el = $(ev.currentTarget);
        var $target = $($el.attr('data-vdm-disc-target'));
        hideTooltip(ev, function() {
            if ($target && $target.length) {
                $tooltip
                    .find('.fgx-tooltip-close')
                    .off('click', hideTooltip)
                    .one('click', hideTooltip);
                $target.append($tooltip);
            }
            showTooltip('', $el.find('.fgx-popup-tooltip-content').html(), $el, 'fgx-disclosure-popup');
        });
    }

    function dynamicDisclosureLinkClick(ev) {
        ev.preventDefault();
        var $el = $(this);
        var href = $(this).attr('href');
        if (href.indexOf('=') > -1) {
            var id = href.split('=')[1];
            var $component = $el.closest('[data-dynamic-disclosure-enable]');
            var $discEl = $component.find('[data-disclosure-id="'+ id +'"]');
            var content = $discEl.data('disclosure-content');
            var title = $discEl.data('disclosure-title');
            var cls = $discEl.data('disclosure-class');
            var cssClass = (title === '' || title === undefined) ? 'fgx-disclosure-popup' : '';
            if (cls !== '' && typeof cls !== 'undefined') {
                cssClass += (' ' + cls);
            }
            if (content !== '' && content !== undefined) {
                hideTooltip(null, function() {
                    showTooltip(title, content, $el, cssClass);
                });
            } else {
                util.log('disclosures.lib: dynamicDisclosureLinkClick link exists, but disclosure contains no content.');
            }
        } else {
            util.log('disclosures.lib: dynamicDisclosureLinkClick link is malformed...it should be formatted like: #disc=id');
        }
    }

    function inlineDisclosureLinkClick(ev) {
        var $el = $(this);
        var content = $el.attr('data-disc-inline');
        var title = $el.attr('data-disc-title');
        if(content) {
            hideTooltip(null, function() {
                showTooltip(title, content, $el, 'fgx-disclosure-popup');
            });
        }
    }

    function flexTooltipLinkClick(ev) {
        ev.preventDefault();
        var $el = $(this);
        var role = $(this).data('tooltip-role');
        var content = $(this).data('tooltip-content');
        if (content !== '' && content !== undefined) {
            hideTooltip(null, function() {
                showTooltip('', content, $el, 'fgx-disclosure-popup', role);
            });
        }
    }

    function priceTipLinkClick(ev) {
        ev.preventDefault();
        var $el = $(this);
        var href = $(this).attr('href');
        if (href.indexOf('=') > -1) {
            var id = href.split('=')[1];
            var $component = $el.closest('[data-price-tip-enable]');
            var isBrandDSStyle = $component.hasClass('brand-ds-style');
            var $discEl = $component.find('[data-price-tip-id="'+ id +'"]');
            var content = $discEl.data('price-tip-content');
            var title = $discEl.data('price-tip-title');
            var cssClass = (title === '' || title === undefined) ? 'fgx-disclosure-popup' : '';
            if (content !== '' && content !== undefined) {
                showPriceTip(title, content, $el, isBrandDSStyle);
            } else {
                util.log('disclosures.lib: priceTipLinkClick link exists, but price tip contains no content.');
            }
        } else {
            util.log('disclosures.lib: priceTipLinkClick link is malformed...it should be formatted like: #price-tip=id');
        }
    }

    /**
     * Helper method to allow accessibility attributes to be added to components via an explicit call
     * rather than relying on the logic that runs when the page is loaded.
     **/
    function updateDisclosures(components) {
        // add accessibility attributes to our disclosure <sup> items...this will add them to the tab order,
        // classify them as 'button' items and enable our key-listener logic
        $('sup[data-vdm-disc]', components).each(function(){
            $el = $(this);
            $el.attr('tabindex', '0');
            $el.attr('role', 'button');
            $el.attr('data-fgx-keypress', 'true');
            $el.attr('aria-label', discLabelPrefix + ' ' + $el.text());
        });
    }

    /**
     * Helper method to allow accessibility attributes to be added to global and inline disclosures via an explicit call
     * rather than relying on the logic that runs when the page is loaded.
     **/
    function updateDisclosuresAll(components) {
        updateDisclosures(components);
        $('a[data-disc-inline]').each(function() {
            $el = $(this);
            $el.attr({
                'tabindex': '0',
                'role': 'button',
                'data-fgx-keypress': 'true'
            });
        });
    }

    function getGlobalDisclosureData(id) {
        var ar = (id || '').split('|');
        var discKey = (ar.length > 1) && ar[0].replace(/\s+/g, '').toLowerCase();
        var disc = discKey && _disclosures[discKey] && _disclosures[discKey][ar[1]];
        return disc || null;
    }

    function getDynamicDisclosureData($el) {
        var output = null;
        if(!$el || $el.length === 0) {
            return output;
        }

        var href = $el.attr('href');
        if (href.indexOf('=') > -1) {
            var id = href.split('=')[1];
            var $component = $el.closest('[data-dynamic-disclosure-enable]');
            var $discEl = $component.find('[data-disclosure-id="'+ id +'"]');
            var content = $discEl.data('disclosure-content');
            var title = $discEl.data('disclosure-title');
            var displayId = $el.text();

            output = {
                "id": displayId,
                "key": id,
                "title": title,
                "detail": content
            };
        }

        return output;
    }

    function updateExpandedAttr($el, val) {
        if($el && $el.length > 0 && $el.is('[aria-expanded]')) {
            $el.attr('aria-expanded', val);
        }
    }

    /*
     * Helper methods to allow a component to setup a callback method that should be fired when the disclosures lib
     * is initialized. If the lib is already initialized when trying to set the listener, then the callback should just
     * be fired instantly.
     */
    function setInitListener(compId, initHandler) {
        if (_initialized) {
            fireListenerCallback({id: compId, handler: initHandler});
        } else {
            _initRegistry.push({
                id: compId,
                handler: initHandler
            });
        }
    }

    function triggerInitListeners() {
        if (_initRegistry.length > 0) {
            _initRegistry.forEach(function(item) {
                fireListenerCallback(item);
            });
        }
    }

    function fireListenerCallback(item) {
        if (item && item.handler && typeof(item.handler) === 'function') {
            try {
                item.handler();
            } catch(e) {
                console.log('An error occurred trying to fire a callback of the disclosures lib init listener for ' + item.id, e);
            }
        }
    }

})(window, jQuery, FD.Brand, FD.Brand.Context, FD.Brand.Util);
/*global FD*/
/**
 * NGP Services support library
 */
(function(win, $, ctx, util) {
    var settings = ctx.settings;

    // setup namespace
    Object.assign(FD.Brand.namespace('FD.Brand.NgpServices', win), {
        location: function(postalCode) {
            return serviceCall('/geo/PostalCodes.json', {
                postalCode: postalCode
            }, function(resp) {
                return util.objPath(resp, 'Response.PostalCode');
            });
        },
        dealers: function(prm) {
            return serviceCall('/dealer/Dealers.json', prm, function(resp) {
                return util.toArray(util.objPath(resp, 'Response.Dealer'));
            });
        },
        dealer: function(prm) {
            return serviceCall('/dealer/Details.json', prm, function(resp) {
                return util.objPath(resp, 'Response.Dealer');
            });
        },
        motorcraftDealer: function(prm) {
            return serviceCall('/dealer/Lookup.json', prm, function(resp) {
                return util.toArray(util.objPath(resp, 'Response.Dealer'));
            });
        },
        dealerByUrlKey: function(prm) {
            return serviceCall('/dealer/DetailsByUrlKey.json', prm, function(resp) {
                return util.objPath(resp, 'Response.Dealer');
            });
        },
        serviceLocations: function(prm) {
            return serviceCall('/dealer/ServiceLocations.json', prm, function(resp) {
                return util.toArray(util.objPath(resp, 'Response.Dealer'));
            });
        },
        dealersAndServiceLocations: function(prm) {
            return serviceCall('/dealer/DealersAndServiceLocations.json', prm, function(resp) {
                return util.toArray(util.objPath(resp, 'Response.Dealer'));
            });
        },
        dealerChatStatus: function(prm) {
            return serviceCall('/dealer/ChatStatus.json', prm, function(resp) {
                return util.objPath(resp, 'Response.DealerChatStatus');
            });
        },
        dealerReviews: function(prm) {
            return serviceCall('/dealer/Reviews.json', prm, function(resp) {
                return util.objPath(resp, 'Response.ReviewResponse');
            });
        },
        dealerSpecialties: function(prm) {
            return serviceCall('/dealer/Specialties.json', prm || {}, function(resp) {
                return util.objPath(resp, 'Response.Specialties');
            });
        },
        modelSlices: function(prm) {
            return serviceCall('/products/ModelSlices.json', prm, function(resp) {
                return util.objPath(resp, 'Response.Model');
            });
        },
        trimLevels: function(prm) {
            return serviceCall('/products/ModelSlices.json', prm, function(resp) {
                return util.objPath(resp, 'Response.Model');
            });
        },
        configDetail: function(prm) {
            return serviceCall('/config/Details.json', prm, function(resp) {
                return util.objPath(resp, 'Response');
            });
        },
        searchTypeAhead: function(prm) {
            return serviceCall('/searchservices/f/', prm, function(resp) {
                return util.searchGoogleObjPath(resp);
            }, true, true);
        },
        specialOffers: function(prm) {
            return serviceCall('/incentives/SpecialOffers.json', prm, function(resp) {
                return util.objPath(resp, 'Response.Nameplate');
            });
        },
        attributesProxy: function(method, prm, attr) {
            var param = {
                client: 'common',
                region: ctx.region,
                url: method + '?' + util.parameters.encode(prm),
                filter: attr
            };
            var host = (settings['shopUrl' + ctx.make + ctx.languageKey] ||
                settings['shopUrl' + ctx.make]);

            if ( param.url.includes("@") || param.url.includes("%40") ) {
                param.url += "/%";
                return $.getJSON(host + '/aemservices/common/api/attributes/proxy', param);
            } else {
                return $.getJSON(host + '/aemservices/common/api/attributes/proxy', param);
            }
        },
        attributeMap: attributeMap
    });

    function serviceCall(method, prm, fn, skipCheck, fullPath) {
        return $.Deferred(function (defer) {
            var path = (fullPath) ? method : settings.ngpServiceUrl + method;
            return $.ajax({
                headers: {
                    'Application-id': settings.clientId
                },
                dataType: 'json',
                url: path,
                data: prm
            }).done(function(resp) {
                if(skipCheck || checkResponse(resp)) {
                    defer.resolve(fn ? fn(resp) : resp);
                } else {
                    defer.reject();
                }
            }).fail(function(resp) {
                util.log(method + ' failed', resp);
                defer.reject(resp);
            });
        }).promise();
    }

    function fixServiceJSON(obj) {
        if($.isPlainObject(obj) || $.isArray(obj)) {
            $.each(obj, function(k, v) {
                var v = util.fixServiceJSON(v);
                obj[k] = v;
            });
            return obj;
        } else {
            if(/^[-+]?[0-9]*\.?[0-9]+$/.test(obj)) {
                return +obj;
            }
            if(/^\d\d\d\d\-\d\d\-\d\d$/.test(obj)) {
                var dt = obj.split('-');
                return new Date(dt[0], dt[1] - 1, dt[2]);
            }
            return obj;
        }
    }

    function checkResponse(resp) {
        if(resp) {
            if(resp.Response) {
                if(resp.Response.status === 'OK') {
                    return true;
                } else {
                    util.log('Service call failed [' + resp.Response.status + '] ' + resp.Response.Message);
                }
            } else {
                util.log('Service call failed - Response root missing');
            }
        } else {
            util.log('Service call failed - No response');
        }
        return false;
    }

    function attributeMap(attributeArray) {
        var map = {};
        util.toArray(attributeArray || []).forEach(function(attr) {
            if(attr.name && attr.Value) {
                map[attr.name] = attr.Value;
            }
        });
        return map;
    }

})(window, jQuery, FD.Brand.Context, FD.Brand.Util);

/*global FD*/
;(function(win, $, brand, util) {

    var _overlays = {};
    var activeOverlay = null;
    var $background;
    var backgroundDef = $.Deferred();
    var backgroundAvailable = backgroundDef.promise();
    var focusElements = 'a:visible, input:visible, select:visible, button:visible, [data-fgx-keypress]:visible';

    // setup namespace
    Object.assign(brand.namespace('FD.Brand.Overlay', win), {
        instance: _overlays,
        register: registerOverlay,
        show: showOverlay,
        trapFocus: trapFocus,
        releaseFocus: releaseFocus,
        hideActive: hideActiveOverlay
    });

    $(init);

    //////

    function init() {
        $background = $('<div style="display: none;" class="fgx-brand-css"><div class="fgx-overlay-background"></div></div>');
        $background.appendTo($('body'));
        backgroundDef.resolve();

        /*
        // The two methods below were attempts to get scrolling to be disabled on the body content on iOS devices.
        // at the moment, they are blocking *all* scrolling (even on the overlay divs) so we've removed them for now...but
        // this may be a good place to pick up on later if we want to re-open the attempts to prevent the body scrolling on iOS.
        $(document).on('touchmove', 'body.no-scroll-sm', function(ev) {
           ev.preventDefault();
        });
        document.ontouchmove = function ( event ) {
            // manually intercept touchmove event on touch devices and, if it's a phone prevent scrolling explicitly on elements 
            // (such as 'body') that have the 'no-scroll-sm' class applied to them...this is a fix for iOS.
            if (util.currentBreakpoint() === 'gux-bkpt-sm') {
                var isTouchMoveAllowed = true, target = event.target;

                while ( target !== null ) {
                    if ( target.classList && target.classList.contains( 'no-scroll-sm' ) ) {
                        isTouchMoveAllowed = false;
                        break;
                    }
                    target = target.parentNode;
                }

                if ( !isTouchMoveAllowed ) {
                    event.preventDefault();
                }
            }

        };
        */
    }

    function registerOverlay(id, element, api, focusElements) {
        var overlay = {
            id: id,
            $el: $(element),
            api: api,
            focusElements: focusElements,
            show: function(...args) { showOverlay(id, ...args); },
            hide: function(...args) { hideOverlay(id, ...args); }
        };
        if (!_overlays[id]) {
            _overlays[id] = overlay;
        } else {
            if(overlay.$el.length > 0) {
                _overlays[id].$el = overlay.$el;
            }
        }
        return overlay;
    }

    function showOverlay(id, focusTrapEnable, currentTarget, firstFocus) {
        var ovr = _overlays[id];
        if(ovr.api && ovr.api.show && ovr.api.show(ovr) === false) {
            return;
        }
        if(activeOverlay) {
            hideOverlay(activeOverlay);
        }
        var scroll = ovr.$el.attr('data-overlay-scroll-offset');
        if(scroll && util.currentBreakpoint() !== 'gux-bkpt-sm') {
            scroll = scroll.split(',');
            //NZ 3/22
            var topPos = 0;
            var scrollTop = $(win).scrollTop();
            if (scrollTop < (+scroll[0])) {
                topPos = (+scroll[0])-scrollTop;
            } else {
                topPos = (+scroll[1]) + scrollTop;
            }
            topPos = topPos + 'px';

            //NZ 3/22: ovr.$el.css({'top': Math.max(+scroll[0], $(win).scrollTop() + (+scroll[1])) + 'px'});
            ovr.$el.css({'top': topPos});
        } else if(util.currentBreakpoint() === 'gux-bkpt-sm') {
            ovr.$el.css({'top': 0});
        }
        backgroundAvailable.done(function() {
            $background.fadeIn(100, function() {
                $background.one('click', ovr.hide);
                ovr.$el.fadeIn(300, function(){
                    // if we have a focusTrapEnable flag, trap focus
                    if (typeof focusTrapEnable !== 'undefined' && focusTrapEnable === true) {
                        var elements = (typeof ovr.focusElements !== 'undefined') ? ovr.focusElements : focusElements;
                        trapFocus(ovr, elements, firstFocus, currentTarget);
                    }
					// check for an 'afterShow' callback method, if it exists, invoke it.
					if (ovr.api && ovr.api.afterShow) {
						ovr.api.afterShow();
					}
                });
            });
        });
        activeOverlay = id;
        $('body').addClass('no-scroll-sm fgx-brand-ovr-open');
    }

    function hideOverlay(id) {
        var ovr = _overlays[id];
        if(ovr.api && ovr.api.hide && ovr.api.hide(ovr) === false) {
            return;
        }
        activeOverlay = null;
        $background.off('click', ovr.hide);
        ovr.$el.fadeOut(300, function() {
            $background.fadeOut(100, function(){
				// check for an 'afterHide' callback method, if it exists, invoke it.
				if (ovr.api && ovr.api.afterHide) {
					ovr.api.afterHide();
				}
            });
            ovr.$el.css({'top': null});
        });
        releaseFocus(ovr);
        $('body').removeClass('no-scroll-sm fgx-brand-ovr-open');
    }

    /**
     * Hide the current active overlay if it exists.
     */
    function hideActiveOverlay() {
        if (activeOverlay && _overlays[activeOverlay]) {
            hideOverlay(activeOverlay);
        }
    }
    
    /**
     * Trap focus in a flip, for specified links, and return focus to element that opened flip upon close
     * @param ovr - the overlay we're trapping
     * @param flipLinks - ex: 'a, .dealer-modal-close' // links to tab through selector
     * @param flipFirst - ex: 'a' // type of link for first focus selector
     * @param lastFocus - ex: $(ev.currentTarget) // target modal opened from
     */
    function trapFocus(ovr, flipLinks, flipFirst, lastFocus, stopPropagation) {
        var $flipWrapper = $(ovr.$el), // we wrap this to ensure it is a jquery element, because the RIBS components sometimes use elements that have not been wrapped.
            linkSelectors = flipLinks,
            links = $flipWrapper.find(linkSelectors);
        
        if (typeof lastFocus != 'undefined') {
            ovr.lastFocus = $(lastFocus); // we wrap this to ensure it is a jquery element, because the RIBS components sometimes use elements that have not been wrapped.
        }
        
        if (flipFirst != null && typeof flipFirst != 'undefined') {
            // if we explicitly pass the selector of an element to focus, focus that element
            $flipWrapper.find(flipFirst).first().focus();
        } else {
            // if not, focus our first actionable item.
            if(links && links.length > 0) {
                links[0].focus();
            }
        }
        
        $flipWrapper.on('keydown', function (e) {
            let cancel = false;
            if (e.ctrlKey || e.metaKey || e.altKey) {
                return;
            }
            switch(e.which) {
                case 27: // ESC
                    if(ovr.api && ovr.api.cancel && ovr.api.cancel(ovr) === false) {
                        return;
                    }
                    ovr.hide();
                    lastFocus.focus();
                    cancel = true;

                    if (stopPropagation) {
                        e.stopPropagation();
                    }
                    break;
                case 9: // TAB
                    // refresh our links (contents change for type-ahead results, etc...)
                    links = $flipWrapper.find(linkSelectors);
                    if (e.shiftKey) {
                        if (e.target === links[0]) {
                            links[links.length - 1].focus();
                            cancel = true;
                        }
                    } else {
                        if (e.target === links[links.length - 1]) {
                            links[0].focus();
                            cancel = true;
                        }
                    }
                    break;
            }
            if (cancel) {
                e.preventDefault();
            }
        });
    }
    
    /**
     * Release focus from a flip.
     * @param ovr - the overlay we're releasing
     * 
     */
    function releaseFocus(ovr) {
        var $flipWrapper = $(ovr.$el); // we wrap this to ensure it is a jquery element, because the RIBS components sometimes use elements that have not been wrapped.
        $flipWrapper.off('keydown');

        // NZ - if the skipLastFocus property is set to true, then return after removing the keydown listener but before updating the focus.
        if (ovr && ovr.skipLastFocus) {
            return;
        }

        if (ovr.lastFocus && typeof ovr.lastFocus != 'undefined') {
            ovr.lastFocus.focus();
        } else {
            // if we don't have an explicitly defined element, focus on the main navigation brand logo if defined or the first link on the page otherwise.
            if($('.fordMainNavigation').length > 0) {
                $('.fordMainNavigation a.navbar-brand').focus();
            } else if($('.lincolnMainNavigation').length > 0) {
                $('.lincolnMainNavigation a.navbar-brand:visible').focus();
            } else {
                $('a').first().focus();
            }
        }
    }

})(window, jQuery, FD.Brand, FD.Brand.Util);


/*global FD*/
/**
 * Pricing support library
 *
 * Dynamically loads Single Payment Calculator if not available
 * Queries DOM elements looking for pricing data attributes and substituting pricing data
 *
 */
(function(win, $, brand, user, util, ngp, disclosures) {

    // setup namespace
    Object.assign(brand.namespace('FD.Brand.Pricing', win), {
        pricingData: getPricingData,
        label: getLabel,
        refresh: refresh,
        format: formatPrice,
        show: showFlip,
        postalLink: postalLink,
        formatPriceTipData: formatPriceTipData,
        price: getPrice,
        planId: getPlanId
    });

    var FALLBACK_POSTALCODE = { US: '48120', CA: 'L6J5E4' };
    var _ctx = FD.Brand.Context;
    var _make = _ctx.make;
    var _langKey = _ctx.languageKey;
    var _spcLock = false;
    var _baseCtx = {
        make: _make,
        model: _ctx.nameplate && _ctx.nameplate.ngpModelName,
        year: _ctx.nameplate && _ctx.nameplate.ngpYear
    };
    var _baseLabels = _ctx.priceLabel;
    var _refreshList = [];
    var _pricingDataCache = {};
    var _trimCache = {};
    var _initPromise = null;
    var _nameplatePricing = brand.Context.nameplatePricing;
    var _nameplatePricingResolved = null;
    var _userPricing = user.pricing.current();
    var _postalLinkPrefix = (_ctx.accessibility && _ctx.accessibility.postalCodeLabelPrefix) || '';
    var _mtxActions = null;

    user.location.subscribe(function() {
        //init().done(function() {
            util.log('context change, refreshing pricing');
            _pricingDataCache = {};
            _nameplatePricingResolved = null;
            _refreshList.forEach(function(element) {
                refresh(element, 1);
            });
            var pc = user.location.current().postalCode;
            var pcLabel = _postalLinkPrefix + ' ' + pc;
            $('[data-fgx-postal-link]').text(pc).attr('aria-label', pcLabel);
        //});
    }, true);

    // ------------------------------------------------------------------

    function init() {
        if(_initPromise !== null) {
            return _initPromise;
        }
        var def = $.Deferred();
        var initPricing = function() {
            if(win.fdcc) {
                win.fdcc.init(function() {
                    def.resolve();
                });
            } else {
                util.log('pricing - spc loader failed to initialize');
                def.reject();
            }
        };

        if(!_mtxActions) {
            _mtxActions = brand.Context && brand.Context.mtxActions;
        }

        if(!win.fdcc) {
            var path = '/aemservices/common/api/component/v2/loader.js/golf-spc?';
            if(_ctx.settings.env !== 'local') {
                path = (_ctx.settings['shopUrl' + _ctx.make + _ctx.languageKey] ||
                        _ctx.settings['shopUrl' + _ctx.make]) + util.url.prepend(path, '/cmslibs');
            }
            if(_ctx.region === 'CA' && _ctx.languageKey === 'FR') {
                path = path.replace('loader.js', 'loader.ext.js');
            }
            util.url.loadAsScript(path +
                $.param({
                    make: _make,
                    region: _ctx.region
                })).done(function() {
                    initPricing();
                }).fail(function(jqxhr, settings, error) {
                    util.log('pricing - failed to load spc loader ' + error);
                    def.reject();
                });
        } else {
            initPricing();
        }
        _initPromise = def.promise();
        return _initPromise;
    }

    function resolveConfig(inputCfg, flip) {
        var cfg = $.extend({
            zipcode: user.location.current().postalCode || FALLBACK_POSTALCODE[FD.Brand.Context.region],
            plantype: _userPricing.planType
        }, _baseCtx, Object.keys(inputCfg).reduce(function(obj, k) {
            if(!!inputCfg[k]) {
                obj[k] = inputCfg[k];
            }
            return obj;
        }, {}));
        if(!flip) {
            cfg.paymentFrequency = _ctx.paymentFrequency || 'monthly';
        }
        if(cfg.model) {
            cfg.options = (cfg.options || {});
            cfg.options.allowChangeVehicle = false;
        }
        return cfg;
    }

    function formatPrice(price) {
        if(typeof price == 'number') {
            // TEMP: format price for FoC fr.  Ideally the format should be defined in settings
            return (_ctx.language === 'fr')
                ? price.toFixed(0).replace(/./g, function (c, i, a) {
		            return i && c !== '.' && ((a.length - i) % 3 === 0) ? ' ' + c : c;
	            }) + ' $'
                : '$' + price.toFixed(0).replace(/./g, function (c, i, a) {
                    return i && c !== '.' && ((a.length - i) % 3 === 0) ? ',' + c : c;
                });
        }
    }
    
    function formatPriceTipData(priceDetail) {
        if (priceDetail) {
            var data = priceDetail.pricingData || {};
            var incentives = priceDetail.pricingData.incentiveList;
            var planId = getPlanId(priceDetail);
            var pricingData = {
                basePrice: formatPrice(priceDetail.pricingData.basePrice),
                options: formatPrice(priceDetail.pricingData.options),
                destinationCharges: formatPrice(priceDetail.pricingData.destinationCharges),
                sellingPrice: formatPrice(priceDetail.pricingData.sellingPrice),
                totalIncentives: formatPrice(priceDetail.pricingData.incentives),
                price: formatPrice(priceDetail.pricingData.price),
                showFriendsAndNeighbors: (priceDetail.pricingData.showFriendsAndNeighbors && priceDetail.pricingData.showFriendsAndNeighbors == true),
                friendsAndNeighborsSavings: formatPrice(priceDetail.pricingData.friendsAndNeighborsSavings),
                incentives: [],
                paymentType: data.paymentType,
                planId: planId,
                planTypes: {
                    'msrp': (planId === 'msrp'),
                    'az': (planId === 'az'),
                    'x': (planId === 'x')
                }
            };
            // NZ: BRAND-17568
            if (_ctx.region === 'CA') {
                Object.assign(pricingData, {
                    caDeliveryAllowance: data.caDeliveryAllowance && formatPrice(data.caDeliveryAllowance),
                    caSupplementDeliveryAllowance: data.caSupplementDeliveryAllowance && formatPrice(data.caSupplementDeliveryAllowance),
                    caEmployeePricingDiscount: data.caEmployeePricingDiscount && formatPrice(data.caEmployeePricingDiscount),
                    caAcTax: data.caAcTax && formatPrice(data.caAcTax),
                    luxuryTax: data.luxuryTax && formatPrice(data.luxuryTax),
                    caGreenLevy: data.caGreenLevy && formatPrice(data.caGreenLevy),
                    caSalesTax: data.caSalesTax && formatPrice(data.caSalesTax),
                    caLeasePaymentSalesTax: data.caLeasePaymentSalesTax && formatPrice(data.caLeasePaymentSalesTax),
                    totalIncentives: data.incentives && formatPrice(data.incentives),
                    tradeIn: data.tradeIn && formatPrice(data.tradeIn),
                    hasBuyPaymentType: !!(data.paymentType && data.paymentType === 'buy'),
                    hasLeasePaymentType: !!(data.paymentType && data.paymentType === 'lease')
                });
            }
            if (incentives) {
                for (var i = 0; i < incentives.length; i ++) {
                    var incentiveItem = {
                        name: incentives[i].Name,
                        disclaimer: incentives[i].Disclaimer,
                        amount: formatPrice(incentives[i].Amount),
                        offerValidRange: FD.Brand.Util.dateTime.longFormat(incentives[i].StartDate) + '-' + FD.Brand.Util.dateTime.longFormat(incentives[i].ExpiryDate)
                    }
                    pricingData.incentives.push(incentiveItem);
                }
            }
            return pricingData;
        }
    }

    function pricingAttribute($el, attributeName) {
        return $.parseJSON($el.closest('[' + attributeName + ']').attr(attributeName) || '{}');
    }

    function postalLink() {
        var pc = user.location.current().postalCode || '';
        var pcLabel = _postalLinkPrefix + ' ' + pc;
        return '<a data-fgx-postal-link href="#$postalCode" role="button" data-fgx-keypress="true" aria-label="' + pcLabel + '">' + (user.location.current().postalCode || '(Enter a Location)') + '</a>';
    }

    function viewAllOffersLink() {
        var label = 'view all offers',
            ariaLabel = '',
            mtxAction = _mtxActions && _mtxActions.viewOffersClickAction,
            mtxActionAttr = (mtxAction) ? (" data-fd-metrics-click='" + mtxAction + "'") : '';
        if(_ctx && _ctx.pricingDisclaimerLabels) {
            label = _ctx.pricingDisclaimerLabels.viewOffersLabel || 'view all offers';
            ariaLabel = _ctx.pricingDisclaimerLabels.viewOffersAriaLabel || '';
        }

        return '<a data-fgx-view-offers-link href="#$incentives" data-fgx-keypress="true" aria-label="' + ariaLabel + '"' + mtxActionAttr + '>' + label + '</a>';
    }

    function showFlip(cfg, $el) {
        var def = $.Deferred();
        init().done(function() {
            var spcCfg = resolveConfig(cfg, true);
            var trimId = cfg.trimId;
            $.when(trimId && pricingTrims(cfg)).done(function(trimData) {
                var trimDetail = trimData && trimData[(trimId || '').trim()];
                if (trimDetail) {
                    spcCfg.trim = trimDetail.token;
                }
                var currentPostalCode = user.location.current().postalCode;
                var postalFlipEvent = false;
                win.fdcc.spc.reset();
                win.fdcc.spc.show(function(resp) {
                    // check for postal code update
                    if(postalFlipEvent && resp.zipcode !== currentPostalCode) {
                        user.location.setPostalCode(resp.zipcode);
                    }
                    def.resolve(resp);
                }, spcCfg, function(eventName) {
                    if('PostalCodeEntryView' === eventName) {
                        postalFlipEvent = true;
                    }

                    var metrics = brand && brand.Metrics || {handler: { direct: function() {}}};
                    //Event handling for metrics
                    if ('FinanceTabView' === eventName) {
                        // new metrics
                        if(_mtxActions && !metrics.spcFlags.tabDisplayed('finance')) {
                            var action = (metrics.spcFlags.tabDisplayed('lease') || metrics.spcFlags.tabDisplayed('purchase')) ? 'spcFinanceTabAdditionalViewAction' : 'spcFinanceTabViewAction';
                            metrics.handler.direct(
                                _mtxActions[action]
                            );
                            metrics.spcFlags.set('finance', true);
                        }
                    } else if ('LeaseTabView' === eventName) {
                        // new metrics
                        if(_mtxActions && !metrics.spcFlags.tabDisplayed('lease')) {
                            var action = (metrics.spcFlags.tabDisplayed('finance') || metrics.spcFlags.tabDisplayed('purchase')) ? 'spcLeaseTabAdditionalViewAction' : 'spcLeaseTabViewAction';
                            metrics.handler.direct(
                                _mtxActions[action]
                            );
                            metrics.spcFlags.set('lease', true);
                        }
                    } else if ('PurchaseTabView' === eventName) {
                        // new metrics
                        if(_mtxActions && !metrics.spcFlags.tabDisplayed('purchase')) {
                            var action = (metrics.spcFlags.tabDisplayed('finance') || metrics.spcFlags.tabDisplayed('lease')) ? 'spcPurchaseTabAdditionalViewAction' : 'spcPurchaseTabViewAction';
                            metrics.handler.direct(
                                _mtxActions[action]
                            );
                            metrics.spcFlags.set('lease', true);
                        }
                    } else if ('FinancePrintClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcFinancePrintClickAction
                            );
                        }
                    } else if ('LeasePrintClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcLeasePrintClickAction
                            );
                        }
                    } else if ('PurchasePrintClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcPurchasePrintClickAction
                            );
                        }
                    } else if ('CreditLinkClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcCreditLinkClickAction
                            );
                        }
                    } else if ('CalculatorHidden' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcCalculatorHiddenAction
                            );
                        }
                        metrics.spcFlags.reset();
                    } else if ('FinanceChangeModelClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcFinanceChangeModelClickAction
                            );
                        }
                    } else if ('LeaseChangeModelClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcLeaseChangeModelClickAction
                            );
                        }
                    } else if ('PurchaseChangeModelClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcPurchaseChangeModelClickAction
                            );
                        }
                    } else if ('FinanceUpdatePostalClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcFinanceUpdatePostalCodeClickAction
                            );
                        }
                    } else if ('LeaseUpdatePostalClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcLeaseUpdatePostalCodeClickAction
                            );
                        }
                    } else if ('PurchaseUpdatePostalClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcPurchaseUpdatePostalCodeClickAction
                            );
                        }
                    } else if ('FinanceIballClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcFinanceIballClickAction
                            );
                        }
                    } else if ('LeaseIballClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcLeaseIballClickAction
                            );
                        }
                    } else if ('PurchaseIballClick' === eventName) {
                        // new metrics
                        if(_mtxActions) {
                            metrics.handler.direct(
                                _mtxActions.spcPurchaseIballClickAction
                            );
                        }
                    }
                }, $el);

            });
        }).fail(function() {
            def.reject();
        });
        return def.promise();
    }

    /**
     * Refresh pricing templates for given element
     * @param $el
     */
    function refresh(element, noTrack) {
        var def = $.Deferred();
        var templateAttrSelector = '[data-pricing-template],[data-pricing-template-lease],[data-pricing-template-finance],[data-pricing-template-cash]';
        if(!noTrack) {
            _refreshList.push(element);
        }
        // init().done(function() {
            var elements = [];
            var templatePromises = [];
            $(templateAttrSelector, element).each(function () {
                var $el = $(this);
                var defTemp = $.Deferred();
                var templateText = $el.attr('data-pricing-template');
                var pricePlaceholderOnly = checkTemplateForPlaceholder(templateText, '{price}');
                var cfg = resolveConfig(pricingAttribute($el, 'data-pricing-context'), false);
                var trimId = $el.attr('data-pricing-trim') || cfg.trimId;
                if(!trimId && !cfg.configToken && !cfg.vin && pricePlaceholderOnly) {
                    // short circuit to use nameplate pricing
                    nameplatePricing().done(function(npPricing) {
                        var pricing = npPricing.find(function (i) {
                            return i.model === cfg.model && i.year === cfg.year;
                        });
                        var priceValue = getPrice(pricing);
                        var price = formatPrice(priceValue);
                        var data = {
                            'price': price || '{price}'
                        };
                        var text;
                        if(templateText === '{price}') {
                            text = data.price;
                        } else {
                            var template = brand.Util.template(templateText || '',
                                {interpolate: /{([\s\S]+?)}/g});
                            text = template(data);
                        }
                        $el.html(text);
                        if(price) {
                            $el.data('pricing', {
                                price: price,
                                priceValue: priceValue
                            });
                        }
                        updateLabels($el, pricing);
                        elements.push($el);
                        disclosures.updateDisclosures($el);
                        defTemp.resolve();
                    });
                    return;
                }
                $.when(trimId && pricingTrims(cfg)).done(function(trimData) {
                    var trimDetail = null;
                    var spcTrimId = null;
                    // translate trim id for SPC
                    if(trimId) {
                        trimDetail = trimData && trimData[(trimId || '').trim()];
                        if(trimDetail) {
                            if(pricePlaceholderOnly) {
                                var priceValue = getPrice(trimDetail);
                                var price = formatPrice(priceValue);
                                var data = {
                                    'price': price || '{price}'
                                };
                                var text;
                                if(templateText === '{price}') {
                                    text = data.price;
                                } else {
                                    var template = brand.Util.template(templateText || '',
                                        {interpolate: /{([\s\S]+?)}/g});
                                    text = template(data);
                                }
                                $el.html(text);
                                if(price) {
                                    $el.data('pricing', {
                                        price: price,
                                        priceValue: priceValue
                                    });
                                }
                                updateLabels($el, trimDetail);
                                elements.push($el);
                                disclosures.updateDisclosures($el);
                                defTemp.resolve();
                                return;
                            }
                            spcTrimId = trimDetail.token;
                        } else {
                            spcTrimId = '#none#';
                            util.log('Invalid trim id ' + trimId, trimData);
                        }
                    }
                    getPricingData(cfg).done(function(result) {
                        var data;
                        var text = templateText;
                        data = (spcTrimId) ? result.find(function(i) { return  i.trim === spcTrimId; }) : result;
                        if (Array.isArray(data)) {
                            data = data[0]
                        }

                        if(data) {
                            if (useAsShownLabel($el)) {
                                data.pricingLabel = getAsShownLabel(pricingAttribute($el, 'data-pricing-labels'), data);
                            } else {
                                data.pricingLabel = getLabel(pricingAttribute($el, 'data-pricing-labels'), data);
                            }
                            templateText = templateText || $el.attr('data-pricing-template-' + data.offerType);
                            var template = brand.Util.template(templateText,
                                {interpolate: /{([\s\S]+?)}/g});
                            text = template(data);
                        }
                        $el.html(text);
                        updateLabels($el, data);
                        $el.data('pricing', data);
                        elements.push($el);
                        disclosures.updateDisclosures($el);
                        defTemp.resolve();
                    }).fail(function() {
                        util.log('pricing - getPricingData call failed for cfg: ', cfg);
                        // NZ - resolve the defTemp promise here so the 'done' callback of the templatePromises is properly triggered below.
                        defTemp.resolve();
                    });
                });
                templatePromises.push(defTemp.promise());
            });
            //Update the monthly prices to display if a valid postal code is set.
            $('[data-pricing-payment-toggle]', element).toggleClass('fgx-brand-hidden', !(!!user.location.current().postalCode));
            //Check that the postalCode
            $.when.apply($, templatePromises).done(function() {
                def.resolve(elements);
            });
        // }).fail(function() {
        //     // pricing not available, update with template text as placeholder
        //     var attrs = templateAttrSelector.replace(/[\[\]]/g, '').split(',');
        //     $(templateAttrSelector, element).each(function() {
        //         var $el = $(this);
        //         _.each(attrs, function(attr) {
        //             var template = $el.attr(attr);
        //             if(template) {
        //                 $el.html(template);
        //                 return false;
        //             }
        //         });
        //     });
        // });
        return def.promise();
    }
    
    function useAsShownLabel($el) {
        return ($el.closest('[data-pricing-context]').attr('data-pricing-use-as-shown') === 'true');
    }

    function getPlanId(pricing) {
        var planType = _userPricing.planType;
        if(pricing.planApplicable === true || pricing.planApplicable === false) {
            return (pricing.planApplicable) ? {'MSRP': 'msrp', 'AZ': 'az'}[planType] || 'x' : 'msrp';
        } else {
            return (planType !== 'MSRP' &&
                (_userPricing.planType === 'AZ'
                    ? pricing.az && 'az'
                    : !(pricing[_userPricing.planType.toLowerCase()] === false) && pricing.x && 'x'))
                || 'msrp';
        }
    }

    function getPrice(pricing) {
        return pricing && pricing[getPlanId(pricing)];
    }

    function getLabel(labels, pricing) {
        return $.extend({}, _baseLabels, labels)[pricing && getPlanId(pricing) || 'msrp'];
    }
    
    function getAsShownLabel(labels, pricing) {
        return $.extend({}, _baseLabels, labels)[pricing && ('as-shown_' + getPlanId(pricing)) || 'as-shown_msrp'];
    }

    function updateLabels($el, pricing) {
        var labels = pricingAttribute($el, 'data-pricing-labels');
        var parentSelector = $el.attr('data-pricing-label-parent-selector');
        var $parentEl = (parentSelector && typeof(parentSelector) != 'undefined') ? $el.closest(parentSelector) : $el.parent();

        if($parentEl && $parentEl.length > 0) {
            var label = (useAsShownLabel($el)) ? getAsShownLabel(labels, pricing) : getLabel(labels, pricing);
            $parentEl.find('[data-pricing-label]').html(label);
        }
        //NZ was - $el.parent().find('[data-pricing-label]').html(getLabel(labels, pricing));
    }

    /**
     * Check if the passed in placeholder exists in the templateText, and if so, if it is the only placeholder used.
     * Will return true if the passed in placeholder is the only placeholder used within templateText. Otherwise, returns false.
    **/
    function checkTemplateForPlaceholder(templateText, placeholder) {
        var flag = false,
            ph = placeholder || '{price}';

        if(templateText && typeof(templateText) != 'undefined') {
            var res = templateText.match(/{([\s\S]+?)}/g);

            if(res) {
                var tmpFlag = true;
                res.forEach(function(item) {
                    if(item != ph) {
                        tmpFlag = false;
                    }
                });
                flag = tmpFlag;
            }
        }

        return flag;
    }

    function getPricingData(cfg) {
        var key = [cfg.make, cfg.model, cfg.year, cfg.configToken, cfg.vin].join('');
        var pricingPromise = _pricingDataCache[key];
        if(!pricingPromise) {
            if(!(cfg.make && cfg.model && cfg.year)) {
                pricingPromise = $.when(null);
            } else {
                var def = $.Deferred();
                init().done(function () {
                    // SPC is not reentrant, poll until available
                    var pollPricing = function () {
                        if (!win.fdcc.spc.isBusy() && !_spcLock) {
                            _spcLock = true;
                            ((cfg.configToken || cfg.vin) ? detail(cfg) : models(cfg)).done(function (result) {
                                _spcLock = false;
                                if (result) {
                                    def.resolve(result);
                                } else {
                                    def.reject();
                                }
                            });
                        } else {
                            setTimeout(pollPricing, 100);
                        }
                    };
                    pollPricing();
                }).fail(function() {
                    def.reject();
                });
                pricingPromise = def.promise();
            }
            _pricingDataCache[key] = pricingPromise;
        }
	    return pricingPromise;
    }

    function detail(cfg) {
        var def = $.Deferred();
        win.fdcc.spc.calculate(function (resp) {
            if (resp) {
                /* NZ: BRAND-17526 - Added basePrice to the object below. This is to support showing the BaseMSRP as the
                   starting at price when a configToken is used. (i.e. in the simple reservations component) */
                var pricing = {
                    id: resp.trimName && resp.trimName.substr(resp.model.length + 1).replace(/ /g, '').toLowerCase(),
                    trim: resp.trim,
                    trimName: resp.trimName,
                    offerType: (resp.paymentType === 'lease') ? 'lease' : ((resp.buy && resp.buy.specialApr) ? 'finance' : 'cash'),
                    price: formatPrice(resp.price),
                    priceValue: resp.price,
                    paymentType: resp.paymentType,
                    baseAsShown: formatPrice(resp.baseAsShown),
                    basePrice: formatPrice(resp.basePrice || resp.price),
                    pricingData: resp,
                    payment: formatPrice(resp.payment),
                    apr: (resp.buy && resp.buy.apr) || (resp.lease && resp.lease.apr),
                    term: (resp.buy && resp.buy.term) || (resp.lease && resp.lease.term),
                    signingAmount: formatPrice(resp.lease && resp.lease.signingAmount),
                    pricingDate: FD.Brand.Util.dateTime.longFormat(),
                    planApplicable: resp.planApplicable,
                    postalCode: postalLink(),
                    hasPostalCode: (!!user.location.current().postalCode),
                    downPayment: formatPrice(resp.downPayment),
                    incentives: formatPrice(resp.incentives),
                    viewOffersLink: viewAllOffersLink()
                };

                switch (pricing.offerType) {
                    case 'lease':
                        pricing.offerText = formatPrice(resp.payment) + '/mo ' + resp.lease.term + ' month lease';
                        break;
                    case 'finance':
                        pricing.offerText = formatPrice(resp.payment) + '/mo ' + resp.buy.term + ' month finance';
                        break;
                }
                def.resolve(pricing);
            } else {
                def.resolve(null);
            }
        }, resolveConfig(cfg, false));
        return def.promise();
    }

    function models(cfg) {
        var def = $.Deferred();
        var resolvedConfig = resolveConfig(cfg, false);
        pricingTrims(cfg).done(function(trimData) {
            // If the pricingTrims promise is resolved with a null value, then there must be something preventing the modelSlices
            // call from succeeding. When this happens, we should be able to resolve the current promise with a null value
            // without calling calculateTrimPayments.
            if (trimData === null) {
                def.resolve(null);
                return;
            }
            win.fdcc.spc.calculateTrimPayments(function(resp) {
                if (resp && resp.trimPayments) {
                    var models = resp.trimPayments.map(function(trim) {
                        var bestOffer = null, bestOfferType = null;
                        var ngpTrim = trimData && Object.values(trimData).find(function(i) { return i.token === trim.trim; });
                        ['lease', 'finance', 'cash'].forEach(function(offerType) {
                            var offer = trim[offerType];
                            var pmt = offer && offer.payment;
                            if(pmt && (!bestOffer || bestOffer.payment > pmt)) {
                                bestOffer = offer;
                                bestOfferType = offerType;
                            }
                        });
                        // If bestOffer still isn't set (for example, if the price values returned are all 0) then set it to
                        // an empty object. This should prevent errors from being thrown later when trying to access properties
                        // on the bestOffer object.
                        if (!bestOffer) {
                            bestOffer = {};
                        }

                        /* NZ: BRAND-17526 - Added basePrice to the modelPricing object below to keep it consistent with the
                           response from the detail call above. This is currently set to just use the same value as the price
                           attribute, so we'll need to verify the value is correct before using (if there is a time when this is needed).*/
                        var startingPrice = ngpTrim ? getPrice(ngpTrim) : bestOffer.basePrice ;
                        var modelPricing = {
                            id: trim.trimName && trim.trimName.substr(resp.model.length + 1).replace(/ /g, '').toLowerCase(),
                            trim: trim.trim,
                            trimName: trim.trimName,
                            ngpTrimName: ngpTrim && ngpTrim.ngpTrimName,
                            offer: bestOffer,
                            offerType: bestOfferType,
                            offerPrice: formatPrice(bestOffer.price),
                            offerPriceValue: bestOffer.price,
                            price: formatPrice(startingPrice),
                            basePrice: formatPrice(startingPrice),
                            priceValue: startingPrice,
                            paymentType: bestOffer.paymentType,
                            baseAsShown: formatPrice(bestOffer.baseAsShown),
                            pricingData: trim,
                            payment: formatPrice(bestOffer.payment),
                            apr: (bestOffer.buy && (bestOffer.buy.apr)) || (bestOffer.lease && bestOffer.lease.apr),
                            term: (bestOffer.buy && bestOffer.buy.term) || (bestOffer.lease && bestOffer.lease.term),
                            signingAmount: formatPrice(bestOffer.lease && bestOffer.lease.signingAmount),
                            pricingDate: FD.Brand.Util.dateTime.longFormat(),
                            postalCode: postalLink(),
                            planApplicable: bestOffer.planApplicable,
                            hasPostalCode: (!!user.location.current().postalCode),
                            downPayment: formatPrice(bestOffer && bestOffer.downPayment),
                            incentives: formatPrice(bestOffer && bestOffer.incentives),
                            viewOffersLink: viewAllOffersLink()
                        };

                        switch(bestOfferType) {
                            case 'lease':
                                modelPricing.offerText = formatPrice(bestOffer.payment) + '/mo ' + bestOffer.lease.term + ' month lease';
                                break;
                            case 'finance':
                                modelPricing.offerText = formatPrice(bestOffer.payment) + '/mo ' + bestOffer.buy.term + ' month finance';
                                break;
                        }
                        return modelPricing;
                    });
                    def.resolve(models);
                } else {
                    def.resolve(null);
                }
            }, resolvedConfig);
        });
        return def.promise();
    }
    function nameplatePricing() {
        var defer = $.Deferred();
        var promise = defer.promise();
        var resolvePricing = function () {
            defer.resolve(_nameplatePricingResolved);
        }
        if(!_nameplatePricingResolved) {
            if(_ctx.region === 'CA') {
                _nameplatePricingResolved = promise;
                user.location.detail().done(function (detail) {
                    if (detail && detail.province === 'QC') {
                        // QC, get QC related pricing
                        var key = 'fgx-pricing-QC';
                        var json = win.sessionStorage.getItem(key);
                        _nameplatePricingResolved = json && JSON.parse(json);
                        if (!_nameplatePricingResolved) {
                            $.getJSON('/aemservices/brand/api/nameplate/pricing', {
                                region: _ctx.region,
                                make: _ctx.make,
                                province: detail.province
                            }).done(function (resp) {
                                if (resp) {
                                    win.sessionStorage.setItem(key, JSON.stringify(resp));
                                    _nameplatePricingResolved = resp;
                                    resolvePricing();
                                }
                                defer.resolve(null);
                            }).fail(function () {
                                defer.resolve(null);
                            });
                        } else {
                            resolvePricing();
                        }
                    } else {
                        // not QC, use default pricing
                        _nameplatePricingResolved = _nameplatePricing;
                        resolvePricing();
                    }
                });
            } else {
                _nameplatePricingResolved = _nameplatePricing;
                resolvePricing();
            }
        } else {
            if(_nameplatePricingResolved.promise) {
                promise = _nameplatePricingResolved;
            } else {
                resolvePricing();
            }
        }
        return promise;
    }

    function pricingTrims(context) {
        var defer = $.Deferred();
        var promise = defer.promise();
        if(!(context.model && context.year)) {
            defer.resolve(null);
        } else {
            var key = context.model + '-' + context.year + '-' + context.zipcode;
            var prm = _trimCache[key];
            if (prm) {
                if (prm.promise) {
                    promise = prm;
                } else {
                    defer.resolve(prm);
                }
            } else {
                // check session storage
                var prmJson = win.sessionStorage.getItem('fgx-pricing-trims-' + key);
                if (prmJson) {
                    prm = JSON.parse(prmJson);
                    _trimCache[key] = prm;
                    defer.resolve(prm);
                } else {
                    _trimCache[key] = promise;
                    prm = {};
                    ngp.modelSlices(Object.assign({}, context, {
                        modelSliceDefiners: 'modelId',
                        modelSliceAttributes: 'modelId',
                        planType: _userPricing.planType,
                        postalCode: context.zipcode,
                        appContext: 'T1'
                    })).done(function (model) {
                        util.toArray(util.objPath(model, 'ModelSlices.ModelSlice') || []).forEach(function (ms) {
                            var msAttr = ngp.attributeMap(ms.Attribute);
                            var stId = msAttr.modelId || '';
                            var pricing = ms.Pricing;
                            var applicable = pricing.PlanApplicability;
                            var val = {
                                ngpTrimName: stId,
                                token: ms.ConfigToken,
                                msrp: parseFloat((_ctx.region === 'CA') ? pricing.StartingAtPrice : pricing.BaseMSRP)
                            };
                            if(_ctx.region !== 'CA') {
                                if (applicable.AZ === 'true') {
                                    val.az = parseFloat(pricing.BaseAZPlan);
                                }
                                val.x = parseFloat(pricing.BaseXPlan);
                                if (applicable.SPX === applicable.FNX && applicable.FNX === applicable.PRX) {
                                    if (applicable.SPX !== 'true') {
                                        delete val.x;
                                    }
                                } else {
                                    ['SPX', 'FNX', 'PRX'].forEach(function (plan) {
                                        val[plan.toLowerCase()] = applicable[plan] === 'true';
                                    })
                                }
                            }
                            if (stId) {
                                prm[stId] = val;
                                prm[stId.replace(/[^A-Za-z0-9\-\_\:]/g, '').toLowerCase()] = val;
                            }
                        });
                        _trimCache[key] = prm;
                        try {
                            win.sessionStorage.setItem('fgx-pricing-trims-' + key, JSON.stringify(prm));
                        } catch (ex) {
                            
                        }
                        defer.resolve(prm);
                    }).fail(function() {
                        util.log('pricing - modelSlices call failed.');
                        defer.resolve(null);
                    });
                }
            }
        }
        return promise;
    }

} )(window, jQuery, FD.Brand, FD.Brand.User, FD.Brand.Util, FD.Brand.NgpServices, FD.Brand.Disclosures);

;(function(doc, util) {
    'use strict';

    // check for picture support
    checkPictureSupport();

    //////

    /**
     * Check for picture tag support, load polyfill if not found
     */
    function checkPictureSupport() {
        var img = doc.createElement('img');
        if(!(('srcset' in img) && ('sizes' in img))) {
            util.url.loadAsScript(
                '/etc/designs/brand_ford/brand/vendor/picturefill/js/picturefill.min.js',
                { 'async': '' });
        }
    }

})(document, FD.Brand.Util);
/*global FD*/
;(function(win, $, brand, util, ctx) {

    const isReady = ctx.useInlineDeepDive;

    if (ctx.make === "Lincoln" && isReady) {
        // Lincoln Only Brightcove Init - Was Needed For Media Overlay
        var initialized = false;
        var _settings = ctx && ctx.settings;
        var _globalBcpConfig = {
            'brightcoveAccountId': _settings && _settings.videoAccount,
            'brightcovePlayerId': _settings && _settings.videoPlayerKey,
            'isYoutube': false,
            'defaultFilmstripExpanded': false
        };
        var _bcpInstances = null;
        var _bcpState = null;
        var _loadBcp = getAsyncTopic(loadBcFramework);
    
        // setup namespace
        Object.assign(brand.namespace('FD.Brand.Video', win), {
            bcp: {
                create: bcpCreatePlayer,
                resetInstance: resetBcpInstance
            },
            videoItem: {
                create: function(config) {
                    return new VideoItem(config);
                }
            }
        });
    
        //////
    
        // helper for topics retrieved asynchronously
        // wraps a common promise that is returned
        // deferred is passed into load function and resolved when topic is loaded
        // this makes the function reentrant without initiating multiple requests to load topic
        function getAsyncTopic(fnLoad) {
            var promise = null;
            var fn = function() {
                var def;
                if(promise === null) {
                    def = $.Deferred();
                    promise = def.promise();
                    fnLoad(def);
                }
                return promise;
            };
            fn.$_reset = function() {
                promise = null;
            };
            return fn;
        }
    
        function loadBcFramework(def) {
            var resolveState = function() {
                def.resolve(Object.assign({},_bcpState));
            };
            if (_bcpState) {
                resolveState();
            } else {
                _bcpState = {
                    loaded: false,
                    basePath: '/etc/designs/brand_ford/brand/vendor/brightcove/js'
                };
    
                util.url.loadAsScript(_bcpState.basePath + '/bcgs_ford_player_framework.min.js').done(function() {
                    _bcpState.loaded = true;
    
                    try {
                        FordPlayer.setPageWideConfig(_globalBcpConfig);
                    } catch(e) {
                        util.log("video.lib: There was an error setting the pageWideConfig");
                    }
    
                    resolveState();
                }).fail(function(resp) {
                    util.log('video.lib: failed to load the brightcove plugin framework', resp);
                    resolveState();
                });
            }
        }
    
        /*
         * Simple API to standardize some of the logic needed that may be different between the Brightcove and Youtube players.
         */
        function bcpPlayerAPIWrapper(config, framework, player) {
            var api = {};
            if(framework && player) {
                api = {
                    autoplay: function () {
                        var shouldAutoplay = (util.currentBreakpoint === 'gux-bkpt-sm') ? false : true;
                        player.autoplay(shouldAutoplay);
    
                        player.one("play", function() {
                            player.autoplay(true);
                        });
                    },
                    getCurrentTime: function () {
                        // BCP Update - Standardize logic to properly handle getting the current time from both BC and YT players.
                        var cT = 0;
                        try {
                            cT = (config && config.isYoutube) ? player.getCurrentTime() : player.currentTime();
                        } catch(e) {
                            util.log("video.lib::apiWrapper.getCurrentTime - issue retrieving currentTime from player.");
                        }
                        return cT;
                    },
                    setConfig: function (_config) {
                        config = Object.assign({}, config, _config);
                    },
                    setCurrentVideo: function (_currentVideo) {
                        config.currentVideo = _currentVideo;
                    },
                    hasFullscreen: function() {
                        // BCP Update - youtube player doesn't indicate when the fullscreen mode is entered, so we use this
                        // check to ensure the logic is only run when using a Brightcove player.
                        return !!(config && !config.isYoutube);
                    },
                    isFullscreen: function() {
                        var isFS = false;
                        try {
                            isFS = player.isFullscreen() || false;
                        } catch(e) {
                            util.log("video.lib::apiWrapper.isFullscreen - issue retrieving fullscreen value from player");
                        }
                        return isFS;
                    }
                };
            }
            return api;
        }
    
        function bcpCreatePlayer(bcpConfig, brandConfig) {
            var def = $.Deferred();
            bcpInitPlayer(bcpConfig, brandConfig).then(function(playerDetail) {
                var config = Object.assign({}, brandConfig, bcpConfig);
                if (playerDetail && playerDetail.playerApi) {
                    playerDetail.playerApi.setConfig(config);
                }
    
                var obj = Object.assign({}, config, playerDetail);
    
                if (obj && obj.bcpFramework && !obj.firstInstance) {
                    // if the player has already been created before, then we need to reinitialize it with the latest config
                    obj.bcpFramework.reInit(bcpConfig);
                }
    
                def.resolve(obj);
            }, function() {
                //Added to handle error state when player is not loaded due to privacy settings.
                def.resolve(null);
            });
            return def.promise();
        }
    
        function bcpInitPlayer(bcpConfig, brandConfig) {
            //Media Overlays Get Here.
            var def = $.Deferred();
            if(util.url.allowScript('6')) {
                var instId = brandConfig && brandConfig.fgxInstanceId || '';

                if (_bcpInstances && _bcpInstances[instId] && _bcpInstances[instId].initialized && !bcpConfig.isLincoln) {
                    _bcpInstances[instId].firstInstance = false;
                    def.resolve(_bcpInstances[instId]);
                } else {
                    _bcpInstances = _bcpInstances || {};
                    var bcVidDetail = {};
                    var _instId = instId;
                    var settings = brand.Context.settings;
                    var language = brand.Context.language;
    
                    bcVidDetail.firstInstance = true;

                    if (brandConfig && brandConfig.fgxSetupSlideItem) {
                        var data = {
                            index: brandConfig.index,
                            count: brandConfig.count,
                            typeSelector: brandConfig.slideItemClass,
                            playerWrapperId: bcpConfig.placeHolderDivId,
                            slideHeadlineId: brandConfig.slideHeadlineId,
                            slideTitle: brandConfig.slideTitle,
                            slideDescription: brandConfig.slideDescription
                        };
                        var $bcSlideItem = $(brandConfig.template(data));
    
                        // Checking If Player Is In Lincoln Overlay To Avoid Conflicts
                        const deepDive = $bcSlideItem.closest('inlineDeepDive');
                        if (!Boolean(deepDive)) {
                            $bcSlideItem.addClass('active');
                        }
                        $bcSlideItem.appendTo(brandConfig.slideContainer);
                        bcVidDetail.slideItem = $bcSlideItem;
                    }
    
                    _loadBcp().done(function(state) {
                        if (state.loaded) {
                            bcVidDetail.initialized = true;
                            bcVidDetail.bcpFramework = FordPlayer.create(bcpConfig);
                            bcVidDetail.bcpFramework.on('ready', function() {
                                bcVidDetail.player = bcVidDetail.bcpFramework.getPlayer();
                                bcVidDetail.playerApi = bcpPlayerAPIWrapper(Object.assign({}, brandConfig, bcpConfig), bcVidDetail.bcpFramework, bcVidDetail.player);
                                _bcpInstances[_instId] = bcVidDetail;
                                def.resolve(_bcpInstances[_instId]);
                            });
                        } else {
                            bcVidDetail.initialized = false;
                            bcVidDetail.bcpFramework = null;
                            bcVidDetail.player = null;
                            bcVidDetail.playerApi = null;
                            _bcpInstances[_instId] = bcVidDetail;
                            def.resolve(_bcpInstances[_instId]);
                        }
                    });
                }
            } else {
                util.log('video.lib: Brightcove Player Framework library not loaded due to privacy settings');
                def.reject();
                let brightcoveComponents = ['.bri-billboard-slide-generic', '.billboard-homepage-slide'];
    
                function updateBillboardElements(container, videoSelector, imgSelector) {
                    let video = container[0].querySelectorAll(videoSelector);
                    let img = container[0].querySelectorAll(imgSelector);
                
                    video[0].style.display = 'none';
                    img[0].style.display = 'block';
                }
                
                brightcoveComponents.forEach(function(component) {
                    let brightcoveContainer = document.querySelectorAll(component);
                    if (brightcoveContainer.length === 0) return;
                    updateBillboardElements(brightcoveContainer, '.inline-video-container', 'picture');
                });
            }
            return def.promise();
        }
    
        function resetBcpInstance(id) {
            if (_bcpInstances && _bcpInstances[id]) {
                _bcpInstances[id].initialized = false;
            }
        }
    
    
        // New VideoItem Class
        function VideoItem(config) {
            this.config = Object.assign({}, config || {});
            this.settings = Object.assign({}, this.config.settings || {});
            this.actions = Object.assign({}, this.config.actions || {});
            this.id = this.config.id || '';
            this.fgxInstanceId = this.config.fgxInstanceId || this.id;
            this.slideItem = this.config.slideItem;
            this.videoContainer = this.config.videoContainer;
            this.type = this.config.type;
            this.displayType = this.config.displayType;
            this.altMobileBp = this.config.altMobileBp || false;
            this.initialized = false;
            this.playing = false;
            this.loading = false;
            this.manuallyPaused = false;
            this.skipManualPauseUpdate = false;
            this.transitionLock = false;
    
            this._bcpBaseConfig = {
                'placeHolderDivId': this.config.id,
                'isYoutube': false,
                'showFilmstripToggle': !(this.config.displayType === 'inline'),
                'defaultFilmstripExpanded': false,
                'autoPlay': false
            };
            this._brandBaseConfig = {
                'fgxInstanceId': this.config.id,
                'fgxSetupSlideItem': !(this.config.displayType === 'inline')
            };
    
            this.bcpConfig = Object.assign({}, this._bcpBaseConfig, this.config.bcpConfig || {});
            this.brandConfig = Object.assign({}, this._brandBaseConfig, this.config.brandConfig || {});
    
            this._mtxBcpVidSegments = {
                'videoStart': {
                },
                'videoSegment25': {
                    videoNamePercentageWatched: '25% complete'
                },
                'videoSegment50': {
                    videoNamePercentageWatched: '50% complete'
                },
                'videoSegment75': {
                    videoNamePercentageWatched: '75% complete'
                },
                'videoComplete': {
                    videoNamePercentageWatched: 'video complete'
                }
            };
    
            this._topics = {};
            this._nextHandleId = 0;
        }
    
        VideoItem.prototype.autoplayBPClasses = {
            'gux-bkpt-sm': 'fgx-brand-video-autoplay-mbl',
            'gux-bkpt-med': 'fgx-brand-video-autoplay-tab',
            'gux-bkpt-lg': 'fgx-brand-video-autoplay-dsk',
            'gux-bkpt-xlg': 'fgx-brand-video-autoplay-dsk'
        };
    
        VideoItem.prototype.autoplayBPClassesNoTab = {
            'gux-bkpt-sm': 'fgx-brand-video-autoplay-mbl',
            'gux-bkpt-med': 'fgx-brand-video-autoplay-mbl',
            'gux-bkpt-lg': 'fgx-brand-video-autoplay-dsk',
            'gux-bkpt-xlg': 'fgx-brand-video-autoplay-dsk'
        };
    
        VideoItem.prototype.create = function(bcpConfig, brandConfig) {
            var def = $.Deferred();
            if (this.initialized) {
                def.resolve(this);
            } else {
                this.bcpConfig = Object.assign({}, this.bcpConfig || {}, bcpConfig || {});
                this.brandConfig = Object.assign({}, this.brandConfig || {}, brandConfig || {});
                var _this = this;
    
                brand.Video.bcp.create(this.bcpConfig, this.brandConfig).then(function(vConfig) {
                    if(vConfig && vConfig.initialized) {
                        _this.config = Object.assign({}, _this.config || {}, vConfig);
                        _this.initialized = true;
                        _this.config.bcScriptLoaded = true;
    
                        // NZ: Only set the 'muted' property based on autoplay status here if the 'muted' property isn't
                        // specifically set within the settings object that's passed in, or if its set to null.
                        if (_this.settings && (_this.settings.muted === null || typeof(_this.settings.muted) == 'undefined')) {
                            _this.settings.muted = _this.autoplayEnabledOnBP();
                        }
    
                        _this.setSettingsOnPlayer();
    
                        if (_this.config.bcpFramework) {
                            _this.config.bcpFramework.on('play', function() {
                                _this.playing = true;
                                _this.setManuallyPaused(false);
                                _this.publishTopic('play', {
                                    topic: 'play',
                                    inst: _this
                                });
                            });
                            _this.config.bcpFramework.on('pause', function() {
                                _this.playing = false;
                                _this.setManuallyPaused(true);
                                _this.publishTopic('pause', {
                                    topic: 'pause',
                                    inst: _this
                                });
                            });
                            _this.config.bcpFramework.on('ended', function() {
                                _this.playing = false;
                                _this.setManuallyPaused(true, true);
                                _this.publishTopic('ended', {
                                    topic: 'ended',
                                    inst: _this
                                });
                            });
                            _this.config.bcpFramework.on('loaded', function() {
                                _this.publishTopic('loaded', {
                                    topic: 'loaded',
                                    inst: _this
                                });
                                // Trigger an event when an inline video is loaded. Currently used to recalculate values in animation logic
                                $(document).trigger('brandinlinevid:loaded', [{
                                    topic: 'loaded',
                                    inst: _this
                                }]);
                            });
                            _this.config.bcpFramework.on('videoStart', function(data) {
                                _this.segmentUpdate('videoStart');
                            });
                            _this.config.bcpFramework.on('first-quartile', function(data) {
                                _this.segmentUpdate('videoSegment25');
                            });
                            _this.config.bcpFramework.on('second-quartile', function(data) {
                                _this.segmentUpdate('videoSegment50');
                            });
                            _this.config.bcpFramework.on('third-quartile', function(data) {
                                _this.segmentUpdate('videoSegment75');
                            });
                            _this.config.bcpFramework.on('fourth-quartile', function(data) {
                                _this.segmentUpdate('videoComplete');
                            });
    
                            if (_this.config.playerApi && _this.config.playerApi.hasFullscreen() && _this.config.player) {
                                _this.config.player.on("fullscreenchange", function() {
                                    if(_this.config.playerApi) {
                                        var isFS = _this.config.playerApi.isFullscreen();
                                        if(isFS) {
                                            _this.fireMetricAction('videoExpand');
                                        }
                                    }
                                });
                            }
                        }
    
                        def.resolve(_this);
                    } else {
                        _this.config = Object.assign({}, _this.brandConfig);
                        _this.config.bcScriptLoaded = false;
                        def.resolve(_this);
                    }
                });
            }
    
            return def.promise();
        };
    
        VideoItem.prototype.loadInViewport = function() {
            var def = $.Deferred();
            if (this.initialized) {
                def.resolve(this);
            } else {
                var $container = $(this.videoContainer);
                //if (!this.loading && brand.Util.inViewport($container) && $container.css('display') != 'none' && $container.css('visibility') != 'hidden') {
                if (!this.loading && this.isVisible()) {
                    this.loading = true;
                    this.create().done(function(inst) {
                        this.loading = false;
                        if (inst && inst.initialized) {
                            $container.attr('data-fgx-inline-video-initialized', 'true');
                        }
                        def.resolve(inst);
                    });
                } else {
                    def.resolve(this);
                }
            }
            return def.promise();
        };
    
        VideoItem.prototype.loadInitialStateForBP = function() {
            this.loadInViewport().done(function(inst) {
                if (inst && inst.initialized && inst.autoplayEnabledOnBP() && inst.isVisible()) {
                    inst.play(true);
                }
            });
        };
    
        VideoItem.prototype.getFramework = function() {
            return (this.config && this.config.bcpFramework) ? this.config.bcpFramework : null;
        };
    
        VideoItem.prototype.setSettingsOnPlayer = function(_settings) {
            var _this = this;
            if (_this.config.player) {
                var settings = !brand.Util.isEmpty(_settings) ? _settings : (_this.settings || {})
                Object.keys(settings).forEach(function(key) {
                    var val = settings[key];
                    if (val !== null && typeof(val) !== 'undefined') {
                        try {
                            _this.config.player[key](val);
                        } catch(e) {
                            util.log("VideoItem::setSettingsOnPlayer - error occurred setting the method on the player. {method}:{val} - ", key, ' : ', val, ' ', e);
                        }
                    }
                });
            }
        };
    
        VideoItem.prototype.play = function(skipMPUpdate) {
            var framework = this.getFramework();
            if (framework) {
                try {
                    if (this.transitionLock || this.playing) {
                        return;
                    }
                    if (skipMPUpdate) {
                        this.skipManualPauseUpdate = true;
                    }
                    framework.play();
                } catch(e) {
                    brand.Util.log('VideoItem::play - error when trying to play the current video. ', e);
                    this.skipManualPauseUpdate = false;
                }
            }
        };
    
        VideoItem.prototype.pause = function(skipMPUpdate) {
            var framework = this.getFramework();
            if (framework) {
                try {
                    if (!this.playing) {
                        return;
                    }
                    if (skipMPUpdate) {
                        this.skipManualPauseUpdate = true;
                    }
                    framework.pause();
                } catch(e) {
                    brand.Util.log('VideoItem::pause - error when trying to pause the current video. ', e);
                    this.skipManualPauseUpdate = false;
                }
            }
        };
    
        VideoItem.prototype.getAutoplayClassForBP = function() {
            let bp = brand.Util.currentBreakpoint(),
                classMap = (this.altMobileBp) ? this.autoplayBPClassesNoTab : this.autoplayBPClasses;
            return classMap && classMap[bp] || 'fgx-brand-video-autoplay-dsk';
        };
    
        VideoItem.prototype.autoplayEnabledOnBP = function() {
            var $container = $(this.videoContainer);
            return ($container.hasClass(this.getAutoplayClassForBP()));
        };
    
        VideoItem.prototype.displayOnBP = function() {
            var bp = brand.Util.currentBreakpoint();
            return !((bp == 'gux-bkpt-sm' || (bp == 'gux-bkpt-med' && this.altMobileBp)) && this.hiddenOnMobile());
        };
    
        VideoItem.prototype.isVisible = function() {
            var $container = $(this.videoContainer);
            var visible = false;
            if (brand.Util.inViewport($container) && $container.is(':visible')) {
                visible = true;
            }
            return visible;
        };
    
        VideoItem.prototype.setTransitionLock = function(_isTransitioning) {
            this.transitionLock = _isTransitioning;
        };
    
        VideoItem.prototype.isTransitioning = function() {
            return this.transitionLock;
        };
    
        VideoItem.prototype.hiddenOnMobile = function() {
            return ($(this.videoContainer).hasClass('.hide-video-on-mobile'));
        };
    
        VideoItem.prototype.shownOnMobile = function() {
            return !(this.hiddenOnMobile());
        };
    
        VideoItem.prototype.isPlaying = function() {
            return this.playing;
        };
    
        VideoItem.prototype.isManuallyPaused = function() {
            return this.manuallyPaused;
        };
    
        VideoItem.prototype.setManuallyPaused = function(_paused, forceUpdate) {
            if (!this.skipManualPauseUpdate || forceUpdate) {
                this.manuallyPaused = _paused;
            }
            this.skipManualPauseUpdate = false;// reset skip manual pause update
        };
    
        // Subscribe/publish topic slightly modified from original implementation in user.lib.js
        VideoItem.prototype.subscribeTopic = function(topic, callback, _once) {
            if(!this._topics[topic]) {
                this._topics[topic] = []
            }
            var handle = {
                topic: topic,
                id: ++this._nextHandleId,
                once: _once || false
            };
            this._topics[topic].push({
                handle: handle,
                callback: callback
            });
            return handle;
        };
    
        VideoItem.prototype.publishTopic = function(topic, data, callback) {
            if(!this._topics[topic]) {
                return false;
            }
            var _this = this,
                _unsubscribeList = [];
            setTimeout(function notifyTopic() {
                (callback ? [{ callback: callback }] : _this._topics[topic]).forEach(function(subscriber) {
                    try {
                        subscriber.callback(data, topic);
    
                        var _handle = subscriber && subscriber.handle;
                        if (_handle && _handle.once) {
                            _unsubscribeList.push(_handle);
                        }
                    } catch(ex) {
                        util.log('video.lib: error occurred publishing videoItem topic ' + topic, data, ex);
                    }
                });
                if (_unsubscribeList.length > 0) {
                    _unsubscribeList.forEach(function(_handle) {
                        try {
                            _this.unsubscribeTopic(_handle);
                        } catch(ex) {
                            util.log('video.lib: error occurred while trying to call unsubscribeTopic with handle: ', _handle, ' ', ex);
                        }
                    });
                }
            }, 0);
            return true;
        };
    
        VideoItem.prototype.unsubscribeTopic = function(handle) {
            var topic = this._topics[handle.topic];
            if(topic) {
                var idx = topic.findIndex(function(i) { return i.handle.id === handle.id; });
                if(idx > -1) {
                    topic.splice(idx, 1);
                }
            }
        };
    
        /*
         * Gather the necessary data and make the call to fire the metrics from the BC Plugin.
         */
        VideoItem.prototype.segmentUpdate = function(id) {
            if (!id) {
                return;
            }
            var vidData = Object.assign({}, this._mtxBcpVidSegments[id] || {}, this.getMtxVideoData() || {});
            //Common Metrics
            this.fireMetricAction(id, {
                video: vidData
            });
        };
    
        /*
         * Return an object with the necessary data about the current video for the metrics.
         */
        VideoItem.prototype.getMtxVideoData = function() {
            return {
                segmentTime: this.getCurrentTime(),
                videoName: util.str.stripMarkup((this.config && (this.config.mtxVideoName || this.config.videoTitle)) || '')
            };
        };
    
        /*
         * Try to get the current time of the video
         */
        VideoItem.prototype.getCurrentTime = function() {
            var currTime = 0;
            if (this.config.playerApi) {
                try {
                    currTime = this.config.playerApi.getCurrentTime();
                } catch(e) {
                    util.log("videoItem::getCurrentTime - issue retrieving the segmentTime");
                }
            }
            return currTime;
        };
    
        /*
         * Fire the metricsAction with the included data if defined.
         */
        VideoItem.prototype.fireMetricAction = function(actionId, data) {
            var actions = this.actions || {};
            if(!data) {
                data = {};
            }
            if(actions && actions[actionId]) {
                FD.Brand.Metrics.handler.direct(actions[actionId], data);
            }
        };
    } else {
        var initialized = false;
        var _settings = ctx && ctx.settings;
        var _globalBcpConfig = {
            'brightcoveAccountId': _settings && _settings.videoAccount,
            'brightcovePlayerId': _settings && _settings.videoPlayerKey,
            'isYoutube': false,
            'defaultFilmstripExpanded': false
        };
        var _bcpInstances = null;
        var _bcpState = null;
        var _loadBcp = getAsyncTopic(loadBcFramework);
    
        // setup namespace
        Object.assign(brand.namespace('FD.Brand.Video', win), {
            bcp: {
                create: bcpCreatePlayer,
                resetInstance: resetBcpInstance
            },
            videoItem: {
                create: function(config) {
                    return new VideoItem(config);
                }
            }
        });
    
        //////
    
        // helper for topics retrieved asynchronously
        // wraps a common promise that is returned
        // deferred is passed into load function and resolved when topic is loaded
        // this makes the function reentrant without initiating multiple requests to load topic
        function getAsyncTopic(fnLoad) {
            var promise = null;
            var fn = function() {
                var def;
                if(promise === null) {
                    def = $.Deferred();
                    promise = def.promise();
                    fnLoad(def);
                }
                return promise;
            };
            fn.$_reset = function() {
                promise = null;
            };
            return fn;
        }
    
        function loadBcFramework(def) {
            var resolveState = function() {
                def.resolve(Object.assign({},_bcpState));
            };
            if (_bcpState) {
                resolveState();
            } else {
                _bcpState = {
                    loaded: false,
                    basePath: '/etc/designs/brand_ford/brand/vendor/brightcove/js'
                };
    
                util.url.loadAsScript(_bcpState.basePath + '/bcgs_ford_player_framework.min.js').done(function() {
                    _bcpState.loaded = true;
    
                    try {
                        FordPlayer.setPageWideConfig(_globalBcpConfig);
                    } catch(e) {
                        util.log("video.lib: There was an error setting the pageWideConfig");
                    }
    
                    resolveState();
                }).fail(function(resp) {
                    util.log('video.lib: failed to load the brightcove plugin framework', resp);
                    resolveState();
                });
            }
        }
    
        /*
         * Simple API to standardize some of the logic needed that may be different between the Brightcove and Youtube players.
         */
        function bcpPlayerAPIWrapper(config, framework, player) {
            var api = {};
            if(framework && player) {
                api = {
                    autoplay: function () {
                        var shouldAutoplay = (util.currentBreakpoint === 'gux-bkpt-sm') ? false : true;
                        player.autoplay(shouldAutoplay);
    
                        player.one("play", function() {
                            player.autoplay(true);
                        });
                    },
                    getCurrentTime: function () {
                        // BCP Update - Standardize logic to properly handle getting the current time from both BC and YT players.
                        var cT = 0;
                        try {
                            cT = (config && config.isYoutube) ? player.getCurrentTime() : player.currentTime();
                        } catch(e) {
                            util.log("video.lib::apiWrapper.getCurrentTime - issue retrieving currentTime from player.");
                        }
                        return cT;
                    },
                    setConfig: function (_config) {
                        config = Object.assign({}, config, _config);
                    },
                    setCurrentVideo: function (_currentVideo) {
                        config.currentVideo = _currentVideo;
                    },
                    hasFullscreen: function() {
                        // BCP Update - youtube player doesn't indicate when the fullscreen mode is entered, so we use this
                        // check to ensure the logic is only run when using a Brightcove player.
                        return !!(config && !config.isYoutube);
                    },
                    isFullscreen: function() {
                        var isFS = false;
                        try {
                            isFS = player.isFullscreen() || false;
                        } catch(e) {
                            util.log("video.lib::apiWrapper.isFullscreen - issue retrieving fullscreen value from player");
                        }
                        return isFS;
                    }
                };
            }
            return api;
        }
    
        function bcpCreatePlayer(bcpConfig, brandConfig) {
            var def = $.Deferred();
            bcpInitPlayer(bcpConfig, brandConfig).then(function(playerDetail) {
                var config = Object.assign({}, brandConfig, bcpConfig);
                if (playerDetail && playerDetail.playerApi) {
                    playerDetail.playerApi.setConfig(config);
                }
    
                var obj = Object.assign({}, config, playerDetail);
    
                if (obj && obj.bcpFramework && !obj.firstInstance) {
                    // if the player has already been created before, then we need to reinitialize it with the latest config
                    obj.bcpFramework.reInit(bcpConfig);
                }
    
                def.resolve(obj);
            }, function() {
                //Added to handle error state when player is not loaded due to privacy settings.
                def.resolve(null);
            });
            return def.promise();
        }
    
        function bcpInitPlayer(bcpConfig, brandConfig) {
            var def = $.Deferred();
            if(util.url.allowScript('6')) {
                var instId = brandConfig && brandConfig.fgxInstanceId || '';
                if (_bcpInstances && _bcpInstances[instId] && _bcpInstances[instId].initialized) {
                    _bcpInstances[instId].firstInstance = false;
                    def.resolve(_bcpInstances[instId]);
                } else {
                    _bcpInstances = _bcpInstances || {};
                    var bcVidDetail = {};
                    var _instId = instId;
                    var settings = brand.Context.settings;
                    var language = brand.Context.language;
    
                    bcVidDetail.firstInstance = true;
    
                    if (brandConfig && brandConfig.fgxSetupSlideItem) {
                        var data = {
                            typeSelector: brandConfig.slideItemClass,
                            playerWrapperId: bcpConfig.placeHolderDivId,
                            slideHeadlineId: brandConfig.slideHeadlineId
                        };
                        var $bcSlideItem = $(brandConfig.template(data));
                        
                        $bcSlideItem.addClass('active');
                        $bcSlideItem.appendTo(brandConfig.slideContainer);
                        bcVidDetail.slideItem = $bcSlideItem;
                    }
    
                    _loadBcp().done(function(state) {
                        if (state.loaded) {
                            bcVidDetail.initialized = true;
                            bcVidDetail.bcpFramework = FordPlayer.create(bcpConfig);
                            bcVidDetail.bcpFramework.on('ready', function() {
                                bcVidDetail.player = bcVidDetail.bcpFramework.getPlayer();
                                bcVidDetail.playerApi = bcpPlayerAPIWrapper(Object.assign({}, brandConfig, bcpConfig), bcVidDetail.bcpFramework, bcVidDetail.player);
                                _bcpInstances[_instId] = bcVidDetail;
                                def.resolve(_bcpInstances[_instId]);
                            });
                        } else {
                            bcVidDetail.initialized = false;
                            bcVidDetail.bcpFramework = null;
                            bcVidDetail.player = null;
                            bcVidDetail.playerApi = null;
                            _bcpInstances[_instId] = bcVidDetail;
                            def.resolve(_bcpInstances[_instId]);
                        }
                    });
                }
            } else {
                util.log('video.lib: Brightcove Player Framework library not loaded due to privacy settings');
                def.reject();
                let brightcoveComponents = ['.bri-billboard-slide-generic', '.billboard-homepage-slide'];
    
                function updateBillboardElements(container, videoSelector, imgSelector) {
                    let video = container[0].querySelectorAll(videoSelector);
                    let img = container[0].querySelectorAll(imgSelector);
                
                    video[0].style.display = 'none';
                    img[0].style.display = 'block';
                }
                
                brightcoveComponents.forEach(function(component) {
                    let brightcoveContainer = document.querySelectorAll(component);
                    if (brightcoveContainer.length === 0) return;
                    updateBillboardElements(brightcoveContainer, '.inline-video-container', 'picture');
                });
            }
            return def.promise();
        }
    
        function resetBcpInstance(id) {
            if (_bcpInstances && _bcpInstances[id]) {
                _bcpInstances[id].initialized = false;
            }
        }
    
    
        // New VideoItem Class
        function VideoItem(config) {
            this.config = Object.assign({}, config || {});
            this.settings = Object.assign({}, this.config.settings || {});
            this.actions = Object.assign({}, this.config.actions || {});
            this.id = this.config.id || '';
            this.fgxInstanceId = this.config.fgxInstanceId || this.id;
            this.slideItem = this.config.slideItem;
            this.videoContainer = this.config.videoContainer;
            this.type = this.config.type;
            this.displayType = this.config.displayType;
            this.altMobileBp = this.config.altMobileBp || false;
            this.initialized = false;
            this.playing = false;
            this.loading = false;
            this.manuallyPaused = false;
            this.skipManualPauseUpdate = false;
            this.transitionLock = false;
    
            this._bcpBaseConfig = {
                'placeHolderDivId': this.config.id,
                'isYoutube': false,
                'showFilmstripToggle': !(this.config.displayType === 'inline'),
                'defaultFilmstripExpanded': false,
                'autoPlay': false
            };
            this._brandBaseConfig = {
                'fgxInstanceId': this.config.id,
                'fgxSetupSlideItem': !(this.config.displayType === 'inline')
            };
    
            this.bcpConfig = Object.assign({}, this._bcpBaseConfig, this.config.bcpConfig || {});
            this.brandConfig = Object.assign({}, this._brandBaseConfig, this.config.brandConfig || {});
    
            this._mtxBcpVidSegments = {
                'videoStart': {
                },
                'videoSegment25': {
                    videoNamePercentageWatched: '25% complete'
                },
                'videoSegment50': {
                    videoNamePercentageWatched: '50% complete'
                },
                'videoSegment75': {
                    videoNamePercentageWatched: '75% complete'
                },
                'videoComplete': {
                    videoNamePercentageWatched: 'video complete'
                }
            };
    
            this._topics = {};
            this._nextHandleId = 0;
        }
    
        VideoItem.prototype.autoplayBPClasses = {
            'gux-bkpt-sm': 'fgx-brand-video-autoplay-mbl',
            'gux-bkpt-med': 'fgx-brand-video-autoplay-tab',
            'gux-bkpt-lg': 'fgx-brand-video-autoplay-dsk',
            'gux-bkpt-xlg': 'fgx-brand-video-autoplay-dsk'
        };
    
        VideoItem.prototype.autoplayBPClassesNoTab = {
            'gux-bkpt-sm': 'fgx-brand-video-autoplay-mbl',
            'gux-bkpt-med': 'fgx-brand-video-autoplay-mbl',
            'gux-bkpt-lg': 'fgx-brand-video-autoplay-dsk',
            'gux-bkpt-xlg': 'fgx-brand-video-autoplay-dsk'
        };
    
        VideoItem.prototype.create = function(bcpConfig, brandConfig) {
            var def = $.Deferred();
            if (this.initialized) {
                def.resolve(this);
            } else {
                this.bcpConfig = Object.assign({}, this.bcpConfig || {}, bcpConfig || {});
                this.brandConfig = Object.assign({}, this.brandConfig || {}, brandConfig || {});
                var _this = this;
    
                brand.Video.bcp.create(this.bcpConfig, this.brandConfig).then(function(vConfig) {
                    if(vConfig && vConfig.initialized) {
                        _this.config = Object.assign({}, _this.config || {}, vConfig);
                        _this.initialized = true;
                        _this.config.bcScriptLoaded = true;
    
                        // NZ: Only set the 'muted' property based on autoplay status here if the 'muted' property isn't
                        // specifically set within the settings object that's passed in, or if its set to null.
                        if (_this.settings && (_this.settings.muted === null || typeof(_this.settings.muted) == 'undefined')) {
                            _this.settings.muted = _this.autoplayEnabledOnBP();
                        }
    
                        _this.setSettingsOnPlayer();
    
                        if (_this.config.bcpFramework) {
                            _this.config.bcpFramework.on('play', function() {
                                _this.playing = true;
                                _this.setManuallyPaused(false);
                                _this.publishTopic('play', {
                                    topic: 'play',
                                    inst: _this
                                });
                            });
                            _this.config.bcpFramework.on('pause', function() {
                                _this.playing = false;
                                _this.setManuallyPaused(true);
                                _this.publishTopic('pause', {
                                    topic: 'pause',
                                    inst: _this
                                });
                            });
                            _this.config.bcpFramework.on('ended', function() {
                                _this.playing = false;
                                _this.setManuallyPaused(true, true);
                                _this.publishTopic('ended', {
                                    topic: 'ended',
                                    inst: _this
                                });
                            });
                            _this.config.bcpFramework.on('loaded', function() {
                                _this.publishTopic('loaded', {
                                    topic: 'loaded',
                                    inst: _this
                                });
                                // Trigger an event when an inline video is loaded. Currently used to recalculate values in animation logic
                                $(document).trigger('brandinlinevid:loaded', [{
                                    topic: 'loaded',
                                    inst: _this
                                }]);
                            });
                            _this.config.bcpFramework.on('videoStart', function(data) {
                                _this.segmentUpdate('videoStart');
                            });
                            _this.config.bcpFramework.on('first-quartile', function(data) {
                                _this.segmentUpdate('videoSegment25');
                            });
                            _this.config.bcpFramework.on('second-quartile', function(data) {
                                _this.segmentUpdate('videoSegment50');
                            });
                            _this.config.bcpFramework.on('third-quartile', function(data) {
                                _this.segmentUpdate('videoSegment75');
                            });
                            _this.config.bcpFramework.on('fourth-quartile', function(data) {
                                _this.segmentUpdate('videoComplete');
                            });
    
                            if (_this.config.playerApi && _this.config.playerApi.hasFullscreen() && _this.config.player) {
                                _this.config.player.on("fullscreenchange", function() {
                                    if(_this.config.playerApi) {
                                        var isFS = _this.config.playerApi.isFullscreen();
                                        if(isFS) {
                                            _this.fireMetricAction('videoExpand');
                                        }
                                    }
                                });
                            }
                        }
    
                        def.resolve(_this);
                    } else {
                        _this.config = Object.assign({}, _this.brandConfig);
                        _this.config.bcScriptLoaded = false;
                        def.resolve(_this);
                    }
                });
            }
    
            return def.promise();
        };
    
        VideoItem.prototype.loadInViewport = function() {
            var def = $.Deferred();
            if (this.initialized) {
                def.resolve(this);
            } else {
                var $container = $(this.videoContainer);
                //if (!this.loading && brand.Util.inViewport($container) && $container.css('display') != 'none' && $container.css('visibility') != 'hidden') {
                if (!this.loading && this.isVisible()) {
                    this.loading = true;
                    this.create().done(function(inst) {
                        this.loading = false;
                        if (inst && inst.initialized) {
                            $container.attr('data-fgx-inline-video-initialized', 'true');
                        }
                        def.resolve(inst);
                    });
                } else {
                    def.resolve(this);
                }
            }
            return def.promise();
        };
    
        VideoItem.prototype.loadInitialStateForBP = function() {
            this.loadInViewport().done(function(inst) {
                if (inst && inst.initialized && inst.autoplayEnabledOnBP() && inst.isVisible()) {
                    inst.play(true);
                }
            });
        };
    
        VideoItem.prototype.getFramework = function() {
            return (this.config && this.config.bcpFramework) ? this.config.bcpFramework : null;
        };
    
        VideoItem.prototype.setSettingsOnPlayer = function(_settings) {
            var _this = this;
            if (_this.config.player) {
                var settings = !brand.Util.isEmpty(_settings) ? _settings : (_this.settings || {})
                Object.keys(settings).forEach(function(key) {
                    var val = settings[key];
                    if (val !== null && typeof(val) !== 'undefined') {
                        try {
                            _this.config.player[key](val);
                        } catch(e) {
                            util.log("VideoItem::setSettingsOnPlayer - error occurred setting the method on the player. {method}:{val} - ", key, ' : ', val, ' ', e);
                        }
                    }
                });
            }
        };
    
        VideoItem.prototype.play = function(skipMPUpdate) {
            var framework = this.getFramework();
            if (framework) {
                try {
                    if (this.transitionLock || this.playing) {
                        return;
                    }
                    if (skipMPUpdate) {
                        this.skipManualPauseUpdate = true;
                    }
                    framework.play();
                } catch(e) {
                    brand.Util.log('VideoItem::play - error when trying to play the current video. ', e);
                    this.skipManualPauseUpdate = false;
                }
            }
        };
    
        VideoItem.prototype.pause = function(skipMPUpdate) {
            var framework = this.getFramework();
            if (framework) {
                try {
                    if (!this.playing) {
                        return;
                    }
                    if (skipMPUpdate) {
                        this.skipManualPauseUpdate = true;
                    }
                    framework.pause();
                } catch(e) {
                    brand.Util.log('VideoItem::pause - error when trying to pause the current video. ', e);
                    this.skipManualPauseUpdate = false;
                }
            }
        };
    
        VideoItem.prototype.getAutoplayClassForBP = function() {
            let bp = brand.Util.currentBreakpoint(),
                classMap = (this.altMobileBp) ? this.autoplayBPClassesNoTab : this.autoplayBPClasses;
            return classMap && classMap[bp] || 'fgx-brand-video-autoplay-dsk';
        };
    
        VideoItem.prototype.autoplayEnabledOnBP = function() {
            var $container = $(this.videoContainer);
            return ($container.hasClass(this.getAutoplayClassForBP()));
        };
    
        VideoItem.prototype.displayOnBP = function() {
            var bp = brand.Util.currentBreakpoint();
            return !((bp == 'gux-bkpt-sm' || (bp == 'gux-bkpt-med' && this.altMobileBp)) && this.hiddenOnMobile());
        };
    
        VideoItem.prototype.isVisible = function() {
            var $container = $(this.videoContainer);
            var visible = false;
            if (brand.Util.inViewport($container) && $container.is(':visible')) {
                visible = true;
            }
            return visible;
        };
    
        VideoItem.prototype.setTransitionLock = function(_isTransitioning) {
            this.transitionLock = _isTransitioning;
        };
    
        VideoItem.prototype.isTransitioning = function() {
            return this.transitionLock;
        };
    
        VideoItem.prototype.hiddenOnMobile = function() {
            return ($(this.videoContainer).hasClass('.hide-video-on-mobile'));
        };
    
        VideoItem.prototype.shownOnMobile = function() {
            return !(this.hiddenOnMobile());
        };
    
        VideoItem.prototype.isPlaying = function() {
            return this.playing;
        };
    
        VideoItem.prototype.isManuallyPaused = function() {
            return this.manuallyPaused;
        };
    
        VideoItem.prototype.setManuallyPaused = function(_paused, forceUpdate) {
            if (!this.skipManualPauseUpdate || forceUpdate) {
                this.manuallyPaused = _paused;
            }
            this.skipManualPauseUpdate = false;// reset skip manual pause update
        };
    
        // Subscribe/publish topic slightly modified from original implementation in user.lib.js
        VideoItem.prototype.subscribeTopic = function(topic, callback, _once) {
            if(!this._topics[topic]) {
                this._topics[topic] = []
            }
            var handle = {
                topic: topic,
                id: ++this._nextHandleId,
                once: _once || false
            };
            this._topics[topic].push({
                handle: handle,
                callback: callback
            });
            return handle;
        };
    
        VideoItem.prototype.publishTopic = function(topic, data, callback) {
            if(!this._topics[topic]) {
                return false;
            }
            var _this = this,
                _unsubscribeList = [];
            setTimeout(function notifyTopic() {
                (callback ? [{ callback: callback }] : _this._topics[topic]).forEach(function(subscriber) {
                    try {
                        subscriber.callback(data, topic);
    
                        var _handle = subscriber && subscriber.handle;
                        if (_handle && _handle.once) {
                            _unsubscribeList.push(_handle);
                        }
                    } catch(ex) {
                        util.log('video.lib: error occurred publishing videoItem topic ' + topic, data, ex);
                    }
                });
                if (_unsubscribeList.length > 0) {
                    _unsubscribeList.forEach(function(_handle) {
                        try {
                            _this.unsubscribeTopic(_handle);
                        } catch(ex) {
                            util.log('video.lib: error occurred while trying to call unsubscribeTopic with handle: ', _handle, ' ', ex);
                        }
                    });
                }
            }, 0);
            return true;
        };
    
        VideoItem.prototype.unsubscribeTopic = function(handle) {
            var topic = this._topics[handle.topic];
            if(topic) {
                var idx = topic.findIndex(function(i) { return i.handle.id === handle.id; });
                if(idx > -1) {
                    topic.splice(idx, 1);
                }
            }
        };
    
        /*
         * Gather the necessary data and make the call to fire the metrics from the BC Plugin.
         */
        VideoItem.prototype.segmentUpdate = function(id) {
            if (!id) {
                return;
            }
            var vidData = Object.assign({}, this._mtxBcpVidSegments[id] || {}, this.getMtxVideoData() || {});
            //Common Metrics
            this.fireMetricAction(id, {
                video: vidData
            });
        };
    
        /*
         * Return an object with the necessary data about the current video for the metrics.
         */
        VideoItem.prototype.getMtxVideoData = function() {
            return {
                segmentTime: this.getCurrentTime(),
                videoName: util.str.stripMarkup((this.config && (this.config.mtxVideoName || this.config.videoTitle)) || '')
            };
        };
    
        /*
         * Try to get the current time of the video
         */
        VideoItem.prototype.getCurrentTime = function() {
            var currTime = 0;
            if (this.config.playerApi) {
                try {
                    currTime = this.config.playerApi.getCurrentTime();
                } catch(e) {
                    util.log("videoItem::getCurrentTime - issue retrieving the segmentTime");
                }
            }
            return currTime;
        };
    
        /*
         * Fire the metricsAction with the included data if defined.
         */
        VideoItem.prototype.fireMetricAction = function(actionId, data) {
            var actions = this.actions || {};
            if(!data) {
                data = {};
            }
            if(actions && actions[actionId]) {
                FD.Brand.Metrics.handler.direct(actions[actionId], data);
            }
        };
    }

})(window, jQuery, FD.Brand, FD.Brand.Util, FD.Brand.Context);
/*global FD*/
(function(win, $, brand, ngp, ctx) {

    // search library
    Object.assign(brand.namespace('FD.Brand.Search', win), {
        typeAheadResults: getSearchTypeaheadResults,
        setReferrerApp: setReferrerApp,
        astuteTypeAheadResults: getAstuteTypeAheadResults,
        initAstuteSession: getAsyncTopic(initAstuteSession),
        highlightText: highlightText
    });

    var defaults = {
        maxResultCount: 10
    };
    var settings = ctx && ctx.settings || {};
    var _asKey = "astuteServiceUrl";
    //NZ - per BRAND-13492 - market should always be en-US regardless of corner. This was originally setup as ctx.language + "-" + ctx.region
    var _astuteSettings = {
        market: "en-US",
        serviceUrl: (settings && (settings[_asKey + ctx.make] || settings[_asKey])) || "//use-fordservicelayer.astuteknowledge.com/AskFordWeb",
        sessionID: null
    };
    var _initAstuteSession = FD.Brand.Search.initAstuteSession;

    function getSearchTypeaheadResults(val, $container, $searchInput, $resultsAlert, maxCount) {
        var results = [],
            maxResultCount = maxCount || defaults.maxResultCount;

        ngp.searchTypeAhead({
            q: val,
            type: 'suggest'
        }).done(function(locations) {
            if(locations != null && (Array.isArray(locations) && locations.length > 0)) {
                handleTypeaheadResponse(locations, $container, $searchInput, $resultsAlert, maxResultCount);
            } else {
                $container.find(".search-res-item.search-suggestion-item").remove();
                $container.parent().hide();
            }
        }).fail(function(resp) {
            $container.find(".search-res-item.search-suggestion-item").remove();
            $container.parent().hide();
        });
    }

    function handleTypeaheadResponse(resp, $container, $searchInput, $resultsAlert, maxResultCount) {
        var results = resp.map(function(result) {
            return result;
        });

        if( maxResultCount !== -1) {
            results = results.slice(0, maxResultCount);
        }

        if(results !== null) {
            $container.find(".search-res-item.search-suggestion-item").remove(); //Should unbind all event handlers on the search items as well.
            processTypeAheadResponse(results, "fgx-brand-searchTypeAheadItem", $container, $searchInput, $resultsAlert);
        } else {
            $container.parent().hide();
            if (typeof $resultsAlert !== 'undefined') {
                $resultsAlert.text('');
            }
        }
    }

    function highlightText(text, $searchInput) {
        const regex = new RegExp(`(${$searchInput?.val()?.toLowerCase()})`, 'i')
        const highlightedText = text?.toLowerCase()?.replace(regex, '<strong>$1</strong>');
        
        return highlightedText
    }

    function processTypeAheadResponse(resp, itemId, $container, $searchInput, $resultsAlert) {
        var index = 0,
            idPrefix = itemId || "fgx-brand-searchTypeAheadItem";
        const AMOUNT_TO_SHOW = 5;
        for(var res in resp?.slice(0, AMOUNT_TO_SHOW)) {
            var id = idPrefix + index;
            var resultStr = highlightText(resp[res], $searchInput)
            // on the author environment, for some reason the final result is always a JS function...make sure we don't display that.
            if (typeof(resultStr) != 'function') {
                const listItem = `
                    <li id='${id}'
                     class='search-res-item search-suggestion-item'
                     tabindex='-1'
                     aria-selected='false' 
                     role='option' 
                     data-fgx-keypress='true'>
                        <div style="display: flex; align-items: center;" class="search-res-item">
                            <span class="search-icon"></span>
                            <span>${resultStr}</span>
                        </div>
                    </li>
                `
                $container.append(listItem);
            }
            index ++;
        }
        if ($searchInput.val().length && resp.length) {
            $container.parent().show();
            $searchInput.toggleClass('fgx-list-shown', true);//BRAND-12331
        }

        if (typeof $resultsAlert !== 'undefined') {
            var templateTxt = $resultsAlert.data('label-template');
            if (templateTxt) {
                $resultsAlert.text(templateTxt.replace('{count}', resp.length));
            }
        }

        // The mousedown event handler is needed to stop the blur event from firing when clicking on a search result.
        $container.find(".search-res-item").on('mousedown', function(ev) {
            ev.preventDefault();
        }).on('focusin', function(){
            $container.find(".search-res-item").attr('aria-selected', 'false');
            $(this).attr('aria-selected', 'true');
            $searchInput.attr('aria-activedescendant', $(this).attr('id'));
        }).on('keydown', function(ev){
            if (ev.shiftKey && ev.which === 9) {
              //shift was down when tab was pressed...so refocus on the search input
              $searchInput.focus();
              return false;
            } else if (ev.which === 27) {
                //escape key was pressed...so refocus on the search input
                $searchInput.focus();
                $container.parent().hide();
                if (typeof($resultsAlert) !== 'undefined') {
                    $resultsAlert.text('');
                }
                $searchInput.toggleClass('fgx-list-shown', false);//BRAND-12331
                $searchInput.removeAttr('aria-activedescendant');
                return false;
            }
        });
    }
    
    // duplicated from our user JS library
    // helper for topics retrieved asynchronously
    // wraps a common promise that is returned
    // deferred is passed into load function and resolved when topic is loaded
    // this makes the function reentrant without initiating multiple requests to load topic
    function getAsyncTopic(fnLoad) {
        var promise = null;
        var fn = function() {
            var def;
            if(promise === null) {
                def = $.Deferred();
                promise = def.promise();
                fnLoad(def);
            }
            return promise;
        };
        fn.$_reset = function() {
            promise = null;
        };
        return fn;
    }

    function initAstuteSession(def) {
        if(_astuteSettings && _astuteSettings.sessionID) {
            def.resolve(_astuteSettings);
        } else {
            var prm = {
                url: _astuteSettings.serviceUrl + "/init",
                contentType: 'application/json',
                processData: false,
                data: JSON.stringify({ market: _astuteSettings.market }),
                type: "POST"
            }

            $.ajax(prm).done(function(resp) {
                if(resp) {
                    if(resp.sessionID) {
                        _astuteSettings.sessionID = resp.sessionID;
                        def.resolve(_astuteSettings);
                    } else {
                        def.reject();
                    }
                } else {
                    def.reject();
                }
            }).fail(function() {
                def.reject();
            });
        }
    }

    function astuteAutoComplete(data) {
        var def = $.Deferred(),
            prm = {
                url: _astuteSettings.serviceUrl + "/autocomplete",
                contentType: 'application/json',
                processData: false,
                data: JSON.stringify(Object.assign({}, data)),
                type: "POST"
            };

        $.ajax(prm).done(function(resp) {
            if(resp && resp.suggestions) {
                def.resolve(resp.suggestions);
            } else {
                def.reject();
            }
        }).fail(function() {
            def.reject();
        });

        return def.promise();
    }

    function getAstuteTypeAheadResults(val, $container, $searchInput, $resultsAlert, maxCount) {
        var maxResultCount = maxCount || defaults.maxResultCount;

        _initAstuteSession().done(function(resp) {
            astuteAutoComplete({
                sessionID: _astuteSettings.sessionID,
                utterance: val.replace('+', '%20'),
                suggestionCount: maxResultCount
            }).done(function(resp) {
                handleAstuteTypeaheadResponse(resp, $container, $searchInput, $resultsAlert, maxResultCount);
            }).fail(function() {
                $container.parent().hide();
            });
        }).fail(function() {
            $container.parent().hide();
        });
    }

    function handleAstuteTypeaheadResponse(resp, $container, $searchInput, $resultsAlert, maxResultCount) {
        if(resp) {
            if(!Array.isArray(resp)) {
                resp = [resp];
            }
            $container.find(".search-res-item.search-suggestion-item").remove(); //Should unbind all event handlers on the search items as well.

            if(brand.Util.isEmpty(resp)) {
                $container.parent().hide();
                if (typeof $resultsAlert !== 'undefined') {
                    $resultsAlert.text('');
                }
                return;
            }

            processTypeAheadResponse(resp, "fgx-brand-astuteSearchTypeAheadItem", $container, $searchInput, $resultsAlert);

        } else {
            $container.parent().hide();
            if (typeof $resultsAlert !== 'undefined') {
                $resultsAlert.text('');
            }
        }
    }

    function setReferrerApp($formWrapper) {
        if(ctx.settings.syn && ctx.metrics && ctx.metrics.pageName && ctx.metrics.pageName.indexOf('owner') >= 0) {
            var formWrapper = $formWrapper[0];
            var referrerApp = document.createElement('input');
            referrerApp.type = "hidden";
            referrerApp.name = "referrerApp";
            referrerApp.value = "owner";
            formWrapper.appendChild(referrerApp);
        }
    }

})(window, jQuery, FD.Brand, FD.Brand.NgpServices, FD.Brand.Context);
/*global FD*/
/**
 * GOLF form support library
 */
(function(win, $, brand, ctx, user, util) {
    const isFord = ctx?.make === 'Ford'

    var FORM_PARAMETER_DEFAULTS = {
        getupdates: {
            'Ford': {
                listid: '310124',
                qacodeEmail: '0799A',
                qacodeMail: '0848312720'
            },
            'Lincoln': {
                listid: '320864',
                qacodeEmail: '0799A',
                qacodeMail: '0848320876'

            }
        },
        guShop: {
            'Ford': {
                qacodeMail: '0848312726'
            }
        },
        guReveal: {
            'Ford': {
                qacodeMail: '0848501137'
            }
        },
        guRevealShop: {
            'Ford': {
                qacodeMail: '0848501149'
            }
        },
        guRevealCTA: {
            'Ford': {
                qacodeMail: '0848501172'
            }
        },
        guBillboard: {
            'Lincoln': {
                qacodeMail: '0848500673'
            }
        },
        blgetupdates: {
            'Lincoln': {
                qacodeMail: '0848321168'
            }
        },
        guComm: {
            'Ford': {
                qacodeMail: '0848501420'
            }
        },
        canvasgu: {
            'Ford': {
                listid: '320864',
                qacodeEmail: '0799A',
                brochureCode: '222'
            },
            'Lincoln': {
                listid: '320864',
                qacodeEmail: '0799A',
                brochureCode: '222'
            }
        },
        personaldriver: {
            'Ford': {
                listid: '320864',
                qacodeEmail: '0799A',
                brochureCode: '223'
            },
            'Lincoln': {
                listid: '320864',
                qacodeEmail: '0799A',
                brochureCode: '223'
            }
        },
        kmi: {
            'Ford': {
                listid: '312726',
                qacodeEmail: '0799A',
                brochureCode: '222'
            },
            'Lincoln': {
                listid: '320879',
                qacodeEmail: '0799A',
                brochureCode: '222'

            }
        },
        promo: {
            'Ford': {
                listid: '310124',
                qacodeEmail: '0799A',
                qacodeMail: '0848501946',
                brochureCode: '274'
            }
        },
        lpa: {
            'Lincoln': {
                listid: '320879',
                qacodeEmail: '0799A',
                brochureCode: '222'
            }
        },
        schedulemodele: {
            'Ford': {
                listid: '320801',
                qacodeEmail: '0799A',
                qacodeMail: '0848312720'
            },
            'Lincoln': {
                listid: '320802',
                qacodeEmail: '0799A',
                qacodeMail: '0848320876'

            }
        }
    };
    var SCHEDULE_EVENT_DATA = {
        schedulemodele: {
            'FormShown': {
                'registeredEvent': true,
                'mtxKey': 'scheduleTestDriveModeleShowFormAction'
            },
            'RequestView': {
                'registeredEvent': false,
                'mtxKey': ''
            },
            'ResponseView': {
                'registeredEvent': true,
                'mtxKey': 'scheduleTestDriveModeleResponseViewAction'
            },
            'SelectVehicleView': {
                'registeredEvent': true,
                'mtxKey': 'scheduleTestDriveSelectVehicleViewAction'
            }
        },
        schedule: {
            'FormShown': {
                'registeredEvent': true,
                'mtxKey': 'scheduleTestDriveShowFormAction'
            },
            'RequestView': {
                'registeredEvent': false,
                'mtxKey': ''
            },
            'ResponseView': {
                'registeredEvent': true,
                'mtxKey': 'scheduleTestDriveResponseViewAction'
            },
            'SelectVehicleView': {
                'registeredEvent': true,
                'mtxKey': 'scheduleTestDriveSelectVehicleViewAction'
            }
        },
        fleetschedule: {
            'FormShown': {
                'registeredEvent': false,
                'mtxKey': ''
            },
            'RequestView': {
                'registeredEvent': true,
                'mtxKey': 'fleetScheduleTestDriveRequestViewAction'
            },
            'ResponseView': {
                'registeredEvent': true,
                'mtxKey': 'fleetScheduleTestDriveResponseViewAction'
            },
            'SelectVehicleView': {
                'registeredEvent': true,
                'mtxKey': 'fleetScheduleTestDriveSelectVehicleViewAction'
            }
        }
    };

    Object.assign(brand.namespace('FD.Brand.Form', win), {
        request: formFactory('request', {skinVersion: "guxv2"}),
        ediRequest: formFactory('request', {skinVersion: 'edi', id: 'ediRequest'}),
        schedule: formFactory('schedule'),
        blschedule: formFactory('schedule', {skinVersion: "lincolnblv1", blackLabelOnly: true}),
        schedulev2: formFactory('schedule', {skinVersion: "guxv2", id: 'schedulev2'}),
        schedulemodele: formFactory('schedulemodele', {skinVersion: "guxv2", id: 'schedulemodele'}),
        fleetschedule: formFactory('schedule', {skinVersion: "fleet", id: 'fleetschedule'}),
        getupdates: formFactory('getupdates', {...(isFord ? {skinVersion: 'guxv2'} : {})}),
        guShop: formFactory('getupdates', Object.assign({id: 'guShop'}, getFormParameterDefaults('getupdates'), formParameters('guShop'))),
        guReveal: formFactory('getupdates', Object.assign({id: 'guReveal'}, getFormParameterDefaults('getupdates'), formParameters('guReveal'))),
        guRevealShop: formFactory('getupdates', Object.assign({id: 'guRevealShop'}, getFormParameterDefaults('getupdates'), formParameters('guRevealShop'))),
        guRevealCTA: formFactory('getupdates', Object.assign({id: 'guRevealCTA'}, getFormParameterDefaults('getupdates'), formParameters('guRevealCTA'))),
        guBillboard: formFactory('getupdates', Object.assign({id: 'guBillboard'}, getFormParameterDefaults('getupdates'), formParameters('guBillboard'))),
        blgetupdates: formFactory('getupdates', Object.assign({id: 'blgetupdates'}, getFormParameterDefaults('getupdates'), formParameters('blgetupdates'))),
        guComm: formFactory('getupdates', Object.assign({skinVersion: 'commform', id: 'guComm'}, getFormParameterDefaults('getupdates'), formParameters('guComm'))),
        canvasgu: formFactory('getupdates', Object.assign({skinVersion: 'canvasv1', id: 'canvasgu'}, formParameters('canvasgu'))),
        personaldriver: formFactory('getupdates', Object.assign({skinVersion: 'personaldriverv1', id: 'personaldriver'}, formParameters('personaldriver'))),
        kmi: formFactory('getupdates', Object.assign({skinVersion: 'kmi', id: 'kmi'}, formParameters('kmi'))),
        promo: formFactory('promo', {skinVersion: "fordRafflev2", id: 'promo'}),
        lpa: formFactory('request',  Object.assign({id: 'lpa', skinVersion: "guxv2", leadSource: 'Lincoln Personal Assistant', formTitle: 'Lincoln Personal Assistant'}, formParameters('lpa'))),
        imageshare: formFactory('emailshare', {skinVersion: "imageshare", id: "emailImageShare"}),
        videoshare: formFactory('emailshare', {skinVersion: "videoshare", id: "emailVideoShare"}),
        compare: formFactory('compare', {skinVersion: "guxv2", id: 'modelCompare'}),
        registerEventCallback: registerEventCallback,
        unregisterEventCallback: unregisterEventCallback,
        formEventCallback: formEventCallback,
        load: loadForm
    });

    var _loadedFiles = {};
    var _eventCallbacks = [];

    //////

    function formFactory(formType, prm, methods) {
        let golfForm = null;
        let golfLoading = false;
        //NGBS3-10469 - use the id value if passed in to distinguish between canvas get updates form (canvasgu) and normal get updates form (getupdates).
        const formId = prm?.id ?? formType;

        const loadFormAsync = async () => {
            try {
                await loadForm(formType, prm);
                const golfBase = win.FD.Pantry.Golf;
                await golfBase.initialized();
                golfBase.refresh();
                return golfBase.getForm(formId);
            } catch (error) {
                console.error('Error loading form:', error);
                throw error; // Re-throw the error to be handled by the caller
            }
        };

        const showFormWrapper = async (cfg, formCallback, eventCallback, title, targetElement) => {
            if (golfLoading) return;

            try {
                golfLoading = true;

                if (!golfForm) {
                    golfForm = await loadFormAsync();
                }

                showForm(golfForm, cfg, formCallback, formEventCallback(golfForm, formType, eventCallback), title, targetElement);
            } catch (error) {
                console.error('Error showing form:', error);
            } finally {
                golfLoading = false;
            }
        };

        return Object.assign({
            show: showFormWrapper
        }, methods || {});
    }

    /**
     * Register a callback function to receive events from all GOLF forms
     * Function called with the following parameters:
     *  - Form type
     *  - Event name
     *  - Current form configuration
     * @param fnCallback
     */
    function registerEventCallback(fnCallback) {
        if(fnCallback && typeof fnCallback === 'function') {
            _eventCallbacks.push(fnCallback);
        }
    }

    function unregisterEventCallback(fnCallback) {
        var idx = _eventCallbacks.indexOf(fnCallback);
        if(idx > -1) {
            _eventCallbacks.splice(idx, 1);
        }
    }

    function formEventCallback(form, formType, fnCallback) {
        return function() {
            var args = [].slice.call(arguments);
            for(var i = -1; i < _eventCallbacks.length; i++) {
                var fn = (i < 0) ? fnCallback : _eventCallbacks[i];
                if(i == 0) {
                    args.unshift(formType);
                }
                if(fn) {
                    try {
                        fn.apply(form, args);
                    } catch (e) {
                    }
                }
            }
        }
    }

    function loadForm(formType, prm, container) {
        var def = $.Deferred();
        var path = '/aemservices/common/api/component';
        var formContainerWrap = (container) ? container : 'body';

        if(ctx.region === 'CA') {
            // BRAND-15571 - need to use Shop Base Url and prepend /cmslibs path for CA
            path = (ctx.settings['shopUrl' + ctx.make + ctx.languageKey] || ctx.settings['shopUrl' + ctx.make]) + util.url.prepend(path, '/cmslibs');
            if (ctx.settings.syn === '1') {
                path = path + '.ext';
            }
        } else {
            // bit of goofiness to handle the /cmslibs rewrites on the FNA stack
            if (ctx.settings.syn === '1') {
                if (ctx.settings.env !== 'local') {
                    path = util.url.prepend(path, '/cmslibs');
                    path = (ctx.settings['shopUrl' + ctx.make + ctx.languageKey] || ctx.settings['shopUrl' + ctx.make]) + path + '.ext';
                }
            }
        }
        $.get(path + '.html/golf-' + formType, Object.assign({
            id: formType,
            formType: formType,
            presentation: 'overlay',
            make: ctx.make,
            region: ctx.region.toLowerCase()
        }, formParameters(formType), prm)).done(function(resp) {
            if(resp) {
                var $form = $(resp);
                var $files = $form.find('script,link[rel="stylesheet"]');
                var files = [];
                var loadNextFile = function() {
                    if(files.length === 0) {
                        util.log('golf.lib: files loaded ' + formType);
                        win.setTimeout(function() {
                            def.resolve($form);
                        }, 0);
                        return;
                    }
                    var file = files.shift();
                    var url = file.url;
                    if(_loadedFiles[url]) {
                        loadNextFile();
                    } else {
                        if(file.script) {
                            util.url.loadAsScript(url).then(loadNextFile, function() {
                                util.log('golf.lib: failed to load script ' + file.url);
                                def.reject();
                            });
                        } else {
                            util.url.loadAsStyle(url);
                            loadNextFile();
                        }
                        _loadedFiles[url] = 1;
                    }
                };
                $.each($files, function(i, file) {
                    var $file = $(file);
                    if($file[0].tagName === 'SCRIPT') {
                        var src = $file.attr('src');
                        if(src) {
                            files.push({
                                script: 1,
                                url: src
                            });
                        } else {
                            $.globalEval($file.text())
                        }
                    } else {
                        files.push({
                            script: 0,
                            url: $file.attr('href')
                        });
                    }
                });
                $files.remove();
                $form.appendTo(formContainerWrap);
                util.log('golf.lib: form loaded ' + formType);
                loadNextFile();
            }
        });
        return def.promise();
    }

    function showForm(golfForm, cfg, formCallback, eventCallback, title, targetElement) {
        var _location = user.location.current();
        var config = Object.assign({
            formTitle: title,
            model: ctx.nameplate && ctx.nameplate.ngpModelName,
            year: ctx.nameplate && ctx.nameplate.ngpYear,
            postalCode: _location.postalCode
        }, cfg);

        // BRAND-17295 - don't pass the postalCode to the get updates form on Ford CA if it doesn't come from either the FPI cookie or user input.
        if (ctx.make === 'Ford' && ctx.region === 'CA' && golfForm && golfForm.formType === 'getupdates') {
            if (config.postalCode && (_location.postalCodeSource === 'Akamai' || _location.postalCodeSource === 'Default')) {
                delete config.postalCode;
            }
        }
        golfForm.show(formCallback, config, eventCallback, targetElement);
    }

    function formParameters(formType) {
        return Object.assign({},
            (FORM_PARAMETER_DEFAULTS[formType] || {})[ctx.make],
            ctx.forms && ctx.forms[formType]);
    }

    /**
     * Will just return the defaults (if specified) for the formType without checking for the existence of authored values.
     */
    function getFormParameterDefaults(formType) {
        return Object.assign({}, (FORM_PARAMETER_DEFAULTS[formType] || {})[ctx.make] || {});
    }

    // new metrics for form events
    try {
        FD.Brand.Form.registerEventCallback(handleGolfMetrics);
    }
    catch(err) {
        console.log("Error occurred in the form registration handling method");
    }

    function fireGUSubmissionSuccessAction(data) {
        var formId = data && data.formId || '';
        var mtxAction = '';
        var mtxData = {};
        switch(formId) {
            case 'promo':
                mtxAction = 'getUpdatesRaffleSubmissionSuccessAction';
                break;
            case 'lpa':
                mtxAction = 'getLpaSubmissionSuccessAction';
                break;
            case 'canvasgu':
                mtxAction = 'canvasGUSubmissionSuccessAction';
                break;
            case 'personaldriver':
                mtxAction = 'personalDriverSubmissionSuccessAction';
                break;
            case 'getUpdatesBrochures':
                //The metrics for the get brochures form are handled separately in that component, so don't set an mtxAction for it here.
                break;
            case 'kmi':
                mtxAction = 'kmiSubmissionSuccessAction';
                break;
            case 'guComm':
                var req = data && data.request,
                    resp = data && data.response;
                if(resp) {
                    var commMtx = resp.commFormMtx || {},
                        contactPref = commMtx && commMtx.contactPref;

                    if (contactPref === 'email') {
                        mtxAction = 'getUpdatesCommSubmissionSuccessEmailOptinAction';
                    } else if (contactPref === 'phone') {
                        mtxAction = 'getUpdatesCommSubmissionSuccessPhoneOptinAction';
                    } else {
                        mtxAction = 'getUpdatesCommSubmissionSuccessNeitherOptinAction';
                    }

                    mtxData['$$getUpdatesTitleType'] = commMtx && commMtx.title || '';
                    mtxData['$$getUpdatesIndustryType'] = commMtx && commMtx.industry || '';
                }
                if (req) {
                    var nameplate = util.str.firstInstance(req.mtxName, ';'),
                        year = util.str.firstInstance(req.year, ';');
                    mtxData['$$getUpdatesNameplate'] = nameplate;
                    mtxData['$$getUpdatesYear'] = year;
                }
                break;
            default:
                var req = data && data.request;
                if(req) {
                    var isEmail = req.email,
                        isMail = req.mail,
                        nameplate = util.str.firstInstance(req.mtxName, ';'),
                        year = util.str.firstInstance(req.year, ';');

                    if(typeof(isEmail) == 'undefined' || !isEmail) {
                        isEmail = 0;
                    }
                    if(typeof(isMail) == 'undefined' || !isMail) {
                        isMail = 0;
                    }

                    if(ctx.region === 'CA' || (isEmail == 1 && isMail == 0)) {
                        mtxAction = 'getUpdatesSubmissionSuccessEmailOptinAction';
                    } else if(isEmail == 1 && isMail == 1) {
                        mtxAction = 'getUpdatesSubmissionSuccessBothOptinAction';
                    } else {
                        mtxAction = 'getUpdatesSubmissionSuccessMailOptinAction';
                    }

                    mtxData['$$getUpdatesNameplate'] = nameplate;
                    mtxData['$$getUpdatesYear'] = year;
                }
                break;
        }

        if(mtxAction != '') {
            FD.Brand.Metrics.handler.direct(
                FD.Brand.Context.mtxActions[mtxAction],
                mtxData
            );
        }
    }

    function fireScheduleMtxActions(eventData, config) {
        var mtxData = {};
        if(eventData && eventData.registeredEvent === true) {
            if(config) {
                if(config.model) {
                    mtxData['$$testDriveNameplate'] = config.model.toLowerCase();
                }
                if(config.year) {
                    mtxData['$$testDriveYear'] = config.year;
                }
                if(config.response && config.response.cksVisitID) {
                    FD.Brand.Metrics.setParameter('user_cksVisitId', config.response.cksVisitID);
                }
                if(config.request && config.request["customer.modeleAddtnlInfo"] && config.request["customer.modeleAddtnlInfo"] != "") {
                    mtxData['$$modeleAddtnlInfo'] = config.request["customer.modeleAddtnlInfo"] || '';
                }
            }
            FD.Brand.Metrics.handler.direct(
                FD.Brand.Context.mtxActions[eventData.mtxKey],
                mtxData
            );
        }
    }

    function handleGolfMetrics (formType, eventName, config) {
        try {
            switch (formType) {
                case 'promo':
                    // Promo, Raffle, Get Updates form events
                    switch (eventName) {
                        case 'FormShown':
                            var showAction = 'getUpdatesRaffleShowFormAction';
                            if(showAction !== '') {
                                // metrics call for showing form
                                FD.Brand.Metrics.handler.direct(
                                    FD.Brand.Context.mtxActions[showAction]
                                );
                            }
                            break;
                        case 'SubmissionSucceeded':
                            // metrics call for successful submission
                            fireGUSubmissionSuccessAction(config);
                            break;
                    }
                    break;
                case 'request':
                    // Get Updates form events
                    switch (eventName) {
                        case 'FormShown':
                            var showAction = '';
                            if(config && config.formId) {
                                switch(config.formId) {
                                    case 'lpa':
                                        showAction = 'getLpaVehicleSelectFormAction';
                                        break;
                                }
                            }

                            if(showAction !== '') {
                                // metrics call for showing form
                                FD.Brand.Metrics.handler.direct(
                                    FD.Brand.Context.mtxActions[showAction]
                                );
                            }
                            break;
                        case 'RequestView':
                            var showAction = '';
                            if(config && config.formId) {
                                switch(config.formId) {
                                    case 'lpa':
                                        showAction = 'getLpaShowFormAction';
                                        const Vehicle= {};
                                        if (config.model) {
                                            Vehicle["nameplate"] = config.model.toLowerCase();
                                        }
                                        if (config.year) {
                                            Vehicle["modelYear"] = config.year;
                                        }
                                        win.digitaldata["vehicle"] = Vehicle;
                                        break;
                                }
                            }
                            if(showAction !== '') {
                                // metrics call for showing form
                                FD.Brand.Metrics.handler.direct(
                                    FD.Brand.Context.mtxActions[showAction]
                                );
                            }
                            break;
                        case 'SubmissionSucceeded':
                            // metrics call for successful submission
                            // fireGUSubmissionSuccessAction(config);
                            break;
                    }
                    break;
                case 'getupdates':
                    // Get Updates form events
                    switch (eventName) {
                        case 'FormShown':
                            var showAction = 'getUpdatesShowFormAction';
                            if(config && config.formId) {
                                switch(config.formId) {
                                    case 'canvasgu':
                                        showAction = 'canvasGUShowFormAction';
                                        break;
                                    case 'personaldriver':
                                        showAction = 'personalDriverShowFormAction';
                                        break;
                                    case 'kmi':
                                        showAction = 'kmiShowFormAction';
                                        break;
                                    case 'getUpdatesBrochures':
                                        showAction = '';
                                        break;
                                    case 'guComm':
                                        showAction = 'getUpdatesCommShowFormAction';
                                        break;
                                }
                            }

                            if(showAction !== '') {
                                // metrics call for showing form
                                FD.Brand.Metrics.handler.direct(
                                    FD.Brand.Context.mtxActions[showAction]
                                );
                            }
                            break;
                        case 'SubmissionSucceeded':
                            // metrics call for successful submission
                            fireGUSubmissionSuccessAction(config);
                            break;
                    }
                    break;
                case 'schedule':
                    var eventList = SCHEDULE_EVENT_DATA[(config && config.formId) || 'schedule'] || SCHEDULE_EVENT_DATA['schedule'];
                    switch (eventName) {
                        case 'FormShown' :
                            var eventData = eventList && eventList['FormShown'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                        case 'RequestView':
                            var eventData = eventList && eventList['RequestView'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                        case 'ResponseView':
                            var eventData = eventList && eventList['ResponseView'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                        case 'SelectVehicleView':
                            var eventData = eventList && eventList['SelectVehicleView'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                    }
                    break;
                case 'schedulemodele':
                    var eventList = SCHEDULE_EVENT_DATA[(config && config.formId) || 'schedulemodele'] || SCHEDULE_EVENT_DATA['schedulemodele'];
                    switch (eventName) {
                        case 'FormShown' :
                            var eventData = eventList && eventList['FormShown'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                        case 'RequestView':
                            var eventData = eventList && eventList['RequestView'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                        case 'ResponseView':
                            var eventData = eventList && eventList['ResponseView'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                        case 'SelectVehicleView':
                            var eventData = eventList && eventList['SelectVehicleView'] || {};
                            fireScheduleMtxActions(eventData, config);
                            break;
                    }
                    break;
                case 'emailshare':
                    switch (eventName) {
                        case 'ResponseView':
                            //case 'SubmissionSucceeded':
                            var eventData = {
                                "formType": formType,
                                "eventName": eventName,
                                "config": config
                            };
                            $('body').trigger('fgxBrandShareComplete', [eventData]);
                            break;
                    }
                    break;
            }
        } catch(err) {
            console.log("Error occurred in the form event callback method " + err);
        }
    }

})(window, jQuery, FD.Brand, FD.Brand.Context, FD.Brand.User, FD.Brand.Util);

/*global FD*/
;(function(win, $, brand, util) {

    // setup namespace
    Object.assign(brand.namespace('FD.Brand.Position', win), {
        items: {
            setup: setupPositionedItems,
            update: updatePositionedItems
        }
    });

    function setupPositionedItems(element, positionedItemClass, contextSelector) {
        var slides = {},
            $element = $(element),
            positionedItemClass = positionedItemClass || "fgx-positioned-slide-",
            contextSelector = contextSelector || ".billboard-slide.item";

        $element.find(contextSelector).each(function() {
            var $elm = $(this),
                slideId = $elm.data("slideId") || "0",
                elements = $elm.find('[data-position-element]'),
                slideItem = {};

            elements.each(function(idx) {
                var $posElm = $(this),
                    data = $posElm.data('positionElement');

                if(data && data.styles && !$.isEmptyObject(data.styles)) {
                    var itemClass = "fgx-" + data.itemType + "-" + idx;
                    slideItem[itemClass] = data;
                    $posElm.addClass(itemClass);
                    if(util.currentBreakpoint() === 'gux-bkpt-sm') {
                        if(data.hasMobileOverride) {
                            $posElm.css(data.styles.mobile);
                        } else {
                            //add the desktop styles on mobile if we don't have a mobile override
                            if(data.styles.desktop) {
                                $posElm.css(data.styles.desktop);
                            }
                        }
                    } else {
                        if(data.styles.desktop) {
                            $posElm.css(data.styles.desktop);
                        }
                    }
                }
            });

            if(!$.isEmptyObject(slideItem)) {
                var itemClass = positionedItemClass + slideId;
                $elm.addClass(itemClass);
                slides[itemClass]= slideItem;
            }
        });

        return slides;
    }

    function updatePositionedItems(version, positionedObjects) {
        //Iterate over the billboards that have positioned items
        $.each(positionedObjects, function(key, value) {
            if(value && !$.isEmptyObject(value)) {
                //Iterate over the slides
                $.each(value, function(k, v) {
                    if(v && !$.isEmptyObject(v)) {
                        //Iterate over the slide items (headline, subheadline, cta, etc.)
                        $.each(v, function(k1, v1) {
                            if((version === 'mobile' && !v1.hasMobileOverride) || (v1.styles[version] && $.isEmptyObject(v1.styles[version]))) {
                                return;
                            }

                            var selector = "." + k1;
                            var context = "." + key + " ." + k;
                            $(selector, context).css(v1.styles[version]);
                        });
                    }
                });
            }
        });
    }

})(window, jQuery, FD.Brand, FD.Brand.Util);
/**
 * Geolocation - Module
 */
;(function(win, $, brand) {

  // variables and constants here

    const { axios } = win;

    const isValidDecimal = (string) => /^-?\d+\.?\d*$/.test(string);

    const isValidCoordinate = (coordinate) => {
        if (!coordinate) return false;
        const {
            latitude,
            longitude
        } = coordinate;
        return isValidDecimal(latitude) && isValidDecimal(longitude) &&
            Math.abs(latitude) <= 90 &&
            Math.abs(longitude) <= 180;
    };

    const navigatorOptions = {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
    };

    const DEFAULT_USER_LOCATION = { latitude: 42.33, longitude: -83.05 };

    let defaultUserPosition;

    const navigatorSuccess = (position) => {
        if (isValidCoordinate(position.coords)) {
            return position.coords;
        } else {
            return navigatorError();
        }
    };

    const navigatorError = () => getFromIp(ipSuccess, ipError);

    const ipSuccess = response => {
        const coordinates = {latitude: response.latitude, longitude: response.longitude}
        if (isValidCoordinate(coordinates)) {
            return coordinates;
        } else {
            return ipError();
        }
    };

    const ipError = () => {
        return defaultUserPosition;
    };

    const getUserLocation = (defaultPosition) => {
        defaultUserPosition = isValidCoordinate(defaultPosition) ? defaultPosition : DEFAULT_USER_LOCATION;
        return getFromNavigator(
            navigatorSuccess,
            navigatorError,
            navigatorOptions
        );
    };

    const getFromNavigator = (success, error, options) => new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject, options)).then(success).catch(error);

    const getFromIp = (success, error) => fetch("https://get.geojs.io/v1/ip/geo.json")
        .then(response => response.json())
        .then(responseData => {
            return success(responseData)
        })
            .catch(err => error())

    const getBrowserLanguage = () => {
        if (!navigator.language) {
            return "en";
        }
        const browserLanguage = navigator.language.split("-")[0];
        if (browserLanguage.length !== 2) return "en";
        return browserLanguage.toLowerCase();
    };

    const getAddressFromGeoCode = ({location, apikey}) => {
        return fetch("https://revgeocode.search.hereapi.com/v1/revgeocode?" +
            new URLSearchParams({
                at: `${location.latitude},${location.longitude}`,
                apiKey: apikey,
                lang: getBrowserLanguage(),
            })).then(response => {
                return response.json()
            }).then(responseData => {
                let postcode = responseData.items[0].address.postalCode;
                postcode = postcode.includes("-") ? postcode.split("-")[0] : postcode;
                return postcode
            })
            .catch(err => {
                console.log("error fetching zip code" + err);
                return "12345"
            })
    };

  // setup namespace
  Object.assign(brand.namespace('FD.Brand.Geolocation', win), {
      getUserLocation: getUserLocation,
      getAddressFromGeoCode: getAddressFromGeoCode
  });

})(window, jQuery, FD.Brand);

;(function(win, $, util, ctx) {

    // setup namespace
    Object.assign(FD.Brand.namespace('FD.Brand.External', win), {
        adChoices: {
            show: showAdChoices
        },
        whosOn: {
            show: showWhosOn
        },
        commentCard: {
            show: showCommentCard
        },
        vrPlayer: {
            show: showVrPlayer
        },
        cafex: {
            load: loadCafeX
        }
    });

    var _loadedScripts = [];

    var _whosOnDomains = {
        'US-Ford': {
            'sync': '/chat/chatstart.htm?domain=' +
                (ctx.settings.env === 'prod' ? 'support.ford.com' : 'sync.ford.com') +
                '&AspxAutoDetectCookieSupport=1&SID=0',
            'vehicle': '/chat/chatstart.htm?domain=owner.ford.com&AspxAutoDetectCookieSupport=1&SID=0'
        },
        'US-Lincoln': {
            'concierge': '/chat/chatstart.htm?domain=www.lincoln.com&SID=1'
        },
        'CA-Lincoln': {
            'concierge': '/chat/chatstart.htm?domain=www.lincolncanada.com&SID=1'
        }
    };
    var _whosOnWindows = {};
    var _vrConfig = {
        WL_PLAYER_ID: 'wl_vr-player',
        initialized: false,
        options: {}
    };
    var _staticAdChoicesSets = [
        {
            smartLink: '#$creditAdChoices',
            type: 'credit',
            btnId: '_bapw-link',
            pid: getSettingsData('creditAdChoicesPid') || 18173,
            cid: getSettingsData('creditAdChoicesCid') || 1063,
            removeTag: false,
            loaded: false
        },
        {
            smartLink: '#$adChoices',
            type: 'brand',
            btnId: '',
            btnCls: 'evidon-notice-link',
            removeTag: true,
            loaded: false
        }
    ];

    $(init);

    function init() {
        var settings = ctx && ctx.settings || {};
        if(ctx.translationProvider === 'motionpoint') {
            loadMotionPoint();
        }
        if(ctx.chatServiceProvider == 'cafex' && ctx.loadCafexOnPage) {
            loadCafeX();
        }

        //Commenting this link to not invoke salesforce function
        MCPSalesforce();
        setupStaticAdChoices(false);
    }

    function loadScripts(scripts) {
        var def = $.Deferred();
        var loadNextScript = function() {
            if(scripts.length === 0) {
                def.resolve();
                return;
            }
            var script = scripts.shift();
            if(_loadedScripts[script]) {
                loadNextScript();
            } else {
                var host = (ctx.settings.synBaseUrl && script[0] === '/' && script[1] !== '/') ? ctx.settings.synBaseUrl : '';
                util.url.loadAsScript(host + script).then(loadNextScript, function() {
                    util.log('external.lib: failed to load script ' + script);
                    def.reject();
                });
                _loadedScripts[script] = 1;
            }
        };
        loadNextScript();
        return def.promise();
    }

    function showAdChoices(el) {
        if(!util.url.allowScript('6')) {
            util.log('external.lib: AdChoices library not loaded due to privacy settings');
            return;
        } else if (ctx.region === 'US' && ctx.make == 'Lincoln') {
            util.log('external.lib: original AdChoices smartLink functionality disabled for Lincoln US');
            return;
        }
        var pid = 201;
        var ocid = 1063;
        var protocol = win.location.protocol;
        var basePath = (protocol === 'https:') ? 'https://a248.e.akamai.net/betterad.download.akamai.com/91609/pub/' : 'http://cdn.betrad.com/pub/';
        var track = function (a) {
            var img = new Image();
            img.src = protocol + "//l.betrad.com/pub/p.gif?pid=" + pid + "&ocid=" + ocid + "&i" + a + "=1&r=" + Math.random();
        };
        var bp = FD.Brand.Util.currentBreakpoint();
        if (bp === 'gux-bkpt-sm' || bp === 'gux-bkpt-med') {
            win.open('//info.evidon.com/pub_info/' + pid + '?v=1');
            track('c');
        } else {
            loadScripts([
                basePath + 'pub2.js'
            ]).done(function () {
                if (win.BAPW && win.BAPW.i) {
                    win.BAPW.i(el, {
                        pid: pid,
                        ocid: ocid
                    });
                }
                //Temporary fix for https://issues.ngptools.com/jira/browse/AEMOPS-6175
                //Should be removed once Ad Choices fixes this issue within their script
                window.addEventListener("message", function(){
                    $("#_bapw-notice").remove();
                }, false );
            });
        }
    }

    function loadStaticAdChoices(item) {
        if(item && !item.loaded) {
            if(!util.url.allowScript('6')) {
                util.log('external.lib: Static AdChoices library not loaded due to privacy settings');
                return;
            }
            var ev = document.createElement('script');
            ev.type = 'text/javascript';
            ev.async = true;
            if (item.type === 'credit') {
                ev.setAttribute('data-ev-tag-pid', item.pid || '');
                ev.setAttribute('data-ev-tag-ocid', item.cid || '');
                ev.src = '//c.evidon.com/pub/tag.js';
            } else {
                var host = (ctx.settings && ctx.settings.synBaseUrl) ? ctx.settings.synBaseUrl : '';
                ev.src = host + '/etc/designs/brand_ford/brand/vendor/adchoices/js/adchoices.js';
            }
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ev, s);
            item.loaded = true;
        }
    }

    function MCPSalesforce() {
        if (ctx.make === 'Ford' && ctx.region === 'US' && ctx.settings.mcpConfigUrl) {
            if (!util.url.allowScript('6')) {
                console.log('external.lib: MCP script not loaded due to privacy settings');
            } else {
                var ev = document.createElement('script');
                ev.type = 'text/javascript';
                ev.src =  ctx.settings.mcpConfigUrl;
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(ev, s);
            }
        }
    }

    function setupStaticAdChoices(skipFooterListener) {
        var $globalFooterEl = $('body').find('[data-fgx-global-footer]').not('[data-fgx-init]');
        var found = false;
        _staticAdChoicesSets.forEach(function(item) {
            var $el = $('body').find('a[href=\'' + item.smartLink + '\']');
            if ($el && $el.length > 0) {
                $el.attr('id', item && item.btnId || '_bapw-link');
                if (item.removeTag && item.btnCls) {
                    $el.parent().addClass(item.btnCls);
                    $el.remove();
                } else if (item.btnCls) {
                    $el.addClass(item.btnCls);
                }
                loadStaticAdChoices(item);
                found = true;
            }
        });

        // There's a possibility that the footer component hasn't been loaded when this logic is run initially on syndicated
        // pages. Therefore, the below logic is used to check if thats the case, and if so, sets up a listener that will
        // re-trigger the setupStaticAdChoices logic once the globalFooter is loaded.
        if (!found && !skipFooterListener && ctx.settings && ctx.settings.syn && (!$globalFooterEl || ($globalFooterEl && $globalFooterEl.length === 0))) {
            $('body').one('fgxBrandGlobalFooterInitialized', function() {
                setupStaticAdChoices(true);
            });
        }
    }

    function showWhosOn(domainId) {
        var domain = _whosOnDomains[ctx.region + '-' + ctx.make][domainId];
        if(domain) {
            var whosOnWindow = _whosOnWindows[domainId];
            if(whosOnWindow && !whosOnWindow.closed) {
                whosOnWindow.focus();
            } else {
                var url = ctx.settings.whosOnUrl + domain + '&lang=' + ctx.language;
                _whosOnWindows[domainId] = win.open(
                    url,
                    domainId,
                    'scrollbars=1,menubar=0,resizeable=1' +
                    (util.currentBreakpoint() !== 'gux-bkpt-sm' ? ',width=484,height=361' : '')
                );
            }
        }
    }

    function showCommentCard() {
        var formId = ctx && ctx.medalliaFormId || '';
        if (formId) {
            try {
                KAMPYLE_ONSITE_SDK.showForm(formId);
            } catch(e) {
                util.log('external.lib: Error triggering the Medallia comment card.');
            }
        } else {
            util.log('external.lib: No Medallia Form Id authored.');
        }
    }

    function loadMotionPoint() {
        if(!util.url.allowScript('6')) {
            util.log('external.lib: MotionPoint library not loaded due to privacy settings');
            return;
        }
        var mp_el = document.createElement('script');
        mp_el.id = 'mpelid';
        mp_el.async = true;
        mp_el.src = ctx.settings['mpEasyLinkUrl' + ctx.make];
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(mp_el, s);
        win.mp_var = {
            UrlLang: 'mp_js_current_lang',
            SrcUrl: decodeURIComponent('mp_js_orgin_url'),
            oSite: decodeURIComponent('mp_js_origin_baseUrl'),
            tSite: decodeURIComponent('mp_js_translated_baseUrl')
        }
    }

    function showVrPlayer(config, $el) {
        var def = $.Deferred();
        initVrPlayer().then(function() {
            var callbacks = {
                exitCallback: function() {
                    var $player = $('#' + _vrConfig.WL_PLAYER_ID);
                    $('body').removeClass('no-scroll');
                    $player.removeClass('shown');
                    $player.empty();

                    if($el && $el.length > 0) {
                        $el.focus();
                    }
                }
            };
            var options = Object.assign(_vrConfig.options, callbacks);
            var path = (config && config.wl_appConfig) ? config.wl_appConfig : "";
            if(path !== "") {
                var rattler = win && win.RATTLER || {};
                var obj = rattler.createPlayer(path, document.getElementById(_vrConfig.WL_PLAYER_ID), options);

                $('#' + _vrConfig.WL_PLAYER_ID).addClass('shown');
                $('body').addClass('no-scroll');
                def.resolve(obj);
            } else {
                def.resolve({});
            }
        }, function() {
            def.reject();
        });
        return def.promise();
    }

    function initVrPlayer() {
        var def = $.Deferred();
        if(util.url.allowScript('6')) {
            if(_vrConfig.initialized) {
                def.resolve();
            } else {
                // create wl player tag to add the custom VR player to
                $('<div id="' + _vrConfig.WL_PLAYER_ID + '"></div>')
                    .appendTo($('body'));

                window.__webpack_public_path__="/etc/designs/brand_ford/brand/vendor/vrplayer/";

                loadScripts(['/etc/designs/brand_ford/brand/vendor/vrplayer/static/js/fordcom360v1.0.13.js']).then(function() {
                    _vrConfig.initialized = true;
                    def.resolve();
                }, function() {
                    _vrConfig.initialized = false;
                    $('#' + _vrConfig.WL_PLAYER_ID).remove();
                    util.log('vr.lib: error loading VR Player JS file');
                    def.reject();
                });
            }
        } else {
            util.log('external.lib: 360 VR Player library not loaded due to privacy settings');
            def.reject();
        }
        return def.promise();
    }

    function loadCafeX() {
        if(!util.url.allowScript('6')) {
            util.log('external.lib: CafeX library not loaded due to privacy settings');
            return;
        }
        var scriptPath = ctx && ctx.settings['cafexUrl'] || '/etc/designs/common/vendor/cafex/cafex_PROD.js';
        loadScripts([
            scriptPath
        ]);
    }

    function getSettingsData(key) {
        var settings = ctx && ctx.settings || {};
        return settings[key + ctx.make + ctx.languageKey] || settings[key + ctx.languageKey] || settings[key + ctx.make] || settings[key];
    }

})(window, jQuery, FD.Brand.Util, FD.Brand.Context);
/*global FD*/
/**
 * Link support library
 */
;(function(win, $, ctx, ngp, overlay, util, form) {

    // setup namespace
    Object.assign(FD.Brand.namespace('FD.Brand.Link', win), {
        baseUrl: baseUrl,
        secureUrl: secureUrl,
        processLink: processLink,
        switchLanguage: switchLanguage,
        externalUrl: function() { return true; },
        getPageContext: getPageContext,
        setPageContext: setPageContext
    });

    var settings = ctx.settings;
    var linkParameters = {};
    var attributes = {
        urlKey: 'urlKey',
        trimName: 'trimName',
        trimId: 'trimId',
        ngpTrimName: 'ngpTrimName',
        brandNameplateLink: 'brandNameplateLink'
    };
    var pageCtxAttrMap = {
        'modelId': 'trim',
        'nameplateSegment': 'segment',
        'nameplateMetricsName': 'metricsName'
    };
    var LANG_COOKIE = 'lang';
    var pageContext = {
	    make: ctx.make,
	    model: ctx.nameplate && ctx.nameplate.ngpModelName,
	    year:  ctx.nameplate && ctx.nameplate.ngpYear,
	    trim: ctx.model && ctx.model.ngpTrimName
    };
    var segmentNameMap = {
        'car': 'cars',
        'crossover': 'crossovers',
        'suv': 'suvs',
        'hybrid': 'cars',
        'truck': 'trucks',
        'commercial-truck': 'commercial-trucks'
    };
    var _legacyBPNameplates = {
        US: {
            '2021': ['ecosport', 'expedition', 'ranger', 'f-150', 'transit vanwagon', 'transit', 'transit chassis', 'mustang', 'escape', 'edge', 'navigator', 'corsair', 'nautilus'],
            '2022': ['transit connect', 'transit connect wagon', 'superduty', 'superduty commercial', 'chassis cab', 'nautilus', 'aviator']
        },
        CA: {
            '2021': ['f-150 commercial', 'transit chassis', 'transit commercial', 'superduty commercial', 'chassis cab', 'ecosport', 'mache', 'expedition', 'ranger', 'mustang', 'edge', 'superduty', 'escape', 'f-150', 'transit vanwagon', 'transit', 'explorer', 'navigator', 'corsair', 'nautilus'],
            '2022': ['transit connect', 'superduty commercial', 'chassis cab', 'superduty', 'aviator']
        }
    };

	$(init);
    $('body').on('click', 'a[href^=\'#$\']', customLinkClick);
    // global key-listener for non <a> and <button> elements which should be actionable or links to add behaviors for accessibility
    $('body').on('keypress', '[data-fgx-keypress]', fgxBrandKeyPress);
    // separate listener needed for arrow and esc keys - not all browsers support keypress for those.
    $('body').on('keydown', '[data-fgx-keypress]', fgxBrandKeyDown);
    // listener to transition to another item via arrow keys when on an item within a group (radio button or tab)
    $('body').on('keydown', '[data-fgx-focusable-group-item]', fgxFocusableGroupKeyDown);

    //////

    function init() {
        // check if need to switch to preferred language
        if(ctx.translationProvider === 'tdc') {
            var code = util.cookie.get(LANG_COOKIE);
            if(code && code !== ctx.language) {
                var lang = ctx.languages.languageLinks.find(function(i) { return i.code === code; });
                if(lang) {
                    location.assign(langUrlPath(lang.domain));
                    return;
                }
            }
        }
        // process custom link on initial hash
        var hash = win.location.hash;
        if(hash && hash.substring(0, 2) === '#$') {
            var context = linkContext();
            getParameters(context).done(function(prm) {
                processLink(hash, null, context, prm);
            }).fail(function() {
                util.log('Failed to open hash link ' + hash, context);
            })
        }
        // process deep links
        if
        (
            settings.deepLink &&
            settings.deepLink.match(/[^/]+/g).length === 1) // no deeplinks with subpaths
        {
            try {
                var $link = $('#' + settings.deepLink.substring(1));
                win.setTimeout(function() {
                    util.window.scrollTo($link, 250);
                }, 200);
            } catch(e) { }
        }

        if (settings && !settings.syn) {
            setupGlobalFocusInListener();
        }
    }

    function customLinkClick(ev) {
        ev.preventDefault();
        var $el = $(this);
        var href = $(this).attr('href');
        var target = $(this).attr('target');
        var context = linkContext($el.closest('[data-link-context]'));
		getParameters(context).done(function(prm) {
            processLink(href, target, context, prm, $el);
        }).fail(function() {
            util.log('Failed to open link ' + href, context);
        });
    }

    function fgxBrandKeyPress(ev){
        var focused = $(':focus');
        var role = focused.attr('role');
        if(ev.which === 13 && (role === 'radio' || role === 'button' || role === 'link' || role === 'combobox' || role === 'option' || role === 'listbox')) {
            ev.preventDefault();
            ev.stopPropagation();
            focused.trigger('click');
        } else if (ev.which === 32 && (role === 'radio' || role === 'button' || role === 'combobox' || role === 'checkbox' || role === 'option' || role === 'listbox')) {
            // prevent the default 'space' behavior, which causes the window to scroll
            ev.preventDefault();
            ev.stopPropagation();
            focused.trigger('click');
        }
    }

    function fgxBrandKeyDown(ev) {
        var focused = $(':focus');
        var role = focused.attr('role');
        if (ev.which === 40 && (role === 'option' || role === 'combobox' || role === 'listbox')) {
            // down arrow
            ev.preventDefault();
            ev.stopPropagation();
            if (role === 'combobox' || role === 'listbox') {
                $dropdownEl = $('.fgx-custom-select-dropdown', focused);
                if (!$dropdownEl.hasClass('shown')) {
                    focused.trigger('click');
                    // then focus first li
                    $('li:visible', $dropdownEl).first().focus();
                } else {
                    // don't trigger click, only shift focus
                    $('li:visible', $dropdownEl).first().focus();
                }
            } else {
                // focus next li
                focused.next().focus();
            }
        } else if (ev.which === 38 && (role === 'option' || role === 'combobox' || role === 'listbox')) {
            // up arrow
            ev.preventDefault();
            ev.stopPropagation();
            if (role === 'combobox' || role === 'listbox') {
                $dropdownEl = $('.fgx-custom-select-dropdown', focused);
                if (!$dropdownEl.hasClass('shown')) {
                    focused.trigger('click');
                    // then focus last li
                    $('li:visible', $dropdownEl).last().focus();
                } else {
                    // don't trigger click, only shift focus
                    $('li:visible', $dropdownEl).last().focus();
                }
            } else {
                // focus prev li
                focused.prev().focus();
            }
        } else if (ev.which === 27 && (role === 'option')) {
            // esc key
            ev.preventDefault();
            ev.stopPropagation();
            focused.closest('.fgx-custom-select').trigger('click');
            focused.closest('.fgx-custom-select').focus();
        }
    }

    function fgxFocusableGroupKeyDown(ev) {
        var focused = $(document.activeElement),
            $groupContainer = focused.closest('[data-fgx-focusable-group]'),
            $items = $groupContainer.find('[data-fgx-focusable-group-item]'),
            itemsCount = $items.length;

        if($groupContainer.length > 0 && itemsCount > 1) {
            //We have a group with more than 1 item so we need to check the key that is pressed and handle accordingly.
            var idx = $items.index(focused),
                nextIdx = idx,
                keyCode = ev.which;

            if(keyCode === 37 || keyCode === 38) {
                // left and up arrow should go to the previous element
                nextIdx = (idx === 0) ? (itemsCount - 1) : (idx - 1);
            } else if(keyCode === 39 || keyCode === 40) {
                // right and down arrow should go to the next element
                nextIdx = (idx === (itemsCount - 1)) ? 0 : (idx + 1);
            }

            if(nextIdx !== idx) {
                //The next index was updated so one of the proper keys was pressed and we should move forward changing the focus.
                ev.preventDefault();
                ev.stopPropagation();

                var $nextItem = $items.eq(nextIdx),
                    role = focused.attr('role');
                $nextItem.focus();
                if(role === 'radio') {
                    $nextItem.trigger('click');
                }
            }
        }
    }

    function setupGlobalFocusInListener() {
        var navSelector = (ctx && ctx.make === 'Lincoln') ? '.lincolnMainNavigation' : (($('.fordMainNavigationR23').length > 0) ? '.fordMainNavigationR23' : '.fordMainNavigation'),
            $mainNav = $(navSelector),
            $secondaryNav = $('.secondaryNavigation, .cmp-secondaryNavigation, .secondaryNavigationR23').first(),
            _hasSecondaryNav = !!($secondaryNav && $secondaryNav.length > 0),
            $compareModels = $('.models-compare, .compare-models'),
            _hasCompareModels = ($compareModels.length > 0),
            _cmSelectorMbl = '.comparison.mobile-titles.ui-scrollfix',
            _cmSelectorDsk = '.comparison.sticky-clone.ui-scrollfix',
            _cmExcludedSelectors = (_hasCompareModels) ? (', ' + _cmSelectorDsk + ', ' + _cmSelectorMbl + ', .vehicle-modal.compare-active') : '',
            excludedSelectors = navSelector + ', .media-overlay, .postal-code-wrapper, .search-overlay, .fgx-overlay, .towing-guide' + ((_hasSecondaryNav) ? ', .secondaryNavigation' : '') + _cmExcludedSelectors,
            $mainStickyEl = (_hasSecondaryNav) ? $secondaryNav : $mainNav,
            $stickyEl = $mainStickyEl,
            $win = $(win);

        var handleFocusIn = function(ev) {
            var $target = $(ev.target);
            if (!$target || $target.closest(excludedSelectors).length > 0) {
                return;
            }
            if (_hasCompareModels) {
                var $cmStickyEl = $((util.currentBreakpoint() === 'gux-bkpt-sm') ? _cmSelectorMbl : _cmSelectorDsk);
                $stickyEl = ($cmStickyEl && $cmStickyEl.length > 0) ? $cmStickyEl : $mainStickyEl;
            }
            var vpTop = Math.floor($win.scrollTop()),
                elmBorderTop = Math.floor($target.offset().top),
                elmBorderBtm = Math.floor(elmBorderTop + $target.outerHeight(true)),
                topPosDiff = elmBorderTop - vpTop,
                stickyOffset = $stickyEl.outerHeight(),
                incOffScreenCheck = $target.is('[data-fd-focus-offscreen-check]');
            if (vpTop > $mainNav.height() && ((topPosDiff >= 0 && topPosDiff < stickyOffset) || (topPosDiff < 0 && elmBorderBtm > vpTop) || (incOffScreenCheck && (topPosDiff < 0 && elmBorderBtm <= vpTop))) && (_hasSecondaryNav || !$mainNav.hasClass('hide-off-top') || _hasCompareModels)) {
                var scrollPos = vpTop - (stickyOffset - topPosDiff) - 10;
                $('html, body').animate({
                scrollTop: scrollPos
                }, 200);
            }
        };
        $('body').on('focusin', util.debounce(handleFocusIn, 300));
    }

    function linkContext($ctxEl) {
        return Object.assign({}, pageContext, $ctxEl && $ctxEl.length && $.parseJSON($ctxEl.attr('data-link-context')) || {});
    }

    function showGolfForm(typ, $el, ctxOvr) {
        FD.Brand.User.authentication.current().then(function(authState) {
            var $ctxEl = $el && $el.closest('[data-link-context]');
            var cfg = Object.assign(
                (typ === 'quote' || typ === 'testdrive' || typ === 'testdrivev2') && pageContext.make === 'Lincoln' && authState.authType === 'user'
                    ? { lead: { leadSource: 'Lincoln.com Concierge Lead' } }
                    : (typ === 'bltestdrive' && pageContext.make === 'Lincoln')
                    ? { configToken: ctx.pageConfigToken}
                    : {},
                $ctxEl && $ctxEl.length && $.parseJSON($ctxEl.attr('data-link-context')) || {}, ctxOvr || {});

            switch(typ) {
                case 'testdrive':   
                case 'testdrivev2':
                    cfg.options = {};
                    cfg.options.allowChangeDealer = true;
                    break;
                case 'bltestdrive':
                case 'fleettestdrive':
                    cfg.lead = Object.assign({}, { context: 'BrandScheduleTestDrive' }, cfg.lead || {});
                    break;
                case 'schedulemodele':
                    cfg.lead = Object.assign({}, { context: 'BrandScheduleTestDriveModele', affiliateLeadSource: 'test drive' }, cfg.lead || {});
                    cfg.options = {};
                    cfg.options.allowChangeDealer = true;
                    cfg.options.allowChangeVehicle = false;
                    break;
            }
            var $overrideLastFocus = $el && $el.data('fgxLastFocusOverride');
            var $lastFocusElm = ($overrideLastFocus && $overrideLastFocus.length > 0) ? $overrideLastFocus : $el;
            form[{
                quote: 'request',
                testdrive: 'schedule',
                bltestdrive: 'blschedule',
                testdrivev2: 'schedulev2',
                schedulemodele: 'schedulemodele',
                fleettestdrive: 'fleetschedule',
                compareOverlay: 'compare'
            }[typ] || typ].show(cfg, null, null, null, $lastFocusElm);
        });
    }

    function getParameters(context) {
        return $.Deferred(function (defer) {
            var key = Object.values(context).join('-');
            var prm = linkParameters[key];
            if (prm) {
                defer.resolve(prm);
            } else {
                if(!((context.model && context.year) || context.configToken)) {
                    defer.resolve(null);
                    return;
                }
                prm = {};
                var attr = Object.keys(attributes).join(',');
                if (context.configToken) {
                    ngp.attributesProxy('/config/Details.json', {
                        configToken: context.configToken,
                        partClass: 'NONE',
                        returnAttributes: 'NGP_ModelInfo_VehicleType',
                        appContext: 'T1'
                    }, attr).done(function(resp) {
                        var config = resp && resp.Response;
                        if(config) {
                            var attrVal = Object.assign(ngp.attributeMap(config.Attribute), config._attributes);
                            var params = {
                                make: config.Make,
                                model: config.Model,
                                year: config.Year
                            };
                            prm = Object.assign({}, prm, params);
                            prm.trim = context.configToken;
                            prm.config = context.configToken;

                            // NZ - updating the context parameters here with the make/model/year returned from the
                            // configDetail call to properly handle the potential situation where either a model/year
                            // aren't passed in the context object initially, or the configToken references a different
                            // vehicle than the other parameters that were passed in.
                            Object.assign(context, params);

                            Object.keys(attrVal).forEach(function(k) {
                                if(attributes[k]) {
                                    prm[attributes[k]] = attrVal[k];
                                }
                            });
                            if(attrVal['NGP_ModelInfo_VehicleType']) {
                                prm.vehicleType = attrVal['NGP_ModelInfo_VehicleType'];
                            }
                            linkParameters[key] = prm;
                            defer.resolve(prm);
                        } else {
                            defer.resolve(null);
                        }
                    }).fail(function() {
                        defer.resolve(null);
                    });
                } else {
                    ngp.attributesProxy('/products/ModelSlices.json',
                        Object.assign({}, context, {
                        modelSliceDefiners: 'modelId',
                        appContext: 'T1'
                    }), attr).done(function(resp) {
                        var model = util.objPath(resp, 'Response.Model');
                        if(model) {
                            var attrVal = model._attributes;
                            prm.vehicleType = model.VehicleType;
                            prm.year = context.year;
                            if (context.trim) {
                                var trim = context.trim.trim();
                                var foundTrim = null;
                                util.toArray(util.objPath(model, 'ModelSlices.ModelSlice') || []).forEach(function (ms) {
                                    var msAttr = ms._attributes;
                                    var id = msAttr.ngpTrimName;
                                    if (typeof trim === 'string') {
                                        trim = trim.toLowerCase();
                                    }
                                    if (typeof id === 'string') {
                                        id = id.toLowerCase();
                                    }
                                    if (id === trim) {
                                        foundTrim = id;
                                        Object.assign(attrVal, msAttr);
                                        prm.trim = ms.ConfigToken;
                                        prm.config = ms.ConfigToken;
                                        return false;
                                    }
                                });
                                if (!foundTrim) {
                                    util.log('Trim not found ' + context.trim);
                                    defer.reject();
                                    return;
                                }
                            }
                            Object.keys(attrVal).forEach(function (k) {
                                if (attributes[k]) {
                                    prm[attributes[k]] = attrVal[k];
                                }
                            });

                            linkParameters[key] = prm;
                            defer.resolve(prm);
                            //util.log('link parameters', prm)
                        }
                    }).fail(function() {
                        defer.resolve(null);
                    });
                }
            }
        }).promise();
    }

    function processLink(href, target, context, prm, $el) {
        var link = /^#\$(\w*)(\/\w*)?(\/\$\(.*\))?(\?.*)?$/g.exec(href);
        if(link) {
            var url;
            var type = link[1];
            var path = link[2];
            var ctxStr = link[3];
            var ctxOvr = {};
            var qs = util.url.queryString(link[4] || ' ');
            var vehType = (win.location.href.indexOf("commercial") > -1) ? 'comm' : '';
            var urlHash = null;
            if (ctxStr) {
                try {
                    ctxOvr = util.parameters.decode(ctxStr.slice(3, -1) || '') || {};
                } catch (e) {
                    util.log('link.lib::processLink - error retrieving context override data. ', e);
                }
            }
            switch(type) {
                case 'spc':
                    if(prm) {
                        prm['type'] = vehType;
                        FD.Brand.Pricing.show(Object.assign({}, context, prm), $el);
                        return;
                    } else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'estimatepayment');
                    }
                    break;
                case 'postalCode':
                    overlay.instance.postalCodeOverlay.show(true, $el, 'input');
                    return;
                case 'languageSelector':
                    overlay.instance.languageSelector.show(true, $el, 'a.btn');
                    return;
                case 'sendEmail':
                    overlay.instance.emailOverlay.show(true, $el, '.email-subject-textfield');
                    return;
                case 'favorites':
                    overlay.instance.myListOverlay.show(true, $el, '.close');
                    return;
                case 'myList':
                    overlay.instance.myListOverlay.show(true, $el, '.close');
                    return;
                case 'closeOverlay':
                    try {
                        overlay.hideActive();
                    } catch(e) { util.log('link.lib::processLink - error occurred trying to close the active overlay. ', e); }
                    return;
                case 'bp':
                    if(prm) {
                        // NZ - The appId below is a bit confusing. To help clarify:
                        // Ford => FBC: /configure/, BNP: /build/
                        // Lincoln => FBC: /build/, LAB: /configure/
                        var toLegacyApp = useLegacyBPApp(context.model, context.year),
                            useConfigAppId = (ctx && ctx.make === 'Lincoln') ? toLegacyApp : !toLegacyApp,
                            appID = (useConfigAppId) ? '/configure/' : '/build/';
                        url = [ baseUrl('shop'),
                            appID,
                            prm.urlKey,
                            '/',
                            context.year,
                            '/'];

                        // BRAND-22381 - update bp smartLink to direct to FBC app by default
                        if (toLegacyApp) {
                            // BRAND-16019 - go to the BNP experience
                            //BRAND-14435
                            if (context.configToken) {
                                // BRAND-16019 - the check for 'configure' here relates to whether we're directing to BNP
                                // for Lincoln or Ford as BNP for Lincoln is setup to use 'configure' in the URL. This check
                                // is NOT related to the actual configure application in any way.
                                var pageKey = (appID === '/configure/') ? 'exterior' : 'config';
                                url.push(
                                    '#/',
                                    pageKey,
                                    '/',
                                    prm.config
                                );
                            } else if(context.trim) {
                                url.push(
                                    '#/select/',
                                    prm.config
                                );
                            }
                        } else {
                            // BRAND-16019 - go to the new configure application
                            if (context.configToken) {
                                url.push(
                                    'config/exterior/',
                                    prm.config
                                );
                            } else if (context.trim && prm.trimId) {
                                url.push(
                                    'model/customize/',
                                    prm.trimId
                                );
                            }
                        }
                    } else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'build');
                    }
                    break;
                case 'si':
                    url = [baseUrl('inventory')];
                    if(prm) {
                        url.push(
                            ctx.nameplate.urlKey || prm.urlKey
                        );
                        if(context.year) {
                            qs.add('year', context.year);
                        }
                        if(context.trim) {
                            qs.add('selectTrim', prm.ngpTrimName);
                        }
                    }  else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'inventory');
                    }
                    break;
                case 'siresults':
                    url = [baseUrl('inventory')];
                    if(prm) {
                        url.push(
                            ctx.nameplate.urlKey || prm.urlKey,
                            '/results/'
                        );
                        if(context.year) {
                            qs.add('year', context.year);
                        }
                        if(context.trim) {
                            qs.add('selectTrim', prm.ngpTrimName);
                        }
                        if(context.radius) {
                            qs.add('Radius', context.radius);
                        }
                    }  else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'inventoryresults');
                    }
                    break;
                case 'siDetail':
                    url = [baseUrl('inventory')];
                    if(prm) {
                        if (context.vin) {
                            url.push(
                                'details/',
                                ctx.nameplate.urlKey || prm.urlKey,
                                '/vin/',
                                context.vin
                            );
                        } else {
                            url.push(
                                ctx.nameplate.urlKey || prm.urlKey,
                                '/results/'
                            );
                            if(context.radius) {
                                qs.add('Radius', context.radius);
                            }
                        }
                        if(context.year) {
                            qs.add('year', context.year);
                        }
                        if(context.trim) {
                            qs.add('selectTrim', prm.ngpTrimName);
                        }
                    }  else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'inventoryresults');
                    }
                    break;
                case 'incentives':
                    if(prm) {
                        url = [ baseUrl('ngbs'),
                            ngbsNameplatePath(prm),
                            '/pricing-and-incentives/'
                        ];
                    } else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'incentives');
                    }
                    break;
                case 'nbs':
                    url = [ baseUrl('shop'),
                        '/showroom/' ];
                    break;
                case 'iqq':
                    if(prm) {
                        url = [ baseUrl('shop'),
                            '/quote/' ];

                        url.push(
                            prm.urlKey || context.model.toLowerCase(),
                            '/',
                            context.year,
                            '/'
                        );
                        if(context.trim) {
                            qs.add('select', prm.trimName);
                        }
                    } else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'quote');
                    }
                    break;
                case 'compare':
                    if(prm) {
                        url = [ baseUrl('ngbs'),
                            ngbsNameplatePath(prm),
                            '/compare/'
                        ];
                    } else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'compare');
                    }
                    break;
                case 'brochures':
                    if(prm) {
                        url = [ baseUrl('ngbs'),
                            ngbsNameplatePath(prm),
                            '/brochures/'
                        ];
                    } else {
                        url = [ baseUrl('shop'),
                            '/showroom/' ];
                        qs.add('linktype', 'brochures');
                    }
                    break;
                case 'ediShowroom':
                    url = [ baseUrl('ngbs'),
                        '/buy/inventory'];
                    if (prm) {
                        var hashArr = [];
                        if (context.year) {
                            hashArr.push(context.year);
                        }
                        if (context.trim) {
                            hashArr.push(context.trim);
                        }
                        if (context.model) {
                            hashArr.push(context.model);
                        }
                        if (hashArr.length > 0) {
                            urlHash = "#config=" + hashArr.join(',');
                        }
                    }
                    break;
                case 'ediShowroomReturn':
                    handleEdiShowroomReturn(context, prm, qs, target);
                    return;
                case 'quote':
                case 'testdrive':
		        case 'schedulemodele':
                case 'getupdates':
                case 'guShop':
                case 'guReveal':
                case 'guRevealShop':
                case 'guRevealCTA':
                case 'guBillboard':
                case 'guComm':
                case 'blgetupdates':
                case 'bltestdrive':
                case 'canvasgu':
                case 'personaldriver':
                case 'testdrivev2':
                case 'testdrivemodele':
                case 'fleettestdrive':
                case 'kmi':
                case 'promo':
                case 'lpa':
                case 'imageshare':
                case 'videoshare':
                case 'ediRequest':
                case 'compareOverlay':
                    showGolfForm(type, $el, ctxOvr);
                    return;
                case 'userSignIn':
                    // url = [ baseUrl('ngbsSecure'),
                    //     '/account/sign-in/?CLWInitLoad=signin&CLWRedirectLogin=',
                    //     encodeURIComponent(window.location.href),
                    //     "&Continue=",
                    //     encodeURIComponent(window.location.href) //BNP-4030
                    // ];
                    FD.Brand.User.authentication.login();
                    break;
                case 'userCreateAccount':
                    FD.Brand.User.authentication.register();
                    break;
                case 'userSignOut':
                    FD.Brand.User.authentication.logout();
                    return;
                case 'opinionLab': // included for backward compatibility
                case 'commentCard':
                    FD.Brand.External.commentCard.show();
                    break;
                case 'adChoices':
                    FD.Brand.External.adChoices.show($el && $el[0]);
                    break;
                case 'chat':
                    if(ctx && ctx.chatServiceProvider == 'cafex') {
                        FD.Brand.External.cafex.load();
                    } else {
                        FD.Brand.External.whosOn.show(path && path.substring(1));
                    }
                    break;
                case 'vrPlayer':
                    var $ctxEl = $el.closest('[data-vr-config]');
                    var vrConfig = Object.assign({}, $ctxEl && $ctxEl.length && $.parseJSON($ctxEl.attr('data-vr-config')) || {});
                    FD.Brand.External.vrPlayer.show(vrConfig, $el);
                    break;
                case 'browserBack':
                    win.history.back();
                    break;
                case 'cookieSettings':
                    if (win.Optanon) {
                        try {
                            win.Optanon.ToggleInfoDisplay();
                        } catch(e) {
                            util.log('link.lib: error occurred opening the OneTrust cookie overlay. ', e);
                        }
                    } else {
                        util.log('link.lib: window.Optanon does not exist');
                    }
                    break;
                case 'overlay':
					if ('id' in ctxOvr && ctxOvr.id in overlay.instance) {
						overlay.instance[ctxOvr.id].show(true, $el, '.close-overlay');
					} else {
						util.log('link.lib: no overlay found for ' + ctxOvr.id);
					}
					break;
				default:
                    util.log('link.lib: Unknown link', link);
                    return;
            }
            if(url) {
                url.push(qs.asString());

                if (urlHash) {
                    url.push(urlHash);
                }
            }
            var fullLink = url && url.join('');
            if(fullLink) {
                if (target === '_blank') {
                    window.open(fullLink);
                } else {
                    window.location.assign(fullLink);
                }
            }
        }
    }

    function secureUrl(url) {
        return url.replace(/^http:\/\//i, 'https://');
    }

    function ngbsNameplatePath(prm) {
        if(ctx.nameplatePath) {
	        return ctx.nameplatePath.substr(ctx.siteRootPath.length) || '';
        } else {
            var output = prm.brandNameplateLink || '';
            return (output.slice(-1) === '/') ? output.slice(0, output.length - 1) : output;
        }
    }

    function baseUrl(type) {
        var key = type + 'Url';
        return settings[key + ctx.make + ctx.languageKey] || settings[key + ctx.languageKey] || settings[key + ctx.make] || settings[key];
    }

    function getLegacyBPNameplates(year) {
        return _legacyBPNameplates[ctx.region] && _legacyBPNameplates[ctx.region][year] || [];
    }

    function useLegacyBPApp(np, year) {
        var npList = getLegacyBPNameplates(year);
        return (npList.indexOf((np || '').toLowerCase()) >= 0);
    }

    function switchLanguage(el) {
        var $el = $(el);
        if($el.hasClass('current-lang')) {
            return true;
        }
        var lang = el.getAttribute('data-lang');
        var url = el.getAttribute('data-href');
        switch(ctx.translationProvider) {
            case 'tdc':
                location.assign(langUrlPath(url));
                var domain = ctx.settings['siteCookieDomain' + ctx.make];
                util.cookie.set(LANG_COOKIE, lang, {
                    path: '/',
                    domain: ((domain || '') === '') ? null : domain,
                    expires: 30
                });
                return true;
            default:
                // motion point
                return false;
        }
    }

    function langUrlPath(langDomain) {
        var path = location.pathname;
        if(path === '/') {
            path = '';
        }
        var outPath = '';
        if(path.indexOf('/content/') === 0) {
            var pathArr = path.split('/');
            for(var i = 5; i < pathArr.length; i++) {
                outPath += '/';
                outPath += pathArr[i];
            }
            // if(outPath.length === 0) {
            //     outPath = '/';
            // }
        } else {
            outPath = path;
        }
        outPath = util.url.extension(outPath).removeSpecified('.html');
        if(outPath.length > 0 && outPath.substring(outPath.length - 1) !== '/') {
            outPath += '/'
        }
        return '//' + langDomain + outPath + util.url.queryString().asString();
    }

    function handleEdiShowroomReturn(context, prm, qs, target) {
        var urlHash = null,
            vehicleStr = (context && context.make && context.model) ? (context.make + ' ' + context.model) : '',
            vehicleStr = (vehicleStr && context.trim) ? (vehicleStr + ' ' + context.trim) : vehicleStr,
            url = [ baseUrl('ngbs'),
                '/buy/inventory'];

        var setDefaultHash = function() {
            if (context) {
                var hashArr = [];
                if (context.year) {
                    hashArr.push(context.year);
                }
                if (context.trim) {
                    hashArr.push(context.trim);
                }
                if (context.model) {
                    hashArr.push(context.model);
                }
                if (hashArr.length > 0) {
                    urlHash = "#config=" + hashArr.join(',');
                }
            }
        };
        var goToUrl = function() {
            if (!urlHash) {
                setDefaultHash();
            }
            if (url) {
                url.push(qs.asString());

                if (urlHash) {
                    url.push(urlHash);
                }
            }
            var fullLink = url && url.join('');
            if (fullLink) {
                if (target === '_blank') {
                    window.open(fullLink);
                } else {
                    window.location.assign(fullLink);
                }
            }
        };

        FD.Brand.User.fps.current().done(function(state) {
            if (!state.loaded) {
                util.log('FPS library not loaded');
                goToUrl();
                return;
            }

            var fpsResponseObject = {
                success: function(resp) {
                    util.log('link.lib::handleEdiShowroomReturn - FPS call successful. ', resp);
                    var recentList = resp && resp[0] && resp[0].RecentShowroomEDI || [],
                        recentItem = (recentList && !util.isEmpty(recentList)) ? recentList[0] : null,
                        returnUrl = recentItem && recentItem.returnURL || '';

                    if (returnUrl && returnUrl.indexOf("#config") > -1) {
                        urlHash = returnUrl.slice(returnUrl.indexOf("#config"));
                        var qsObj = qs.asObject() || {};
                        if (qsObj && qsObj['intcmp']) {
                            qsObj['intcmp'] = qsObj['intcmp'].replace('default', 'return');
                        }
                    }
                    goToUrl();
                },
                error: function(err) {
                    util.log('link.lib::handleEdiShowroomReturn - error occurred with the FPS call. ', err);
                    goToUrl();
                }
            };

            try {
                if (vehicleStr) {
                    FPS.RecentNameplateShowroomEDI(vehicleStr, fpsResponseObject);
                } else {
                    FPS.get([{RecentShowroomEDI:{}}], fpsResponseObject);
                }
            } catch(e) {
                util.log('link.lib::handleEdiShowroomReturn - error occurred trying to get the recent showroom EDI return url from FPS. ', e);
                goToUrl();
            }
        });
    }

    function getPageContext() {
        return Object.assign({}, pageContext);
    }

    function setPageContext(ctx) {
        ctx = ctx || {};
        if(ctx.configToken) {
            ngp.configDetail({
                configToken: ctx.configToken,
                partClass: 'NONE',
                returnAttributes: 'modelId;nameplateMetricsName;nameplateSegment',
                appContext: 'T1'
            }).done(function(config) {
                if(config) {
                    var params = {
                        make: config.Make,
                        model: config.Model,
                        year: config.Year,
                        configToken: ctx.configToken
                    };
                    util.toArray(config.Attribute || []).forEach(function(attr) {
                        if (attr.name && attr.Value) {
                            var key = pageCtxAttrMap[attr.name] || attr.name;
                            params[key] = attr.Value;
                        }
                    });
	                Object.assign(pageContext, params);
	                updateFDContext(params);
                }
            });
        } else {
	        var params = {
                make: ctx.make,
                model: ctx.model,
                year: ctx.year,
                trim: ctx.trim
            };
	        Object.assign(pageContext, params);
            updateFDContext(params);
        }
    }

    function updateFDContext(params) {
        if(ctx) {
            ctx.make = params.make;
            var nameplate = {
                ngpModelName: params.model,
                ngpYear: params.year
            };

            if (params.segment) {
                nameplate['segment'] = params.segment;
            }
            if (params.metricsName) {
                nameplate['metricsName'] = params.metricsName;
            }

            ctx.nameplate = Object.assign({}, ctx.nameplate || {}, nameplate);

            if(params.trim) {
                var model = {
                    ngpTrimName: params.trim
                };
                ctx.model = Object.assign({}, ctx.model || {}, model);
            }
            if(params.configToken) {
                ctx.pageConfigToken = params.configToken;
            }
        }
        if (FD.Brand && FD.Brand.Metrics) {
            FD.Brand.Metrics.updateVehicle(params.make, params.model, params.year, params.metricsName, params.segment);
        }
    }

})(window, jQuery, FD.Brand.Context, FD.Brand.NgpServices, FD.Brand.Overlay, FD.Brand.Util, FD.Brand.Form);

/*global FD*/
(function(win, $, brand, ctx, user, util) {

    // dealer library
    Object.assign(brand.namespace('FD.Brand.Dealer', win), {
        sortPreferred: getSortPreferred,
        isFullStateName: getIsFullStateName,
        updateDealer: updateDealer,
        updateForChangeDealer: updateForChangeDealer,
        updateSearchHints: updateSearchHints,
        getSearchHintData: getSearchHintData,
        appendT3QS: appendT3QS,
        getDealerConfig: getDealerConfig
    });

    var NON_ALPHA_REGEX = /[^A-Za-z0-9]/g;

    function getSortPreferred(dealers) {
        var preferredDealers = [];
        var unpreferredDealers = [];
        dealers.forEach(function eachDealer(dealer) {
            if (dealer.isPreferred) {
                preferredDealers.push(dealer);
            }
            else {
                unpreferredDealers.push(dealer);
            }
        });

        return preferredDealers.concat(unpreferredDealers);
    }

    var fullStateNames = ['Alabama','Alaska','Arizona','Arkansas','California','Colorado','Connecticut','Delaware','District of Columbia','Florida','Georgia','Hawaii','Idaho','Illinois','Indiana','Iowa','Kansas','Kentucky','Louisiana','Maine','Maryland','Massachusetts','Michigan','Minnesota','Mississippi','Missouri','Montana','Nebraska','Nevada','New Hampshire','New Jersey','New Mexico','New York','North Carolina','North Dakota','Ohio','Oklahoma','Oregon','Pennsylvania','Rhode Island','South Carolina','South Dakota','Tennessee','Texas','Utah','Vermont','Virginia','Washington','West Virginia','Wisconsin','Wyoming'];
    var fullProvinceNames = ['Alberta','British Columbia','Manitoba','New Brunswick','Newfoundland and Labrador','Newfoundland','Labrador','Nova Scotia','Nunavut','Northwest Territories','Ontario','Prince Edward Island','Quebec','Saskatchewan','Yukon'];

    function getIsFullStateName(val) {
        if (ctx.region === 'CA') {
            for (var i = 0; i < fullProvinceNames.length; i ++) {
                var str = fullProvinceNames[i];
                if (str.toLowerCase() === val.toLowerCase()) {
                    return true;
                }
            }
        } else {
            for (var i = 0; i < fullStateNames.length; i ++) {
                var str = fullStateNames[i];
                if (str.toLowerCase() === val.toLowerCase()) {
                    return true;
                }
            }
        }
        return false;
    }

    function updateDealer(dealer, idx, salesOpenUntil, salesOpenAgain, preferredDealer, dealerPageLink, hoursDisplayType) {
        // convert service/sales open/close time format
        var dt = new Date();
        var dow = dt.getDay();
        var hour = dt.getHours();
        // only process our hours if we don't already have a 'SalesHoursDescription' - if we do, we've already processed this dealer.
        if(dealer.SalesHours && dealer.SalesHours.Day && !dealer.SalesHoursDescription) {
            dealer.SalesHours.Day.forEach(function(day, dayIdx) {
                if (dayIdx === dow && day.open && hour < day.open.split(':')[0]) {
                    dealer.SalesHoursDescription = salesOpenAgain + ' ' + convertTime(day.open, hoursDisplayType);
                } else if(dayIdx === dow && day.close && hour < day.close.split(':')[0]) {
                    dealer.SalesHoursDescription = salesOpenUntil + ' ' + convertTime(day.close, hoursDisplayType);
                } else if (dayIdx === dow && day.close && hour >= day.close.split(':')[0]) {
                    dealer.SalesHoursDescription = salesOpenAgain + ' ' + findNextOpen(dealer.SalesHours.Day, (dayIdx + 1), hoursDisplayType);
                } else if (dayIdx === dow && day.closed) {
                    dealer.SalesHoursDescription = salesOpenAgain + ' ' + findNextOpen(dealer.SalesHours.Day, (dayIdx + 1), hoursDisplayType);
                }
                day.open = convertTime(day.open, hoursDisplayType);
                day.close = convertTime(day.close, hoursDisplayType);
            });
        }
        // need to convert service hours as well
        if(dealer.ServiceHours && dealer.ServiceHours.Day) {
            dealer.ServiceHours.Day.forEach(function(day, dayIdx) {
                day.open = convertTime(day.open, hoursDisplayType);
                day.close = convertTime(day.close, hoursDisplayType);
            });
        }
        // figure out if we're a preferred dealer and set a flag.
        if (preferredDealer != null && dealer.PACode && dealer.PACode === preferredDealer.PACode) {
            dealer.isPreferred = true;
        } else {
            dealer.isPreferred = false;
        }
        if (dealerPageLink != null) {
            var ext = (window.location.pathname.indexOf('.html') > 0) ? '.html' : '';
            dealer.DeepLinkUrl = [
                dealerPageLink,
                dealer.urlKey,
                ext
            ].join('');
            dealer.ReviewsDeepLinkUrl = [
                dealerPageLink,
                dealer.urlKey,
                '/reviews',
                ext
            ].join('');
        }
        if(dealer.PACode && dealer.Address && dealer.Address.PostalCode) {
            var street = [dealer.Address.Street1];
            if (dealer.Address.Street2) {
                street.push(dealer.Address.Street2);
            }
            if (dealer.Address.Street3) {
                street.push(dealer.Address.Street3);
            }
            dealer.AddressStreet = street.join(', ');
            dealer.AddressCityStateZip = dealer.Address.City + ', ' + (dealer.Address.Province || dealer.Address.State) + ' ' + dealer.Address.PostalCode;
            dealer.MobileMapUrl = 'http://maps.apple.com/?daddr=' + dealer.AddressStreet + ' ' + dealer.AddressCityStateZip;
        }
        if(dealer.textnumber) {
            dealer.TextUrl = dealer.textnumber.replace(/^\(/, '').replace(/\)\s?/, ' ').replace(/\s/g, '').replace('-', '');
        }
        // if 'mt-attr-val' cookie exists add the appropriate param value to the dealer data
        var mtAttrValCookieVal = util.cookie.get('mt-attr-val'),
            currentQSObj = util.parameters.decode(window.location.search),
            fdGuidCurrentQSVal = currentQSObj['fdguid'];

        if (mtAttrValCookieVal != null && typeof mtAttrValCookieVal !== 'undefined') {
            dealer.mtAttrQS = 'fdguid=' + mtAttrValCookieVal;
        } else if (fdGuidCurrentQSVal != null && typeof fdGuidCurrentQSVal !== 'undefined') {
            dealer.mtAttrQS = 'fdguid=' + fdGuidCurrentQSVal;
        } else {
            dealer.mtAttrQS = null;
        }

        //dealer.mtAttrQS = (mtAttrValCookieVal) ? 'fdguid=' + mtAttrValCookieVal : null;
        if(ctx.make === 'Lincoln') {
            // normalize combined ratings using Lincoln values if they exist
            if (dealer.l_cmb_rate_ct && dealer.l_cmb_rate_ct > 0) {
                dealer.combinedRating = dealer.l_cmb_rate;
                dealer.combinedRatingsPercentage = generateRatingsPercentage(dealer.l_cmb_rate);
                dealer.combinedRatingsCount = dealer.l_cmb_rate_ct;
            }
            // normalize sales ratings using Lincoln values if they exist
            if (dealer.l_sls_rate_ct && dealer.l_sls_rate_ct > 0) {
                dealer.salesRating = dealer.l_sls_rate;
                dealer.salesRatingsPercentage = generateRatingsPercentage(dealer.l_sls_rate);
                dealer.salesRatingsCount = dealer.l_sls_rate_ct;
            }
            // normalize service ratings using Lincoln values if they exist
            if (dealer.l_svc_rate_ct && dealer.l_svc_rate_ct > 0) {
                dealer.serviceRating = dealer.l_svc_rate;
                dealer.serviceRatingsPercentage = generateRatingsPercentage(dealer.l_svc_rate);
                dealer.serviceRatingsCount = dealer.l_svc_rate_ct;
            }
        } else {
            // normalize combined ratings using Ford values
            if (dealer.f_cmb_rate_ct && dealer.f_cmb_rate_ct > 0) {
                dealer.combinedRating = dealer.f_cmb_rate;
                dealer.combinedRatingsPercentage = generateRatingsPercentage(dealer.f_cmb_rate);
                dealer.combinedRatingsCount = dealer.f_cmb_rate_ct;
            }
            // normalize sales ratings using Ford values if they exist
            if (dealer.f_sls_rate_ct && dealer.f_sls_rate_ct > 0) {
                dealer.salesRating = dealer.f_sls_rate;
                dealer.salesRatingsPercentage = generateRatingsPercentage(dealer.f_sls_rate);
                dealer.salesRatingsCount = dealer.f_sls_rate_ct;
            }
            // normalize service ratings using Ford values if they exist
            if (dealer.f_svc_rate_ct && dealer.f_svc_rate_ct > 0) {
                dealer.serviceRating = dealer.f_svc_rate;
                dealer.serviceRatingsPercentage = generateRatingsPercentage(dealer.f_svc_rate);
                dealer.serviceRatingsCount = dealer.f_svc_rate_ct;
            }
        }
        dealer.index = idx;
        // default value for 'Change Dealer' treatment so it always has a default
        dealer.isSelectableForOrderManagement = false;
        return dealer;
    }

    function updateForChangeDealer(dealer, idx, salesOpenUntil, salesOpenAgain, preferredDealer, dealerPageLink, hoursDisplayType, orderNameplate, readyToOrder) {
        //console.log("##### UPDATE FOR CHANGE DEALER #####");
        dealer = updateDealer(dealer, idx, salesOpenUntil, salesOpenAgain, preferredDealer, dealerPageLink, hoursDisplayType);
        //console.log("##### INITIAL DEALER UPDATE COMPLETE #####");
        if (dealer.AuthorizedToSell && dealer.AuthorizedToSell.Model && dealer.AuthorizedToSell.Model.length > 0) {
            for (var i = 0; i < dealer.AuthorizedToSell.Model.length; i ++) {
                var model = dealer.AuthorizedToSell.Model[i];
                //console.log("##### CHECKING AUTHORIZED TO SELL FOR MODEL NAME : " + model.ModelName + " #####");
                if (model.ModelName === orderNameplate) {
                    //console.log("##### MODEL NAME MATCH FOUND - CONTINUING TO RESERVE / ORDER LOGIC #####");
                    if(ctx.make === 'Lincoln') {
                        //console.log("##### MAKE IS LINCOLN #####");
                        if (readyToOrder) {
                            //console.log("##### READY TO ORDER IS TRUE #####");
                            if (dealer.lorder && dealer.lorder > 0) {
                                //console.log("##### 'lorder' is true #####");
                                dealer.isSelectableForOrderManagement = true;
                            }
                        } else {
                            //console.log("##### READY TO ORDER IS FALSE #####");
                            if (dealer.lreserve && dealer.lreserve > 0) {
                                //console.log("##### 'lreserve' is true #####");
                                dealer.isSelectableForOrderManagement = true;
                            }
                        }
                    } else {
                        //console.log("##### MAKE IS FORD #####");
                        if (readyToOrder) {
                            //console.log("##### READY TO ORDER IS TRUE #####");
                            if (dealer.forder && dealer.forder > 0) {
                                //console.log("##### 'forder' is true #####");
                                dealer.isSelectableForOrderManagement = true;
                            }
                        } else {
                            //console.log("##### READY TO ORDER IS FALSE #####");
                            if (dealer.freserve && dealer.freserve > 0) {
                                //console.log("##### 'freserve' is true #####");
                                dealer.isSelectableForOrderManagement = true;
                            }
                        }
                    }
                    return dealer;
                }
            }
        }
        return dealer;
    }

    function generateRatingsPercentage(decimalValue) {
        var ratingsPercentage = (decimalValue / 5) * 100;
        return ratingsPercentage + '%';
    }

    function findNextOpen(days, index, hoursDisplayType) {
        var nextOpen = undefined;
        var totalIterations = 0;
        while (nextOpen === undefined) {
            if (index > days.length) index = 0;
            var day = days[index];
            if (day != undefined && day.open) {
                if (day.open.indexOf('AM') > 0 || hoursDisplayType == '24') {
                    nextOpen = day.open + " " + day.name;
                } else {
                    nextOpen = convertTime24to12(day.open) + " " + day.name;
                }
                break;
            }
            index ++;
            totalIterations ++;
            if (totalIterations >= 7) break;
        }
        return nextOpen;
    }

    function convertTime(time, hoursDisplayType) {
        if(hoursDisplayType == '12') {
            return convertTime24to12(time);
        } else {
            return convertTime24(time);
        }
    }

    function convertTime24to12(time) {
        // if we have 'AM' or 'PM' in our time value, we've already been converted.
        if(time && time.indexOf('AM') < 0 && time.indexOf('PM') < 0) {
            var arTime = time.split(':');
            if (arTime.length == 2) {
                var hour = parseInt(arTime[0], 10);
                var amPM = 'AM';
                if (hour === 0 || hour > 12) {
                    hour = (hour === 0) ? 12 : hour - 12;
                    amPM = 'PM';
                } else if (hour === 12) {
                    amPM = 'PM';
                }
                time = hour + ':' + arTime[1] + amPM;
            }
        }
        return time;
    }

    function convertTime24(time) {
        // if we have 'h' in our time value, we've already been converted
        if (time && time.indexOf('h') < 0) {
            var arTime = time.split(':');
            if (arTime.length < 2) {
                time = arTime[0] + 'h00';
            } else {
                time = arTime[0] + 'h' + arTime[1];
            }
        }
        return time;
    }

    /**
     * Retrieve the typeAhead results directly without handling the display logic.
     * @param data - object that includes the following properties:
     *      -val: the value that should be passed to the typeAhead service.
     *      -isDealer: boolean to indicate whether a dealerName or location search is being performed.
     * @param maxCount - the maximum number of results that should be returned. Default: 5.
     * @param includeDistance - boolean indicating whether the distance based on the users current coordinates should be determined or not.
     */
    function getSearchHintData(data, maxCount, includeDistance) {
        var def = $.Deferred(),
            cCoords = {},
            maxResultCount = maxCount || 5,
            includeDist = includeDistance || false;
        if(includeDist && util && util.env.geoLocation()) {
            cCoords = user.location.coordinates();
        }

        if(!data.isDealer) {
            // search by location
            // Note, maxResults is limited to 20 below because thats the maximum that the BING location API will allow.
            // reference: https://docs.microsoft.com/en-us/bingmaps/rest-services/locations/find-a-location-by-query
            $.ajax({
                url: ctx.settings.mapSearch,
                dataType: 'jsonp',
                data: {
                    q: data.val,
                    maxResults: Math.min(maxResultCount, 20),
                    key: ctx.settings.mapKey
                },
                jsonp: 'jsonp',
                cache: true
            }).done(function(resp) {
                var locations,
                    results = [];
                if (resp.statusCode === 200 &&
                    resp.resourceSets &&
                    resp.resourceSets.length &&
                    (locations = resp.resourceSets[0]) &&
                    (locations = locations.resources)) {

                    locations = locations.filter(function(i) { return i.address && i.address.countryRegionIso2 === ctx.region; });

                    locations.slice(0, Math.min(locations.length, maxResultCount)).forEach(function(item) {
                        var hasCoordinates = (item.point && item.point.coordinates && item.point.coordinates.length),
                            resItem = {
                                name: item.name || '',
                                paCode: null,
                                location: {
                                    lat: (hasCoordinates) ? item.point.coordinates[0] : 1,
                                    lon: (hasCoordinates) ? item.point.coordinates[1] : 1
                                },
                                distance: {},
                                hasDistance: false
                            };

                        if(includeDist && !brand.Util.isEmpty(cCoords)) {
                            var dist = util.distance.betweenCoords(cCoords.lat, cCoords.lon, resItem.location.lat, resItem.location.lon, true);
                            resItem.distance = Object.assign(resItem.distance, dist);
                            resItem.hasDistance = (!brand.Util.isEmpty(resItem.distance));
                        }
                        results.push(resItem);
                    });
                }
                def.resolve(results);
            }).fail(function(resp) {
                def.resolve([]);
            });
        } else {
            // search by dealer name
            var locateDealerServiceURI = '/searchservices/fd/';
            if (ctx.make === 'Ford') {
                locateDealerServiceURI = '/searchservices/fd/';
            } else if (ctx.make === 'Lincoln') {
                locateDealerServiceURI = '/searchservices/ld/';
            }

            $.ajax({
                url: locateDealerServiceURI,
                data: {
                    q: srch.val,
                    type: 'suggest_static'
                },
                callback: 'JSON_CALLBACK',
                method: 'GET',
                responseType: 'json',
                headers: {
                    'Application-id': ctx.settings.clientId
                },
                cache: true,
                timeout: 5000
            }).done(function(resp) {
                var locations,
                    results = [];
                if (resp.suggestions &&
                    resp.suggestions.length) {
                    results = def.resolve(
                        resp.suggestions.slice(0, Math.min(resp.suggestions.length, 5))
                            .map(function(suggestion) {
                                var locationParts = suggestion.split('+');
                                var resItem = {
                                    paCode: (locationParts[0]) ? locationParts[0] : '',
                                    name: (locationParts[1]) ? locationParts[1] : '',
                                    location: {
                                        city: locationParts[2],
                                        state: locationParts[3],
                                        lat: (locationParts[4]) ? parseFloat(locationParts[4]) : 1,
                                        lon: (locationParts[5]) ? parseFloat(locationParts[5]) : 1
                                    },
                                    distance: {}
                                };

                                if(!brand.Util.isEmpty(cCoords)) {
                                    var dist = util.distance.betweenCoords(cCoords.lat, cCoords.lon, resItem.location.lat, resItem.location.lon, true);
                                    resItem.distance = Object.assign(resItem.distance, dist);
                                }
                                return resItem;
                            })
                    );
                }
                def.resolve(results);
            });
        }
        return def.promise();
    }

    // NZ: The updateSearchHints function should be updated to use the new getSearchHintData function to retrieve the typeAhead
    // data at some point so the logic isn't duplicated. I'm leaving it as is for now though to prevent the need for retesting.
    function updateSearchHints($cnt, srch, $input, $alertCnt, clear) {
        //var $cnt = componentElement(this, '.type-ahead-results');
        var $lst = $cnt.find('ul');
        var $alert = ($alertCnt && typeof($alertCnt) != 'undefined' && $alertCnt.length > 0) ? $alertCnt : $cnt.find('.search-suggestions-info');
        //var srch = getSearchData.call(this);
        var def = $.Deferred();
        $cnt.hide();
        $lst.empty();
        // BRAND-21377: Updated logic below to continue to restrict values with < 2 characters AND postal codes from being passed
        // to the typeAhead service while removing the restrictions around the values that are passed during a dealer name
        // or city, state / province search.
        if (clear || (!srch.val || srch.val.length < 2) || (!srch.isDealer && ((/\d+/.test(srch.val)) || (/^(?=.*[a-zA-Z])(?=.*[0-9])/.test(srch.val))))) {
            toggleMarkup([]);
            return;
        }
        var util = FD.Brand && FD.Brand.Util,
            cCoords = {};
        if(util && util.env.geoLocation()) {
            cCoords = user.location.coordinates();
        }

        if(!srch.isDealer) {
            // search by location
            $.ajax({
                url: ctx.settings.mapSearch,
                dataType: 'jsonp',
                data: {
                    q: srch.val,
                    key: ctx.settings.mapKey
                },
                jsonp: 'jsonp',
                cache: true
            }).done(function(resp) {
                var locations,
                    results = [];
                if (resp.statusCode === 200 &&
                    resp.resourceSets &&
                    resp.resourceSets.length &&
                    (locations = resp.resourceSets[0]) &&
                    (locations = locations.resources)) {
                    locations = locations.filter(function(i) { return i.address && i.address.countryRegionIso2 === ctx.region; });

                    locations.slice(0, Math.min(locations.length, 5)).forEach(function(item) {
                        var hasCoordinates = (item.point && item.point.coordinates && item.point.coordinates.length),
                            resItem = {
                                name: item.name || '',
                                paCode: null,
                                location: {
                                    lat: (hasCoordinates) ? item.point.coordinates[0] : 1,
                                    lon: (hasCoordinates) ? item.point.coordinates[1] : 1
                                },
                                distance: {}
                            };

                        if(!brand.Util.isEmpty(cCoords)) {
                            var dist = util.distance.betweenCoords(cCoords.lat, cCoords.lon, resItem.location.lat, resItem.location.lon, true);
                            resItem.distance = Object.assign(resItem.distance, dist);
                        }

                        results.push(resItem);
                    });
                    //results = _.uniq(_.pluck(locations.slice(0, Math.min(locations.length, 5)), 'name'));
                }
                def.resolve(results);
            })
        } else {
            // search by dealer name
            var locateDealerServiceURI = '/searchservices/fd/';
            if (ctx.make === 'Ford') {
                locateDealerServiceURI = '/searchservices/fd/';
            } else if (ctx.make === 'Lincoln') {
                locateDealerServiceURI = '/searchservices/ld/';
            }
            $.ajax({
                url: locateDealerServiceURI,
                data: {
                    q: srch.val,
                    type: 'suggest_static'
                },
                callback: 'JSON_CALLBACK',
                method: 'GET',
                responseType: 'json',
                headers: {
                    'Application-id': ctx.settings.clientId
                },
                cache: true,
                timeout: 5000
            }).done(function(resp) {
                var locations,
                    results = [];
                if (resp.suggestions &&
                    resp.suggestions.length) {
                    results = def.resolve(
                        resp.suggestions.slice(0, Math.min(resp.suggestions.length, 5))
                            .map(function(suggestion) {
                                var locationParts = suggestion.split('+');
                                var resItem = {
                                    paCode: (locationParts[0]) ? locationParts[0] : '',
                                    name: (locationParts[1]) ? locationParts[1] : '',
                                    location: {
                                        city: locationParts[2],
                                        state: locationParts[3],
                                        lat: (locationParts[4]) ? parseFloat(locationParts[4]) : 1,
                                        lon: (locationParts[5]) ? parseFloat(locationParts[5]) : 1
                                    },
                                    distance: {}
                                };

                                if(!brand.Util.isEmpty(cCoords)) {
                                    var dist = util.distance.betweenCoords(cCoords.lat, cCoords.lon, resItem.location.lat, resItem.location.lon, true);
                                    resItem.distance = Object.assign(resItem.distance, dist);
                                }
                                return resItem;
                            })
                    );
                }
                def.resolve(results);
            });
        }
        def.promise().done(function(results) {
            toggleMarkup(results);
            $lst.empty();
            var index = 0;
            var distUnit = (ctx.region === 'CA') ? 'km' : 'mi';
            results.forEach(function(result) {
                $('<li id="fgx-brand-dealerSearchSuggestion' + index + '" class="result" tabindex="-1" role="option" aria-selected="false" data-fgx-keypress="true" data-pacode="' + result.paCode + '"><span><span class="result-name">' + result.name + '</span><span class="result-meta-wrap"><span class="result-location">' + ((result.location && result.location.city) ? ' (' +result.location.city + ', ' + result.location.state + ')' : '')  + '</span><span class="result-distance">' + ((!brand.Util.isEmpty(result.distance)) ? result.distance[distUnit] : '') + '</span></span></li>').appendTo($lst);
                index ++;
            });
            $cnt.toggle(results.length > 0);
            $input.toggleClass('fgx-list-shown', (results.length > 0));//BRAND-12331
            if (results.length <= 0) {
                $input.removeAttr('aria-activedescendant');
            }
            if (typeof $alert !== 'undefined' && results.length > 0) {
                // set alert text
                var templateTxt = $alert.data('label-template');
                if (templateTxt) {
                    $alert.text(templateTxt.replace('{count}', results.length));
                }
            } else if (typeof $alert !== 'undefined' && results.length <= 0) {
                $alert.text('');
            }
            $lst.find(".result").on('focusin', function(){
                $lst.find(".result").attr('aria-selected', 'false');
                $(this).attr('aria-selected', 'true');
                $input.attr('aria-activedescendant', $(this).attr('id'));
            }).on('keydown', function(ev){
                if (ev.shiftKey && ev.which === 9) {
                    //shift was down when tab was pressed...so refocus on the search input
                    $input.focus();
                    return false;
                } else if (ev.which === 27) {
                    //escape key was pressed...so refocus on the search input
                    $input.focus();
                    $cnt.hide();
                    $alert.text('');
                    $input.removeClass('fgx-list-shown');//BRAND-12331
                    $input.removeAttr('aria-activedescendant');
                    return false;
                }
            });
        });
    }

    function toggleMarkup(results) {// NGBS3-10835
        // .search-container needs set height on mobile map view for viewport height calculation and scrolling,
        // therefore cant expand .search-container to contain .advanced-search, so hide advanced search cta when there are type ahead results
        if(FD.Brand.Util.currentBreakpoint() === 'gux-bkpt-sm' && $(".dealer-standard.expanded").length){ //mobile and map view
            $("p.advanced").toggle(!(results.length > 0));
        }
    }

    function appendT3QS(url, mtAttrQS) {
        var output = '',
            qs = '',
            t3QueryString = ctx.t3DealerQueryString || '';
        //Append the T3 query string to qs if available and remove '?' if present
        if(!brand.Util.isEmpty(t3QueryString)) {
            if(t3QueryString.indexOf('?') > -1) {
                qs += t3QueryString.substring((t3QueryString.indexOf('?') + 1), t3QueryString.length);
            } else {
                qs += t3QueryString;
            }
        }
        // if a 'mt-attr-val' cookie is present, we will have a Query String value added to our dealer object, add it to qs
        if (mtAttrQS) {
            if (!brand.Util.isEmpty(qs)) {
                qs += '&';
            }
            qs += mtAttrQS;
        }
        // if qs is not empty, decode our params and add them to our URL, otherwise, leave the url as is.
        if(typeof(qs) != 'undefined' && qs !== '') {
            var _url = util.url.urlObject(url),
                param = util.parameters.decode(qs);
            _url.qs.add(param);
            output = _url.url();
        } else {
            output = url;
        }
        return output;
    }

    function getDealerConfig() {
        var cfg = brand.Component && brand.Component.locateDealerConfig || {};
        if (cfg) {
            var exitOvrs = brand.Link && brand.Link.exitOverlays,
                exitOvrId = cfg.exitOverlayId || '';
            cfg.hasExitOverlay = !!(exitOvrId && exitOvrs && typeof(exitOvrs[exitOvrId]) != 'undefined');
            cfg.exitOverlayCls = (cfg.hasExitOverlay) ? 'fgx-external-url-trigger' : '';
        }
        return cfg;
    }

})(window, jQuery, FD.Brand, FD.Brand.Context, FD.Brand.User, FD.Brand.Util);
/*global FD*/
/**
 * Metrics support library
 */
;(function(win, common, ctx) {

	// setup namespace
	common.assign(FD.Brand.namespace('FD.Brand.Metrics', win), {
		provider: metricsProvider,
		getParameter: getParameter,
		setParameter: setParameter,
		check: checkSetup,
		updateVehicle: updateVehicleData,
		getSegment: getSegment,
		getCommNameplate: getCommercialNameplate,
		spcFlags: {
		    set: setSpcFlag,
		    reset: resetSpcFlags,
		    tabDisplayed: checkSpcTabDisplayed
		},
		setInherited: setInheritedMetrics
	});

    var commNameplates = {
        US: {
            'transit connect commercial': 'transit connect-comm',
            'strippedchassis': 'stripped chassis-comm',
            'transit chassis': 'transit chassis-comm',
            'econoline cutaway': 'e-series cutaway-comm',
            'econoline chassis': 'e-series chassis-comm',
            'transit commercial': 'transit-comm',
            'chassis cab': 'chassis cab-comm',
            'superduty commercial': 'super duty-comm',
            'f-650-750': 'f-650-750-comm'
        },
        CA: {
            'transit connect commercial': 'transit connect-comm',
            'strippedchassis': 'stripped chassis-comm',
            'transit chassis': 'transit chassis-comm',
            'econoline cutaway': 'e-series cutaway-comm',
            'econoline chassis': 'e-series chassis-comm',
            'transit commercial': 'transit-comm',
            'chassis cab': 'chassis cab-comm',
            'superduty commercial': 'super duty-comm',
            'f-650-750': 'f-650-750-comm',
            'f-150 commercial': 'f-150-comm'
        }
    };

    var spcTabDisplayed = {
        'finance': false,
        'lease': false,
        'purchase': false
    };

    var brochuresTabs = {
        'brochures': 'brochures',
        'guides': 'guides',
        'manuals': 'manuals'
    };

    var _nameplatesData = ctx && ctx.nameplatePricing || [];

	var metricsData = {
		'user_loginStatus': isLoggedIn(),
		'page_radUIVersion': function() {
		    win.radUIVersion = getRadUIVersion();
		    return win.radUIVersion;
		},
		'page_pageDomain': getDomainName(),
		'page_experienceType': experienceType(),
		'page_pageFormType': '', // gets set after DOMContentLoaded
		'page_pageFormCount': '', // gets set after DOMContentLoaded
		'page_userLanguage': {'en': 'eng', 'es': 'esp', 'fr': 'fr'}[ctx.language || 'en'],
		'page_siteSearchString': '',
		'page_client': {
		    USFord: 'ford-us',
		    USLincoln: 'lincoln',
		    CAFord: 'ford-canada',
		    CALincoln: 'canada'
		}[ctx.region + ctx.make],
		'page_site': {
		    USFord: 'fordvehicles.com',
		    USLincoln: 'lincoln.com',
		    CAFord: 'ford.ca',
		    CALincoln: 'lincolncanada.com'
		}[ctx.region + ctx.make],
		'vehicle_modelYear': ctx.nameplate && ctx.nameplate.ngpYear,
		'vehicle_nameplate': ctx.nameplate && (ctx.make + ' ' + (ctx.nameplate.metricsName || ctx.nameplate.ngpModelName)).toLowerCase(),
		'vehicle_bodyModelTrim': ctx.model && ctx.model.ngpTrimName,
		'$sitePrefix': {
			USFord: 'fv',
			USLincoln: 'ln',
			CAFord: 'foc',
			CALincoln: 'lnc'
		}[ctx.region + ctx.make],
		'$make': ctx.make && ctx.make.toLowerCase(),
		'$nameplate': ctx.nameplate && (ctx.nameplate.metricsName || ctx.nameplate.ngpModelName).toLowerCase(),
		'$modelYear': ctx.nameplate && ctx.nameplate.ngpYear,
		'$segment': ctx.nameplate && ctx.nameplate.segment,
		'$$dealerPrefix':'dd',
		'$$brochuresTab': 'brochures'
	};


	win.radUIVersion = getRadUIVersion();

	if (sessionStorage['fgx-lad-ownerCtx']) {
	    metricsData.$$dealerContext = 'owner';
	    metricsData.$$dealerPrefix = 'flmo';
    }

    var activeAnchor = anchorCheck();
    if(activeAnchor !== '') {
        metricsData.$$brochuresTab = brochuresTabs[activeAnchor.toLowerCase()] || 'brochures';
    }

	init();

	//////

	function init() {
		common.ready(function() {
			var user = win.FD.Brand.User;
			user.authentication.subscribe(function(state) {
				metricsData['user_loginStatus'] = (state.authType === 'user') ? 'logged in' : 'logged out';
			});
			user.location.subscribe(function() {

				user.location.detail().done(function(detail) {
					if(detail) {
						var regionData = {};
						if(detail.regions) {
							common.assign(metricsData, {
								'user_fdafCode': (ctx.make === 'Lincoln') ? detail.regions.LMDA : detail.regions.FDAF,
								'user_fordRegion': detail.regions.Marketing
							});

							regionData['Marketing'] = detail.regions.Marketing;
							regionData['FDAF'] = detail.regions.FDAF;
							regionData['LMDA'] = detail.regions.LMDA;
						}

						regionData['zip'] = (user.location.current() && user.location.current().postalCode) ? user.location.current().postalCode : "";
						regionData['PACode'] = (detail.paCode) ? detail.paCode : "";
						setRegionsCookie(regionData);
					}
				});
			});
		});

	}

	function metricsProvider(name) {
		if(name in metricsData) {
			var val = metricsData[name];
			return (typeof val === 'function') ? val() : val;
		}
	}

	function getParameter(name) {
		return metricsData[name];
	}

	function setParameter(name, val) {
		metricsData[name] = val;
	}

	function checkSetup() {
		if(!(win.FD && FD.Common && FD.Common.Metrics && FD.Brand.Metrics.handler)) {
			// no plan registered, stub out handler
			var noop = function() {};
			FD.Brand.Metrics.handler = {
				page: noop,
				direct: noop,
				data: noop
			};
		}
	}

	function getCommercialNameplate(nameplate) {
	    var commNp = commNameplates[ctx.region][nameplate];
	    return commNp || nameplate || '';
	}

	function getSegment(nameplate, year) {
        var segment = null;
        if (isNameplateDefined(nameplate)) {
            var np = (nameplate || metricsData.$nameplate || '').trim(),
                yr = year || metricsData.$modelYear,
                npData = getNameplateData(np, yr);
            if (npData && npData.seg) {
                segment = npData.seg;
            }
        }
        return segment;
    }

    function isNameplateDefined(nameplate) {
        return !!(nameplate || metricsData.$nameplate || metricsData['vehicle_nameplate'] || (ctx.nameplate && (ctx.nameplate.metricsName || ctx.nameplate.ngpModelName)));
    }

	function updateVehicleData(make, model, year, metricsName, segment) {
	    if(!make || !model || !year) {
	        return;
	    }
	    var _make = make.toLowerCase(),
	        _model = model.toLowerCase(),
	        npData = getNameplateData(model, year),
	        mtxName = metricsName || npData && npData.mnp || _model,
	        mtxSeg = segment || npData && npData.seg;

	    setParameter('vehicle_nameplate', _make + ' ' + mtxName);
	    setParameter('vehicle_modelYear', year);
	    setParameter('$make', _make);
	    setParameter('$nameplate', mtxName);
	    setParameter('$modelYear', year);
	    //MTX-14431 - set segment to null if mtxSeg isn't defined so any previous segment value is cleared out.
        setParameter('$segment', mtxSeg || null);
	}

	function getNameplateData(_model, _year) {
	    var npData = {};
	    if (_model && _year) {
	        _model = _model.toLowerCase();
	        npData = _nameplatesData.find(function(i) { return (i.model || '').toLowerCase() === _model && i.year === _year; });
	    }
	    return npData;
	}

	function checkSpcTabDisplayed(tabName) {
	    return spcTabDisplayed[tabName] || false;
	}

	function resetSpcFlags() {
        spcTabDisplayed.finance = false;
        spcTabDisplayed.lease = false;
        spcTabDisplayed.purchase = false;
    }

    function setSpcFlag(tabName, value) {
        spcTabDisplayed[tabName] = value;
    }

    function setRegionsCookie(prop) {
        var util = FD.Brand && FD.Brand.Util;
        var ck = util.cookie.get('regions');
        var p = (ck) ? util.parameters.decode(ck) : { };
        var domain = ctx.settings['siteCookieDomain' + ctx.make];
        p = common.assign(p, prop);
        util.cookie.set('regions', util.parameters.encode(p), {
            path: '/',
            domain: ((domain || '') == '') ? null : domain,
            expires: 65
        });
    }

	function createCookie(name,value,days) {
		let expires = '';

		if (days) {
			const date = new Date();
			const time = date.getTime() + (days * 86400000); // 24*60*60*1000
			
			date.setTime(time);

			expires = `expires=${date.toUTCString()}`;
		}

		const hostnameArray = win.location.hostname.split('.').reverse();
		const cookieName = `${name}=${value}`;
		const cookieDomain = `${hostnameArray[1]}.${hostnameArray[0]}`;

		document.cookie = `${cookieName}; ${expires}; path=/; ${cookieDomain};`;
	}

	function readCookie(name) {
		var nameEQ = name + "=";
		var ca = document.cookie.split(';');
		for(var i=0;i < ca.length;i++) {
				var c = ca[i];
				while (c.charAt(0)==' ') c = c.substring(1,c.length);
				if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
		}
		return null;
	}

	function isLoggedIn() {
		const loginStatusStr = 'loginStatus';
		const loggedOutStr = 'logged out';
		const loggedInStr = 'logged in';
		const hasLogoutCookie = document?.cookie?.includes('fma_YmFuYW5h=');
		const hasLoginCookie = document?.cookie?.includes('fma_ZnJhZ21lbnREYXRh=');

		if (hasLogoutCookie) createCookie(loginStatusStr, loggedOutStr, 1);
		if (hasLoginCookie) createCookie(loginStatusStr, loggedInStr, 1);

		const loginStatus = readCookie(loginStatusStr);

		if (!!loginStatus) return loginStatus;

		return loggedOutStr;
	}


    function getRadUIVersion() {
        var width = win.innerWidth;
        return 'ui:rad:' +
            ((width < 768) ? 'mobile' : ((width < 992) ? 'tablet' : 'pc'));
    }

	function experienceType() {
		const bp = win.innerWidth;
		if (bp < 768) {
			return 'mobile';
		} else if (bp < 992) {
			return 'tablet';
		} else {
			return 'desktop';
		}
	}
	// Metrics form tagging
	function updateMetricsFormTagging () {
		win.digitaldata = win.digitaldata || {};
        win.digitaldata.page = win.digitaldata.page || {};
        
        const quoteAndTestDriveSmartLinksCount = getPageFormCount();
        
        if (quoteAndTestDriveSmartLinksCount) {
            win.digitaldata.page.pageFormType = getPageFormType();
            win.digitaldata.page.pageFormCount = String(quoteAndTestDriveSmartLinksCount);
            win.digitaldata.events = {
                ...win?.digitaldata?.events,
                "events": "page form cta impression"
            };
        } else {
            delete win.digitaldata.page.pageFormType;
            delete win.digitaldata.page.pageFormCount;
        }
	}

	function isElementVisible(element) {
		let parent = element;
		
		while (parent) {
			if (parent.classList && (
				parent.classList.contains('hidden') ||
				parent.classList.contains('d-none') ||
				parent.classList.contains('hide')
			)) {
				return false;
			}

			// inline styles
			if (parent.style.display === 'none' || parent.style.visibility === 'hidden') {
				return false;
			}
			
			// getComputedStyle is most expensive, do it last
			const style = window.getComputedStyle(parent); // css styles
			if (style.display === 'none' || style.visibility === 'hidden') {
				return false;
			}
			
			parent = parent.parentElement;
		}
		
		return true;
	}

	function getQuoteAndTestDriveSmartLinks() {
		// Only query for quote and testdrive smartlinks, excluding header, footer, and my-list-overlay
		const smartLinks = document.querySelectorAll(
			'a[href^="#$iqq"]:not(.fordMainNavigationR23 *):not(.globalFooter *):not(.my-list-overlay *), ' +
			'a[href^="#$quote"]:not(.fordMainNavigationR23 *):not(.globalFooter *):not(.my-list-overlay *), ' +
			'a[href^="#$testdrive"]:not(.fordMainNavigationR23 *):not(.globalFooter *):not(.my-list-overlay *), ' +
			'a[href^="#$schedulemodele"]:not(.fordMainNavigationR23 *):not(.globalFooter *):not(.my-list-overlay *), ' +
			'a[href^="#$testdrivev2"]:not(.fordMainNavigationR23 *):not(.globalFooter *):not(.my-list-overlay *)'
		);
		
		const mappedSmartLinks = {
			'testdrive': 'td',
			'testdrivev2': 'td',
			'schedulemodele': 'td',
			'iqq': 'qrfq',
			'quote': 'qrfq'
		}

		return Array.from(smartLinks)
			.filter(link => {
				if (!isElementVisible(link)) return false;

				const kbaItem = link.closest('.kba-item');
				// If not in kba-item, keep it
				if (!kbaItem) return true;
				
				// Only apply special handling to kba-items with our specific smartlinks
				const hasSmartLink = link.getAttribute('href').startsWith('#$iqq') || 
									link.getAttribute('href').startsWith('#$quote') ||
									link.getAttribute('href').startsWith('#$testdrive') ||
									link.getAttribute('href').startsWith('#$schedulemodele') ||
									link.getAttribute('href').startsWith('#$testdrivev2');
									
				if (!hasSmartLink) return true;
				
				// Only keep the first link from kba-items that have our smartlinks
				return link === kbaItem.querySelector('a');
			})
			.map(link => {
				const href = link.getAttribute('href').substring(2); // Remove '#$'
				const exactMatch = mappedSmartLinks[href];
				if (exactMatch) return exactMatch;

				const baseHref = href.split(/[/?]/)[0]; // Get string before any '/' or '?'
				return mappedSmartLinks[baseHref] || baseHref;
			});
	}

	function getPageFormType() {
		const smartLinks = getQuoteAndTestDriveSmartLinks();
		
		if (smartLinks.length === 0) {
			return '';
		}
		
		// Start with 'brand' and add each smartlink separated by ':'
		return 'brand:' + smartLinks.join(':');
	}

	function getPageFormCount() {
		return getQuoteAndTestDriveSmartLinks().length;
	}
// end of Metrics form tagging

	function getDomainName() {
		const domain = window.location.origin;
		return domain;
	}

    function anchorCheck() {
        var anchorId = win.location.hash,
            anchor = '';
        if (anchorId) {
            anchor = anchorId.substr(1).trim();
        }
        return anchor;
    }

    /**
     * Inherit metrics from a container to a child element based on the data passed in the cfg object.
     * cfg.container (required): Either a selector or a jQuery object indicating the container elements where the metrics should be inherited from
     * cfg.inheritList (required): An array of objects that define the inherit behavior between the metrics on the container and child elements.
     *
     * Each object within cfg.inheritList is required to include the following:
     * selector: The selector that should be used to determine which child elements the metric should be applied to.
     * containerAttr: The name of the attribute on the container element that holds the value of the metric to be inherited.
     * childAttr: The name of the attribute on the child element that the metric should be stored in. This attribute is only created on the child if it doesn't already exist on the element
     */
    function setInheritedMetrics(cfg) {
        try {
            if (cfg && cfg.container) {
                var util = win.FD.Brand && win.FD.Brand.Util || {},
                    inheritList = util.toArray(cfg.inheritList || []);
                if (!inheritList || inheritList.length === 0 ) {
                    return;
                }
                $(cfg.container).each(function() {
                    var $cnt = $(this);
                    inheritList.forEach(function(itm, idx) {
                        var cntMtx = $cnt.attr(itm.containerAttr || '') || '';
                        if (cntMtx && itm.selector && itm.childAttr) {
                            $cnt.find(itm.selector).not('[' + itm.childAttr + ']').not('[data-fd-metrics-skip-inherit]').attr(itm.childAttr, cntMtx);
                        }
                    });
                });
            }
        } catch(ex) {
            console.log("MetricsLib::setInheritedMetrics - error occurred initializing inherited metrics. ", ex);
        }
    }
	
	

    win.addEventListener('load', updateMetricsFormTagging);

})(window, FD.Common, FD.Brand.Context);

(function (win, context) {

	"use strict";
    try {
        jQuery(function() {
	        FD.Brand.Metrics.check(!!context.legacyMetrics);
        });
    } catch(err) {
        console.log("Unable to set legacyDtm for Syndicated components-->"+err.message);
    }

    win.digitaldata = win.digitaldata || {
	    page: {},
	    vehicle: {},
	    onclick: {},
	    video: {},
	    user: {},
	    event: {}
    };

})(window, FD.Brand.Context);

