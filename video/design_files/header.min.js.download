;(function($, brand, user, pricing, search, ctx, dealerLib, ngp, rno) {

    var components,
        _layoutKey = 'desktop',
        _ladInitialized = false,
        _ladData = {},
        _dealerItemTemplate = null,
        _flyoutData = {
            isActive: false,
            activeType: '',
            activeOvr: null
        },
        _dskOvrIdx = 0,
        _dskOvrAttr = 'data-fgx-fordMainNav-flyout-id',
        _dskOvrIdPrefix = 'fgx-fordMainNav-flyout-',
        _dskOverlays = {},
        _mobileMenuOvr = {
            isOpen: false,
            focusElements: 'a:not([tabindex="-1"]):visible, input:visible, button:visible, [data-fgx-keypress]:visible',
            skipLastFocus: false
        },
        _searchInst = {},
        _isNonSticky = false;

    brand.setInitHandler('[data-fgx-ford-main-navigation]', init);

    function init(_components) {

        if (!_components || _components.length == 0) {
            return;
        }
        components = _components;

        if (ctx) {
            if(ctx.hideGlobalHeader) {
                $(components).addClass('fgx-brand-hidden');
            }
            if (ctx.settings && ctx.settings.syn && components.hasClass('with-eyebrow')) {
                $('html').addClass('fgx-brand-syn-eyebrow');
            }
        }

        var mql = window.matchMedia('(min-width: 992px)'),
            mtxActions = ctx && ctx.mtxActions,
            languageSelectorOverlayOpenAction = mtxActions && mtxActions.languageSelectorOverlayOpenAction || null,
            defaultAction = "//www.ford.com/search/",
            formAction = ctx.settings['ngbsSearchUrl' + ctx.make + ctx.languageKey] || ctx.settings['ngbsSearchUrl' + ctx.make] || defaultAction,
            $resultsContainer = $('.search-suggestions', components),
            $navbarToggle = $('.navbar-toggle', components),
            $bgOverlay = $('.fordMainNavOverlay'),
            _hasSecondaryNav = ($('.secondaryNavigation').length > 0 || $('.cmp-secondaryNavigation').length > 0 || $('.secondaryNavigationR23').length > 0),
            notificationsEnabled = (($(components).attr('data-notification-enabled') || '') === 'yes'),
            $body = $('body'),
            navHeight = components.outerHeight(),
            _dynamDisplayOnScroll = ((components.attr('data-dynamic-scroll-display-enabled') || '') === 'true'),
            _forceNoDynamDisplay = false,
            _cartEnabled = ((components.attr('data-cart-enabled') || '') === 'true');

        _isNonSticky = _hasSecondaryNav;

        _mobileMenuOvr.lastFocus = $navbarToggle;
        _mobileMenuOvr.$el = $('.menu-items-container', components);
        _mobileMenuOvr.hide = function() {
            toggleMobileMenu.call($navbarToggle);
        };
        _mobileMenuOvr.$firstToggle = _mobileMenuOvr.$el.find('.flyout-toggle').first();

        $('.flyout-toggle:not(.flyout-mbl-only)', components).each(function() {
            setupOvrItem($(this));
        });

        $(document).on('brandnav:setnonsticky', function(ev) {
            brand.Util.log("fordMainNavigation - brandnav:setnonsticky handler triggered");
            _isNonSticky = true;
            $('.navbar-static-top', components).toggleClass('nonsticky', true);
        });

        mql.addListener(handleResize);
        handleResize(mql);

        brand.Dig.resolve(components);

        components.each(function() {
            pricing.refresh(this);
        });

        user.authentication.subscribe(setUserMenuState);
        user.dealer.subscribe(setDealerDetail);

        // cart state logic
        if (_cartEnabled) {
            setCartState();
        }

        // Server-Side Current Page object will not work on rewritten Publish URLs - handling this via JS.
        var relativeLoc = '/' + window.location.href.replace(/^(?:\/\/|[^\/]+)*\//, "");
        $('.eyebrow-item', components).each(function() {
            var $el = $(this),
                href = $el.attr('href');
            if (href === relativeLoc || href === window.location.href) {
                $el.addClass('active');
            }
        });

        // search form
        $('.fgx-search-input', components).each(function(idx) {
            var id = 'fgx-mainNav-search-' + idx;
            _searchInst[id] = searchController($(this), formAction, id, search);
        });


        // Event Handlers
        $('.flyout-item-wrap', components).on('focusin', '.fgx-brand-nav-flyout-end', function(ev) {
            var $focusEl = $(this).closest('.flyout-item-wrap').find('.flyout-toggle');
            updateFocus($focusEl);
        });

        $('.menu-items-container', components).on('focusin', '.fgx-brand-nav-mobile-menu-end', function(ev) {
            if (_layoutKey === 'mobile') {
                var $focusEl = $('.mbl-menu-close', components);
                updateFocus($focusEl);
            }
        });

        $('.navbar-toggle, .mbl-menu-close', components).on('click', function() {
            toggleMobileMenu.call($navbarToggle);
        });

        $('.mbl-menu-close', components).on('focusin focusout', function(ev) {
            $navbarToggle.toggleClass('fgx-focus-display', (ev.type === 'focusin'));
        });

        $('.flyout-toggle', components).on('click', function(ev) {
            ev.preventDefault();
            // I don't believe this is needed but commenting out just in case. - ev.stopPropagation();
            handleFlyoutToggle.call(this);
        });

        $('.column-vehicle-item', components).on('click', '.year-item-toggle', function(ev) {
            var $el = $(this),
                activeClass = $el[0].value || 'active-veh-1',
                $tile = $el.closest('.vehicle-tile');
            $tile.toggleClass('active-veh-1 active-veh-2', false).addClass(activeClass);
        });

        $('.segment-anchor-trigger', components).on('click', function(ev) {
            var $el = $(this),
                segId = $el.attr('data-fgx-section-id') || '',
                $container = $el.closest('.flyout-container'),
                $segItem = (segId) ? $container.find('#' + segId) : null;
            
            $('.segment-anchor-trigger', components).removeClass('open');
            $el.addClass('open');
            
            if ($segItem && $segItem.length > 0) {
                $container.animate({
                    scrollTop: $segItem.position().top
                }, 200, function() {
                    $segItem.toggleClass('fgx-show-outline', true)
                            .focus()
                            .one('blur.fgxFordMainNav', function() {
                                $(this).toggleClass('fgx-show-outline', false);
                            });
                });
            }
        });

        // language links
        $('.fgx-lang-link', components).on('click', function(ev) {
            if(FD.Brand.Link.switchLanguage(this)) {
                ev.preventDefault();
            }
        });

        // Initialize dynamic scrolling functionality when enabled
        if (_dynamDisplayOnScroll) {
            if (!_isNonSticky) {
                // we're on a brand page that doesn't have the secondary navigation, so setup the dynamic scrolling functionality.
                setupScrollHandling(window);
            }
            $(document).on('brandnav:nodynamicscroll', function(ev) {
                brand.Util.log("fordMainNavigation - brandnav:nodynamicscroll handler triggered");
                disableScrollListener(window);
                _forceNoDynamDisplay = true;
            });
        }


        // Functions
        function isElValid($el) {
            return ($el && $el.length > 0) || false;
        }

        function updateFocus($focusEl) {
            if ($focusEl && $focusEl.length > 0) {
                $focusEl.focus();
            }
        }

        function setupOvrItem($el) {
            if (!$el || $el.length === 0) {
                return;
            }
            var _id = _dskOvrIdPrefix + ++_dskOvrIdx,
                $toggle = $el.attr(_dskOvrAttr, _id),
                $flyoutWrap = $toggle.closest('.flyout-item-wrap').attr(_dskOvrAttr, _id),
                _ovr = {
                    id: _id,
                    $el: $flyoutWrap,
                    lastFocus: $toggle,
                    focusElements: 'a:not([tabindex="-1"]):visible, input:visible, button:visible, [data-fgx-keypress]:visible',
                    skipLastFocus: false,
                    hide: function(...args) {
                        handleFlyoutToggle.call($toggleEl[0], ...args);
                    }
                };
            _dskOverlays[_ovr.id] = _ovr;
        }

        function handleBodyClick(ev) {
            // clicking outside the main nav or within the mainNav but outside of dropdown items should close nav dropdowns
            // and remove the overlay
            var $target = $(ev.target);
            if ($target.hasClass('fordMainNavOverlay') || ($target.closest('.fordMainNavigation').length && !$target.closest('.flyout-toggle, .flyout-container, .navbar-toggle').length)) {
                // Hide the current opened flyout
                closeFlyoutMenus();

                // on mobile this click handler can be called to close the flyouts without actually closing the mobile
                // menu so we want to prevent the nonsticky class from being added in the case because it will override the
                // position: fixed that is used for the mobile menu.
                if (_isNonSticky && _layoutKey !== 'mobile') {
                    components.find('.navbar-static-top').toggleClass('nonsticky', true);
                }
            }
        }

        function toggleMobileMenu() {
            var $el = $(this),
                $container = $el.closest('.container-fluid'),
                $menuItems = $container.find('.menu-items-container'),
                isOpen = $menuItems.hasClass('opened');

            $menuItems.toggleClass('opened', !isOpen);
            $el.toggleClass('opened', !isOpen);
            $el.attr('aria-expanded', !isOpen);
            $('body').toggleClass('no-scroll-sm', !isOpen);

            // clear any search input if it exists
            $('.fgx-search-input', components).val('');

            if (_isNonSticky) {
                $el.closest('.navbar-static-top').toggleClass('nonsticky', isOpen);
            }

            if (isOpen) {
                // if isOpen is true here, then the mobile menu is actually being closed.
                closeFlyoutMenus();
                FD.Brand.Overlay.releaseFocus(_mobileMenuOvr);
            } else {
                FD.Brand.Overlay.trapFocus(_mobileMenuOvr, _mobileMenuOvr.focusElements, null, _mobileMenuOvr.lastFocus, false);
                handleFlyoutToggle.call(_mobileMenuOvr.$firstToggle[0]);
            }

            _mobileMenuOvr.isOpen = !isOpen;
        }

        function handleFlyoutToggle() {
            var $el = $(this),
                $flyoutGroup = $el.closest('[data-fgx-flyout-group]');

            if (canActivateToggle($el)) {
                var layoutSelector = (_layoutKey === 'mobile') ? '' : ':not(.flyout-mbl-only)';
                var hSelector = '.flyout-toggle' + layoutSelector;
                var cSelector = '.flyout-container' + layoutSelector;

                $(components).toggleClass('no-transition-dsk', dskPreventTransitionCheck($el));
                $('.segment-anchor-trigger', components).toggleClass('open', false);

                if (_flyoutData.isActive && _layoutKey === 'desktop') {
                    var newId = $el.attr(_dskOvrAttr) || '',
                        activeOvr = _flyoutData.activeOvr || {};
                    if (newId && activeOvr && activeOvr.id && activeOvr.id !== newId) {
                        // If a different flyout is already open then releaseFocus from that flyout without updating the lastFocus
                        // position. Note, the accordion.update call below will actually handle the logic to close the active flyout.
                        activeOvr.skipLastFocus = true;
                        FD.Brand.Overlay.releaseFocus(activeOvr);
                        activeOvr.skipLastFocus = false;
                    }
                }

                brand.Util.accordion.update($el, $flyoutGroup, hSelector, cSelector, true, function() {
                    var $el = $(this),
                        isOpen = $el.hasClass('open'),
                        id = $el.attr(_dskOvrAttr) || '',
                        invisibleBg = isOpen && $el.hasClass('fgx-no-bg-ovr');

                    _flyoutData.isActive = (isOpen);
                    _flyoutData.activeType = (isOpen) ? ($el.attr('data-flyout-type') || '') : '';

                    if (_layoutKey === 'desktop' && id && !brand.Util.isEmpty(_dskOverlays[id] || {})) {
                        var _ovr = _dskOverlays[id];
                        if (isOpen) {
                            FD.Brand.Overlay.trapFocus(_ovr, _ovr.focusElements, '.flyout-toggle', _ovr.lastFocus, false);
                            _flyoutData.activeOvr = Object.assign({}, _ovr || {});
                        } else {
                            _flyoutData.activeOvr = null;
                            FD.Brand.Overlay.releaseFocus(_ovr);
                        }
                    } else {
                        _flyoutData.activeOvr = null;
                    }

                    $bgOverlay.toggleClass('open', isOpen).toggleClass('fgx-invisible-bg', invisibleBg);

                    $body.off('click.fgxMainNav', handleBodyClick);
                    if (isOpen) {
                        $body.on('click.fgxMainNav', handleBodyClick);
                    }

                    // On mobile the flyouts can be closed without actually closing the main mobile menu, so we want
                    // to prevent the nonsticky class from being added in that case because it will override the position: fixed
                    // that is used for the mobile menu.
                    if (_isNonSticky && _layoutKey !== 'mobile') {
                        $el.closest('.navbar-static-top').toggleClass('nonsticky', !isOpen);
                    }
                });
            }
        }

        function canActivateToggle($el) {
            return !!($el && $el.length > 0 && (!$el.hasClass('.flyout-mbl-only') || _layoutKey === 'mobile'));
        }

        function getActiveFocusTrappedOvr() {
            return _flyoutData.activeOvr || {};
        }

        function hasActiveFocusTrappedOvr() {
            return (_flyoutData.isActive && !brand.Util.isEmpty(getActiveFocusTrappedOvr()));
        }

        function updatePresentationElms() {
            var $presElms = $('.presentation-only-lg', components);
            var onDsk = (_layoutKey === 'desktop');
            var bpKey = (onDsk) ? 'dsk' : 'mbl';
            if ($presElms && $presElms.length) {
                $presElms.attr('role', (onDsk) ? 'presentation' : null);
            }
            $('[data-role-cfg]', components).each(function() {
                var $el = $(this),
                    roleCfg = null;
                try {
                    roleCfg = JSON.parse($el.attr('data-role-cfg') || '{ }');
                } catch(e) { }
                // logic below will set the role attribute to the provided value for the bp, or remove the role attribute if no value is provided.
                $el.attr('role', roleCfg && roleCfg[bpKey] || null);
            });
        }

        function updateFlyoutAttributes() {
            var onDsk = (_layoutKey === 'desktop'),
                hSelector = '.flyout-toggle.flyout-mbl-only',
                cSelector = '.flyout-container.flyout-mbl-only' + ((onDsk) ? '' : ':not(.open)');

            $(cSelector, components).toggleClass('hidden', !onDsk);
            $('.vehicles-nav-items', components).attr('data-fgx-flyout-group', ((onDsk) ? null : 'true'));

            if (onDsk) {
                $(hSelector, components).attr('aria-expanded', null);
            } else {
                $(hSelector, components).each(function() {
                    var $el = $(this);
                    $el.attr('aria-expanded', $el.hasClass('open') ? 'true' : 'false');
                });
            }
        }

        function closeFlyoutMenus() {
            var layoutSelector = (_layoutKey === 'mobile') ? '' : ':not(.flyout-mbl-only)';
            var hSelector = '.flyout-toggle.open' + layoutSelector;
            var cSelector = '.flyout-container.open' + layoutSelector;

            $(hSelector, components).removeClass('open').attr('aria-expanded', 'false');
            $(cSelector, components).removeClass('open').addClass('hidden');
            $('.segment-anchor-trigger', components).toggleClass('open', false);

            if (hasActiveFocusTrappedOvr()) {
                FD.Brand.Overlay.releaseFocus(getActiveFocusTrappedOvr());
            }
            _flyoutData.activeOvr = null;
            _flyoutData.isActive = false;
            _flyoutData.activeType = '';
            $bgOverlay.toggleClass('open fgx-invisible-bg', false);
            $body.off('click.fgxMainNav', handleBodyClick);
        }

        // User Menu
        function setUserMenuState(authState) {
            // hide entire li element if auth is not loaded
            var $menuItem = $('.user-menu-item', components).toggleClass('hidden', !authState.loaded);
            var $authItems = $menuItem.find('[data-auth]').addClass('hidden');
            var $currentAuthItems = $authItems.filter('[data-auth~="' + authState.authType + '"]').toggleClass('hidden', false).not('[data-auth-icon]');

            if(authState && authState.authType == 'user') {
                user.profile.current().then(function(profileState) {
                    var firstName = profileState && profileState.firstName || '';
                    $currentAuthItems.each(function() {
                        var $el = $(this),
                            itemTemplate = ($el.attr('data-fgx-item-template') || $el.text() || '').trim(),
                            val = itemTemplate.replace('{firstName}', firstName);
                        $el.find('.link-text').html(val);
                    });
                });
            }

            var $notificationListItems = $currentAuthItems.find('[data-notification-item]');
            checkNotifications($notificationListItems);
        }

        // Notifications
        function checkNotifications($listItems) {
            if (notificationsEnabled && isElValid($listItems)) {
                var $notifyGlobalItems = components.find('[data-notification-item="all"]'),
                    _promises = [],
                    hasNotification = false,
                    notifyItemsCfg = [{
                        $items: $listItems.filter('[data-notification-item="saved-vehicle"]'),
                        method: user.fps.notification.getAll,
                        showAlert: function(data) {
                            return !!(data && data.bsrCallSuccess && data.SavedVehicleCount && data.SavedVehicleCount.total > 0);
                        }
                    }, {
                        $items: $listItems.filter('[data-notification-item="reserve-order"]'),
                        method: rno.getOrderStatus,
                        showAlert: function(data) {
                            return !!(data && data.bsrCallSuccess && (['RCO', 'RNO', 'ONIP', 'OIP', 'SHIPPED', 'ARRIVED'].indexOf(data.statusCode || '') > -1));
                        }
                    }],
                    handleNotifyResp = function($items, showAlert) {
                        $items.toggleClass('hidden', !showAlert);
                        if (showAlert) {
                            hasNotification = true;
                        }
                    };

                notifyItemsCfg.forEach(function(item) {
                    if (item && isElValid(item.$items)) {
                        // Use Util.alwaysResolve method to ensure the promise returned by the API call is resolved (even
                        // if the call fails) so that the $.when logic below does not fail prematurely if one of the API calls fails.
                        _promises.push(brand.Util.alwaysResolve(item.method).then(function(data) {
                            handleNotifyResp(item.$items, item.showAlert(data));
                        }));
                    }
                });

                // Update the display of the global notification items after completing our check for notifications from all active types.
                $.when.apply($, _promises).always(function() {
                    $notifyGlobalItems.toggleClass('hidden', !hasNotification);
                });
            }
        }

        function initDealerData() {
            var $nav = $(components),
                _ladConfig = dealerLib.getDealerConfig() || {},
                savedDealerEnabled = $nav.attr('data-saved-dealer-enabled') || '',
                savedDealerGnav = $nav.attr('data-saved-dealer-gnav') || '',
                moreDealersLink = $nav.attr('data-lad-moredealershref') || '',
                moreDealersLinkSavedGnav = moreDealersLink,
                $dealerItemEl = $nav.find('.fgx-lad-item');

            if (moreDealersLink) {
                moreDealersLinkSavedGnav = appendQueryString(moreDealersLink, savedDealerGnav);
            }

            var data = {
                ladConfig: _ladConfig,
                showSavedDealer: (savedDealerEnabled == 'yes') ? true : false,
                distanceLabel: $nav.attr('data-lad-distance-label') || '',
                distanceTypeKey: (ctx.region === 'CA') ? 'DistanceKM' : 'Distance',
                noDealerGnav: $nav.attr('data-no-dealer-gnav') || '',
                savedDealerGnav: savedDealerGnav,
                dealerAppContext: $nav.attr('dealerAppContext') || '',
                suppressDealerHours: _ladConfig && _ladConfig.suppressDealerHours || false,
                salesOpenUntil: $nav.attr('data-lad-sales-open-until') || '',
                salesOpenAgain: $nav.attr('data-lad-sales-open-again') || '',
                hoursDisplayType: $nav.attr('data-lad-hours-displaytype') || '',
                dealerDetailLink: _ladConfig && _ladConfig.dealerDetailPageUrl || '',
                detailLinkDestination: $nav.attr('data-lad-detail-link-destination') || 'dealer-details',
                ratingLinkDestination: $nav.attr('data-lad-rating-link-destination') || 'dealer-details',
                detailClickAction: $nav.attr('data-dealer-detail-click-action') || '',
                detailAriaLabelTmpl: $nav.attr('data-lad-detail-aria-label') || '',
                moreDealersLink: moreDealersLink,
                moreDealersLinkSavedGnav: moreDealersLinkSavedGnav,
                hideDealerRatings: _ladConfig && _ladConfig.hideDealerRatings || false,
                starAriaLabelTmpl: $nav.attr('data-lad-star-aria-label') || '',
                ratingsAriaLabelTmpl: $nav.attr('data-lad-ratings-aria-label') || '',
                chatAriaLabelTmpl: $nav.attr('data-lad-chat-aria-label') || '',
                directionsAriaLabelTmpl: $nav.attr('data-lad-directions-aria-label') || '',
                textDealerAriaLabelTmpl: $nav.attr('data-lad-text-dealer-aria-label') || '',
                $ladItemEl: $dealerItemEl
            };

            $dealerItemEl.on('click', '.dealer-rating .dealer-rating-iball', function(event) {
                event.preventDefault();
                event.stopImmediatePropagation();
                if (FD.Brand.Overlay) {
                    FD.Brand.Overlay.show('dealerRatingsInfo', true, $(this));
                }
            });

            // Update LAD urls to include proper gnavparameter
            $('.dealer-gnav-update', components).each(function() {
                var href = $(this).attr('href');
                if(href) {
                    href = appendQueryString(href, data.noDealerGnav);
                    $(this).attr('href', href);
                }
            });

            _ladData = Object.assign({}, _ladData, data);
            _dealerItemTemplate = brand.Util.template($('script[data-fgx-main-nav-saved-dealer-item]').html());
            _ladInitialized = true;
        }

        function setDealerDetail(dealerState) {
            if (!_ladInitialized) {
                initDealerData();
            }

            var $ladItemEl = _ladData.$ladItemEl,
                $savedDealerWrap = $ladItemEl.find('.fgx-saved-dealer-content');
            $savedDealerWrap.empty();
            if (dealerState.preferred && _ladData && _ladData.showSavedDealer) {
                var dealer = dealerLib.updateDealer(dealerState.preferred, 0, _ladData.salesOpenUntil, _ladData.salesOpenAgain, null, _ladData.dealerDetailLink, _ladData.hoursDisplayType);

                if (dealer != null) {
                    var dist = dealerState.preferred[_ladData.distanceTypeKey];
                    var distanceTxt = (dist && dist !== '0') ? (dist + " " + _ladData.distanceLabel) : '';
                    $ladItemEl.find('.fgx-saved-dealer .lad-link-label').text(dealerState.preferred.Name)
                    $ladItemEl.find('.fgx-saved-dealer .dealer-distance').text(distanceTxt);

                    dealer.Distance = dist;

                    var starAriaLabel = (_ladData.starAriaLabelTmpl || '').replace('{starCount}', dealer.combinedRating || '');
                    var ratingsAriaLabel = (_ladData.ratingsAriaLabelTmpl || '').replace('{reviewCount}', dealer.combinedRatingsCount || '');
                    var detailAriaLabel = (_ladData.detailAriaLabelTmpl || '').replace('{dealerName}', dealer.Name || '');
                    var chatAriaLabel = (_ladData.chatAriaLabelTmpl || '').replace('{dealerName}', dealer.Name || '');
                    var directionsAriaLabel = (_ladData.directionsAriaLabelTmpl || '').replace('{dealerName}', dealer.Name || '');
                    var textDealerAriaLabel = (_ladData.textDealerAriaLabelTmpl || '').replace('{dealerName}', dealer.Name || '');

                    // phone
                    var phone = dealer.Phone;
                    if (dealer.dlrcalltrk_lad && dealer.dlrcalltrk_lad !== '') {
                        phone = dealer.dlrcalltrk_lad;
                    } else if (dealer.ldlrcalltrk_lad && dealer.ldlrcalltrk_lad !== '') {
                        phone = dealer.ldlrcalltrk_lad;
                    }
                    dealer.fgxPhoneDisplay = phone;

                    // dealer detail deeplink
                    var dealerDeepLink,
                        detailLinkCls = '';
                    if (_ladData.detailLinkDestination === 'dealer-website' && dealer.URL && !brand.Util.isEmpty(dealer.URL)) {
                        var qs = _ladData.savedDealerGnav;
                        // if a 'mt-attr-val' cookie is present, we will have a Query String value added to our dealer object, add it to qs
                        if (dealer.mtAttrQS) {
                            if (!brand.Util.isEmpty(qs)) {
                                qs += '&';
                            }
                            qs += dealer.mtAttrQS;
                        }
                        dealerDeepLink = appendQueryString(dealer.URL, qs);
                        detailLinkCls = _ladData.ladConfig && _ladData.ladConfig.exitOverlayCls || '';
                    } else {
                        dealerDeepLink = appendQueryString(dealer.DeepLinkUrl, _ladData.savedDealerGnav);
                        dealerDeepLink = appendAppContext(dealerDeepLink, _ladData.dealerAppContext);
                    }
                    
                    // rating deeplink
                    var ratingDeepLink,
                        ratingLinkCls = '';
                    if (_ladData.ratingLinkDestination === 'dealer-website' && dealer.URL && !brand.Util.isEmpty(dealer.URL)) {
                        var qs = _ladData.savedDealerGnav;
                        // if a 'mt-attr-val' cookie is present, we will have a Query String value added to our dealer object, add it to qs
                        if (dealer.mtAttrQS) {
                            if (!brand.Util.isEmpty(qs)) {
                                qs += '&';
                            }
                            qs += dealer.mtAttrQS;
                        }
                        ratingDeepLink = appendQueryString(dealer.URL, qs);
                        ratingLinkCls = _ladData.ladConfig && _ladData.ladConfig.exitOverlayCls || '';
                    } else {
                        ratingDeepLink = appendQueryString(dealer.ReviewsDeepLinkUrl, _ladData.savedDealerGnav);
                        ratingDeepLink = appendAppContext(ratingDeepLink, _ladData.dealerAppContext);
                    }

                    var prm = {
                        dealer: dealer,
                        cfg: _ladData.ladConfig,
                        starAriaLabel: starAriaLabel,
                        ratingsAriaLabel: ratingsAriaLabel,
                        detailAriaLabel: detailAriaLabel,
                        detailLinkCls: detailLinkCls,
                        dealerDeepLink: dealerDeepLink,
                        ratingDeepLink: ratingDeepLink,
                        ratingLinkCls: ratingLinkCls,
                        chatAriaLabel: chatAriaLabel,
                        directionsAriaLabel: directionsAriaLabel,
                        textDealerAriaLabel: textDealerAriaLabel,
                        moreDealersLinkSavedGnav: _ladData.moreDealersLinkSavedGnav,
                        showTextDealer: ctx.showTextDealer
                    };
                    $(_dealerItemTemplate(prm)).appendTo($savedDealerWrap);

                    // dealer chat
                    if (ctx.region !== 'CA') {
                        var $dealerChat = $savedDealerWrap.find('.actions .dealer-chat');
                        // check for chat
                        ngp.dealerChatStatus({dealerPACode: dealer.PACode, make: ctx.make}).done(function(resp) {
                            if(resp && resp.url) {
                                var url = resp.url;
                                $dealerChat
                                    .toggleClass('hidden', false)
                                    .on('click', 'a', function(event) {
                                        event.preventDefault();
                                        event.stopImmediatePropagation();
                                        // new metrics
                                        FD.Brand.Metrics.handler.direct(
                                            $(this).attr('data-fd-metrics-click')
                                        );
                                        window.open(url, '_blank', 'directories=no,titlebar=no,toolbar=no,location=no,status=no,menubar=no,width=350,height=620');
                                    });
                            }
                        });
                    }

                    $ladItemEl.toggleClass('saved-dealer-state', true);
                } else {
                    $ladItemEl.toggleClass('saved-dealer-state', false);
                }
            } else {
                $ladItemEl.toggleClass('saved-dealer-state', false);
            }
        }

        function setCartState() {
            var cartObj = {};
            try {
                var cartItem = window.localStorage.getItem('cartReferral');
                cartObj = (cartItem) ? JSON.parse(cartItem || '{ }') : {};
            } catch(e) { }

            var cartState = (!brand.Util.isEmpty(cartObj) && cartObj.cartId) ? 'full' : 'empty';
            components
                .find('[data-cart-link]')
                .toggleClass('hidden', true)
                .filter('[data-cart-link="' + cartState + '"]')
                .toggleClass('hidden', false);
        }

        function appendQueryString(url, parameters) {
            var output = '';
            if(url && typeof(url) !== 'undefined') {
                if(typeof(parameters) != 'undefined' && parameters !== '') {
                    var _url = brand.Util.url.urlObject(url),
                        param = brand.Util.parameters.decode(parameters);
                    _url.qs.add(param);
                    output = _url.url();
                } else {
                    output = url;
                }
            }
            return output;
        }

        function appendAppContext(url, context) {
            var output = '';
            if(url && typeof(url) !== 'undefined') {
                if(context && typeof(context) !== 'undefined' && context !== '') {
                    var _url = brand.Util.url.urlObject(url),
                        contextStr = '/context/' + context;
                    _url.setHash(contextStr, true);
                    output = _url.url();
                } else {
                    output = url;
                }
            }
            return output;
        }

        function dskPreventTransitionCheck($el) {
            // If we're opening a flyout on desktop that's the same 'type' as the one that's already open, then prevent the animation from happening.
            return (_layoutKey === 'desktop' && _flyoutData.isActive && ($el.attr('data-flyout-type') || '') === _flyoutData.activeType && !$el.hasClass('open') && _flyoutData.activeType != '');
        }

        function handleResize(mql) {
            _layoutKey = (!mql.matches) ? 'mobile' : 'desktop';
            navHeight = components.outerHeight();
            updatePresentationElms();
            updateFlyoutAttributes();

            if (_layoutKey === 'desktop' && _mobileMenuOvr.isOpen) {
                // When resizing the screen from mobile to desktop we should close the mobile menu and release focus, but set
                // the skipLastFocus property on the mobileMenuOvr object to true first so focus isn't moved off the current element.
                _mobileMenuOvr.skipLastFocus = true;
                toggleMobileMenu.call($navbarToggle);
                // Reset to false after toggling the mobile menu
                _mobileMenuOvr.skipLastFocus = false;
            } else if (_layoutKey === 'mobile' && hasActiveFocusTrappedOvr()) {
                var activeOvr = getActiveFocusTrappedOvr(),
                    lastId = activeOvr.id;
                activeOvr.skipLastFocus = true;
                closeFlyoutMenus();
                // Need to reset the skipLastFocus in the actual overlay object itself because activeOvr will be set to null in the closeFlyoutMenus function.
                (_dskOverlays[lastId] || {}).skipLastFocus = false;
            }
        }

        // Functions to setup and handle dynamic scrolling functionality when enabled
        function setupScrollHandling(el) {
            // wait for initial scroll event before setting up the logic to handle subsequent scrolls. Used in an attempt
            // to prevent the nav from unintentionally being hidden when reloading a page that has already been scrolled.
            $(el).one('scroll.fgxMainNav', function() { createScrollListener(el); });
        }
        function createScrollListener(el) {
            var $el = $(el),
                lastScrollPos = $el.scrollTop(),
                scrollLock = false;
            var handleScroll = function() {
                if (!scrollLock) {
                    scrollLock = true;
                    var scrollPos = $el.scrollTop(),
                        scrollDir = ((scrollPos - lastScrollPos) > 0) ? 'down' : 'up',
                        hasOpenFlyout = ((_layoutKey === 'mobile' && _mobileMenuOvr.isOpen) || (_layoutKey === 'desktop' && _flyoutData.isActive));
                    lastScrollPos = scrollPos;
                    // add or remove the 'hide-off-top' class from the main nav element as needed
                    components.toggleClass('hide-off-top', (!hasOpenFlyout && scrollPos > navHeight && scrollDir === 'down'));
                    // wait before releasing the scroll lock
                    window.setTimeout(function() {
                        scrollLock = false;
                    }, 100);
                } else {
                    lastScrollPos = $el.scrollTop();
                }
            };
            components.addClass('top-trans-enabled');
            if (!_forceNoDynamDisplay) {
                $el.on('scroll.fgxMainNav', handleScroll);
                components.on('focusin.fgxMainNav', function(ev) {
                    $(this).removeClass('hide-off-top');
                });
            }
        }
        function disableScrollListener(el) {
            $(el).off('scroll.fgxMainNav');
            components.removeClass('top-trans-enabled hide-off-top');
        }


        function searchController($inputEl, formAction, id, searchLib) {

            function searchControllerHelper($input, id, searchLib) {
                var _this = this,
                    _id = id,
                    _searchLib = searchLib;

                _this.$input = $input;
                _this.$form = $input.closest('.fgx-search-form');
                _this.$formWrapper = _this.$form.find('.form-wrapper');
                _this.$resultsContainer = _this.$form.find('.search-suggestions');
                _this.$searchSubmit = _this.$form.find('.fgx-search-submit');
                _this.setAction = setFormAction;
                _this.setReferrerApp = setReferrerApp;
                _this.inputChange = handleInputChange;
                _this.hideResults = hideResults;
                _this.itemFocusOut = handleItemFocusOut;
                _this.submitForm = submitForm;
                _this.getId = getId;

                // Event Listeners
                _this.$input
                    .on('input', handleInputChange)
                    .on('keydown', handleInputKeydown)
                    .on('blur', function() {
                        _this.itemFocusOut('input');
                    });

                // handling to ensure the type-ahead results container isn't hidden if the search suggestions scroll bar is clicked.
                _this.$resultsContainer
                    .on('mousedown', function() {
                        _this.$resultsContainer.addClass('fgx-is-scrolling');
                    })
                    .on('mouseup', function() {
                        _this.$input.focus();
                        _this.$resultsContainer.removeClass('fgx-is-scrolling');
                    })
                    .on('focusout', '.search-res-item', function() {
                        _this.itemFocusOut('result');
                    });

                _this.$searchSubmit.on('click', submitForm);

                return _this;

                function setFormAction(action) {
                    _this.$form.attr("action", action || '');
                    return _this;
                }

                function setReferrerApp() {
                    if (_searchLib) {
                        _searchLib.setReferrerApp(_this.$formWrapper);
                    }
                    return _this;
                }

                //Handles input value for Type-a-head
                function handleInputChange() {
                    var $this = $(this),
                        val = $this.val();
                    if(val.length === 0) {
                        _this.hideResults();
                    } else {
                        try {
                            _searchLib.typeAheadResults(val, _this.$resultsContainer, $this);
                        } catch(ex) { }
                    }
                }

                function handleInputKeydown(ev) {
                    if (ev.which === 40 && $(this).hasClass('fgx-list-shown')) {
                        // focus on the very first type-ahead result item
                        _this.$resultsContainer.find('li').first().focus();
                    }
                }

                function handleItemFocusOut(itmType) {
                    // setTimeout is needed because nothing has focus during 'focusout'
                    setTimeout(function() {
                        var active = $(document.activeElement),
                            itmTypeCond = !((itmType === 'result') ? active.hasClass('fgx-search-input') : _this.$resultsContainer.hasClass('fgx-is-scrolling'));

                        if (!active.hasClass('search-res-item') && itmTypeCond) {
                            _this.hideResults();
                        }
                    }, 100);
                }

                function hideResults() {
                    _this.$resultsContainer.hide();
                    _this.$input.toggleClass('fgx-list-shown', false);//BRAND-12331
                    return _this;
                }

                function submitForm() {
                    if (!$input.val()) {
                        window.event.preventDefault();
                    } else {
                        _this.$form.submit();
                    }
                }

                function getId() {
                    return _id;
                }
            }

            var _sch = new searchControllerHelper($inputEl, id, searchLib);

            _sch.setAction(formAction)
                .setReferrerApp();

            return _sch;
        }

    }
	
	window.FD.Brand.User.fps.current().done(function(state) {
		if(!state.loaded) {
			return;
		}
		// FPS loaded
		// Only set FPS cookies if not already set from a separate FPS library script
		if (document.cookie.match(/^(.*;)?\s*(FPS|fps)(.*)\s*=\s*[^;]+(.*)?$/)) {
			try {
			    var pageType = FD.Brand.Context && FD.Brand.Context.pageType;
				/* BEGIN NEW PAGE TYPE IMPLEMENTATION */
				if (typeof pageType !== 'undefined') {
				    switch (pageType) {
				        case 'VehicleHomePage':
				            FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewPage,window.location.href)]);
				            break;
			            case 'VehicleHomePageBlackLabel':
				            FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewPageBlackLabel,window.location.href)]);
				            break;
			            case 'VehicleGalleryPage':
				            FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewGallery, window.location.href)]);
				            break;
				        case 'VehicleModelsSelectPage':
				            var url = FD.Brand.Context && FD.Brand.Context.canonicalNameplateUrl;
				            if (typeof url === 'undefined') {
				                url = window.location.href;
				            }
    						FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewModels, url)]);
    						break;
    					case 'VehicleModelsDetailPage':
    					    FPS.set([FPS.lib.ActionTrim(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FD.Brand.Context.model.ngpTrimName, FPS.actions.ViewModelDetail,window.location.href)]);
    					    break;
    					case 'VehicleModelsDetailPageBlackLabel':
    					    var theme = (typeof FD.Brand.Context.blackLabelTheme !== 'undefined') ? FD.Brand.Context.blackLabelTheme : '',
					            trim = FD.Brand.Context.model.ngpTrimName + " " + theme;
                           			    trim = trim.trim();
						    FPS.set([FPS.lib.ActionTrim(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, trim, FPS.actions.ViewModelDetailBlackLabel,window.location.href)]);
    					    break;
    					case 'PricingAndIncentivesPage':
    					    FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.tabName, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.IOModelOffers, window.location.href)]);
    					    break;
    					case 'VehicleFeaturesPage':
    					    FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewFeatures, window.location.href)]);
    					    break;
    					case 'VehicleBrochuresPage':
    					    FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.RequestBrochure)]);
    					    break;
    					case 'CommercialVehicleCenterPage':
    					    FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewPage, window.location.href)]);
    					    break;
    					case 'RevealPage':
    					    FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewPageReveal,window.location.href)]);
    					    break;
					case 'none':
				            var url = FD.Brand.Context && FD.Brand.Context.canonicalNameplateUrl;
				            if (typeof url === 'undefined') {
				                url = window.location.href;
				            }
    					    FPS.set([FPS.lib.ActionNameplate(FD.Brand.Context.nameplate.ngpYear, FD.Brand.Context.make, FD.Brand.Context.nameplate.ngpModelName, FPS.actions.ViewModels, url)]);
    				            break;	    
				    }
				    FPS.setTargetCookie({success: function(data) {console.log('FPS set target cookie::success ==>'+data);}, error: function(data) {'FPS set target cookie::error ==>'+console.log(data);}});
				}
				/* END PAGE TYPE IMPLEMENTATION */
			} catch(err) {
				console.log("Unable to load fps set script "+err.message);
			}
		}	
	}).fail(function() {
		console.log("Unable to load FPS library");
	});	
	
})(jQuery, FD.Brand, FD.Brand.User, FD.Brand.Pricing, FD.Brand.Search, FD.Brand.Context, FD.Brand.Dealer, FD.Brand.NgpServices, FD.Brand.RnO);

;(function($, win, brand, user, pricing, search, ctx, ngp, rno) {

    var components,
        _layoutKey = 'desktop',
        _flyoutData = {
            isActive: false,
            activeType: '',
            activeOvr: null
        },
        _dskOvrIdx = 0,
        _dskOvrAttr = 'data-fgx-fordMainNav-flyout-id',
        _dskOvrIdPrefix = 'fgx-fordMainNav-flyout-',
        _dskOverlays = {},
        _segController = {},
        _mobileMenuOvr = {
            isOpen: false,
            focusElements: 'a:not([tabindex="-1"]):visible, input:visible, button:visible, [data-fgx-keypress]:visible',
            skipLastFocus: false
        },
        _searchOvr = {
            isOpen: false,
            focusElements: 'a:not([tabindex="-1"]):visible, input:visible, button:visible, [data-fgx-keypress]:visible',
            skipLastFocus: false
        },
        _searchInst = {},
        _isNonSticky = false,
        _alwaysNonSticky = false,
        events = 'animationend webkitAnimationEnd MSAnimationEnd transitionend webkitTransitionEnd';
    let $initialFocusMobileSegmentTrigger = null;

    brand.setInitHandler('[data-fgx-ford-main-navigation-r23]', init);

    function init(_components) {
        /* NZ: TODO:
            1. Should be able to clean up all instances of flyout-mbl-only logic.
            2. clean up instances of presentation-only-lg logic.
        */
        if (!_components || _components.length == 0) {
            return;
        }
        components = _components;

        if (ctx) {
            if(ctx.hideGlobalHeader) {
                $(components).addClass('fgx-brand-hidden');
            }
        }
        
        var mql = window.matchMedia('(min-width: 992px)'),
            mtxActions = ctx && ctx.mtxActions,
            languageSelectorOverlayOpenAction = mtxActions && mtxActions.languageSelectorOverlayOpenAction || null,
            defaultAction = "//www.ford.com/search/",
            formAction = ctx.settings['ngbsSearchUrl' + ctx.make + ctx.languageKey] || ctx.settings['ngbsSearchUrl' + ctx.make] || defaultAction,
            $resultsContainer = $('.search-suggestions', components),
            $searchFormWrapper = $('.fgx-search-wrapper', components),
            $navbarToggle = $('.navbar-toggle', components),
            $bgOverlay = $('.fordMainNavOverlay'),
            _hasSecondaryNav = ($('.secondaryNavigation').length > 0 || $('.cmp-secondaryNavigation').length > 0),
            $secondaryNavR23 = $('.secondaryNavigationR23'),
            _hasSecondaryNavR23 = ($secondaryNavR23.length > 0),
            notificationsEnabled = (($(components).attr('data-notification-enabled') || '') === 'yes'),
            $body = $('body'),
            navHeight = components.outerHeight(),
            _dynamDisplayOnScroll = ((components.attr('data-dynamic-scroll-display-enabled') || '') === 'true'),
            _forceNoDynamDisplay = false,
            _cartEnabled = ((components.attr('data-cart-enabled') || '') === 'true'),
            animEvents = 'animationend webkitAnimationEnd MSAnimationEnd transitionend webkitTransitionEnd',
            _transparencyEnabled = !!(components.closest('.bri-nav-transparent-onLt, .bri-nav-transparent-onDrk').length > 0),
            _transparentObs = null,
            _hasPreSubNavContent = ($('.brand-content_pre-sub-nav > div').not('.new.section').length > 0);
        // The nav should always be non-sticky (be positioned relative and scrolled off the page) if we have a legacy secondary
        // nav OR if we have the r23 secondary nav but there is no content authored above it.
        _alwaysNonSticky = _hasSecondaryNav || (_hasSecondaryNavR23 && !_hasPreSubNavContent);
        _isNonSticky = _alwaysNonSticky;// Default to alwaysNonSticky flag.

        _mobileMenuOvr.lastFocus = $navbarToggle;
        _mobileMenuOvr.$el = $('.menu-items-container', components);
        _mobileMenuOvr.hide = function() {
            toggleMobileMenu.call($navbarToggle);
        };
        _mobileMenuOvr.$firstToggle = _mobileMenuOvr.$el.find('.flyout-toggle').first();

        if (components.hasClass('fordMainNavigationR23') && !$('.promoBanner').length && !_alwaysNonSticky) {
            setupMainNavScrollBehavior();
        }

        $('.flyout-toggle:not(.flyout-mbl-only)', components).each(function() {
            setupOvrItem($(this));
        });

        // Setup the controller for segment items
        _segController = segmentController($('.segment-anchor-trigger', components));

        $(document).on('brandnav:setnonsticky', function(ev) {
            brand.Util.log("fordMainNavigation - brandnav:setnonsticky handler triggered");
            _isNonSticky = true;
            $('.navbar-static-top', components).toggleClass('nonsticky', true);
        });

        mql.addListener(handleResize);
        handleResize(mql);
        const isDesktop = _layoutKey === 'desktop';
        
        // self-contained exposedSearchBarJS
        const { 
            $searchListContainer,
            $searchInput,
            handleAddToSearchHistory,
            hasSearchHistory
        } = handleExposedSearchBar({ isDesktop, components, navHeight })
        // end of self-contained exposedSearchBarJS

        brand.Dig.resolve(components);

        components.each(function() {
            pricing.refresh(this);
        });

        user.authentication.subscribe(setUserMenuState);

        // Set nonsticky class
        // previously checked _isNonSticky flag. Only set non sticky here if thats always the case.
        if (_alwaysNonSticky) {
            $('.navbar-static-top', components).toggleClass('nonsticky', true);
        }

        // cart state logic
        if (_cartEnabled) {
            setCartState();
        }

        // search form
        _searchOvr.lastFocus = $('.fgx-search-trigger', components);
        _searchOvr.$el = $searchFormWrapper;
        _searchOvr.controller = searchController($searchInput, formAction, 'fgx-mainNav-search-0', search);
        _searchOvr.hide = function() {
            _searchOvr.controller.closeSearch();
        };


        // Event Handlers
        $('.flyout-item-wrap', components).on('focusin', '.fgx-brand-nav-flyout-end', function(ev) {
            var $focusEl = $(this).closest('.flyout-item-wrap').find('.flyout-toggle');
            updateFocus($focusEl);
        });

        $('.menu-items-container', components).on('focusin', '.fgx-brand-nav-mobile-menu-end', function(ev) {
            if (_layoutKey === 'mobile') {
                var $focusEl = $('.mbl-menu-close', components);
                updateFocus($focusEl);
                //updateFocus('.mbl-menu-close');
            }
        });

        $('.navbar-toggle, .mbl-menu-close', components).on('click', function() {
            toggleMobileMenu.call($navbarToggle);
        });

        $('.mbl-menu-close', components).on('focusin focusout', function(ev) {
            $navbarToggle.toggleClass('fgx-focus-display', (ev.type === 'focusin'));
        });

        $('.flyout-toggle', components).on('click', function(ev) {
            ev.preventDefault();
            // I don't believe this is needed but commenting out just in case. - ev.stopPropagation();
            handleFlyoutToggle.call(this);
            $("#brand-nav-gm2-item .container_flex").removeClass('container-flexwidth');
            $(".megaMenu_sub_nav").addClass('hide');
            $(this).find(".link-text").text().trim()==='Vehicles' ? $('.fgx-mbl-lst-wrap').removeClass('megamenu-vehicle-style')
                : $('.fgx-mbl-lst-wrap').addClass('megamenu-vehicle-style');
            $("#brand-nav-gm1-item .flyout-full-width, #brand-nav-gm2-item .flyout-full-width").addClass('megaMenu-gm1-item');
            $("#brand-nav-gm1-item .flyout-full-width.megaMenu-gm1-item, #brand-nav-gm2-item .flyout-full-width.megaMenu-gm1-item").find('.container_flex').removeClass('bri-nav__col-1');
            $('.img-link picture').removeClass("loaded");
            var intervalId = setInterval(function(){
                $('.vehicle-tile-top img').each(function(index) {
                    if($(this).hasClass("lazyloaded")){
                        $(this).parent().addClass("loaded");
                        (index === $('.vehicle-tile-top img').length - 1) && clearInterval(intervalId);
                    }
                });
            }, 500);
        });

        $('.column-vehicle-item', components).on('click', '.year-item-toggle', function(ev) {
            var $el = $(this),
                activeClass = $el[0].value || 'active-veh-1',
                $tile = $el.closest('.vehicle-tile');
            $tile.toggleClass('active-veh-1 active-veh-2', false).addClass(activeClass);
        });

        $('.segment-anchor-trigger', components).on('click', function(ev) {
            _segController?.openSegment($(this))
            // skeleton loaders
            $('.img-link picture').removeClass("loaded");
            var intervalId = setInterval(function(){
                $('.vehicle-tile-top img').each(function(index) {
                    if($(this).hasClass("lazyloaded")){
                        $(this).parent().addClass("loaded");
                        (index === $('.vehicle-tile-top img').length - 1) && clearInterval(intervalId);
                    }
                });
            }, 500);
        });

        $('.segment-back-btn', components).on('click', function(ev) {
            if (_layoutKey === 'mobile') {
                // Hide the open segment overlay when the back button is clicked on mobile.
                _segController?.closeSegment($(this).closest('.vehicle-segment-layout'));
                $initialFocusMobileSegmentTrigger?.focus();
            }
        });

        // language links
        $('.fgx-lang-link', components).on('click', function(ev) {
            if(FD.Brand.Link.switchLanguage(this)) {
                ev.preventDefault();
            }
        });

        // search trigger
        $('.fgx-search-trigger', components).on('click', function(ev) {
            if (_searchOvr && _searchOvr.controller) {
                if ($searchFormWrapper.hasClass('hidden')) {
                    _searchOvr.controller.showSearch($(this));
                } else {
                    _searchOvr.controller.closeSearch();
                }
                $(this).addClass('hidden');
                $searchInput.addClass('focus');
                if(_layoutKey === 'desktop') {
                    $searchInput.parents('.fgx-search-wrapper').removeClass('hidden').addClass('open');
                    $('.fgx-search-wrapper.mobile-show .fgx-search-input').parents('.fgx-search-wrapper').removeClass('open mbl-show-transition').addClass('hidden');
                }
            }
        });

        if(_layoutKey === 'mobile') {
            $('.fgx-search-wrapper.desktop-show .fgx-search-input', components).on('click focus', function(ev) {
                $(this).parents('.fgx-search-wrapper').removeClass('open').addClass('hidden');
                $searchInput.parents('.fgx-search-wrapper').addClass('mbl-show-transition').css('display', 'block');
                $searchInput.focus();
            });

            $('.mobile-back-icon', components).on('click focus', function(ev) {
                $searchInput.parents('.fgx-search-wrapper').removeClass('mbl-show-transition').css('display', 'none');
                $('.fgx-search-wrapper.desktop-show .fgx-search-input').parents('.fgx-search-wrapper').removeClass('hidden').addClass('open');
                $searchInput.val('');
            });
        }

        // mbl-flyout-back-btn  trigger
        $('.mbl-flyout-back-btn', components).on('click', function() {
            $(".megaMenu_sub_nav").removeClass('open').addClass('hide');
            $("#brand-nav-gm2-item .container_flex").removeClass('container-flexwidth');
            $(".megaMenu_sub_nav .segment-menu-item-container").removeClass('open').addClass('hidden');
        });

        // Triggers megamenu flyout L2 to show or hide for desktop
        $('.button_flex_container', components).on('click', function(event) {
            // Check if the clicked element is inside an element with class 'button_flex_container'
            if ($(event.target).closest(".button_flex_container").length > 0 || $(event.target).hasClass('button_flex_container')) {
                let getCategoryName = "";
                let getMblCategoryLabel = "";

                // focus correctly on flyout
                const $lastAnchorElemInOpenFlyout = $('.flyout-container.open .segment-menu-item-container').find('a').last();
                $lastAnchorElemInOpenFlyout?.off('keydown').on('keydown', function(e) {
                    const isTabKeydown = e?.key === "Tab" || e?.keyCode === 9;
                    const isShiftKeydown = e?.shiftKey;

                    if (isTabKeydown && !isShiftKeydown) {
                        e?.preventDefault();
                        e?.stopPropagation();
                        if (_layoutKey === 'desktop') {
                            const $activeFlyoutButton = $('.button_flex_container.open');
                            const $nextFocusFlyoutItem = $activeFlyoutButton?.closest('li')?.next('li')?.children('a, button')?.first();
                            $nextFocusFlyoutItem?.focus();
                        }

                        if (_layoutKey === 'mobile') {
                            const $segmentBackButton = $('.flyout-container.open').find('.segment-back-btn.fgx-btn');
                            $segmentBackButton?.focus();
                        }
                    }
                });

                // Return tab focus back to top of menu
                const $flyoutContainerMenuLinks = $('.flyout-container.open .column-item .column-link-list a.column-link');
                const $lastflyoutContainerMenuLink = $flyoutContainerMenuLinks?.last();
                $lastflyoutContainerMenuLink?.off('keydown').on('keydown', function(e) {
                    const isTabKeydown = e?.key === "Tab" || e?.keyCode === 9;
                    const isShiftKeydown = e?.shiftKey;

                    if (isTabKeydown && !isShiftKeydown) {
                        e?.preventDefault();
                        e?.stopPropagation();

                        const $activeMainNavButton = $('.main-item.flyout-toggle.open');
                        $activeMainNavButton?.focus();
                    }
                });

                if ($(event.target).hasClass('link-text') || $(event.target).hasClass('fgx-icon')) {
                    getCategoryName = $(event.target).closest(".button_flex_container").attr('data-target');
                    getMblCategoryLabel = $(event.target).closest(".button_flex_container").attr('data-target-mbl-label');
                } else {
                    getCategoryName = $(event.target).attr('data-target');
                    getMblCategoryLabel = $(event.target).attr('data-target-mbl-label');
                }

                //updating hide or show class for img tag based on desktop or mobile.
                if (_layoutKey === 'mobile') {
                    $(".mobile_img").removeClass("hide").addClass("open");
                    $(".desktop_img").removeClass("open").addClass("hide");
                } else {
                    $(".mobile_img").removeClass("open").addClass("hide");
                    $(".desktop_img").removeClass("hide").addClass("open");
                }

                // Get the data-target attribute value
                $(".megaMenu_sub_nav").removeClass('hide').addClass('open');
                $("#brand-nav-gm2-item .container_flex").addClass('container-flexwidth');
                $(".megaMenu_sub_nav .segment-menu-item-container").addClass('hidden')
                $('.' + getCategoryName).closest(".megaMenu_sub_nav").find(".segment-menu-item-container").css("opacity",".45");
                $('.' + getCategoryName).closest(".megaMenu_sub_nav").find(".segment-menu-item-container").removeClass('hidden').addClass('open')
                $(".megaMenu_sub_nav .segment-menu-item-container .dynamic-mbl-heading").text(getMblCategoryLabel);

                // Hide all elements with class 'listId'
                $('.listId, .sub_heading, .sub_heading_link').addClass('hide');

                // Show elements with class equal to getCategoryName
                $('.segment-anchor-trigger').removeClass('open');
                $(this).addClass('open');

                // focus correctly on mobile flyout menu
                if (_layoutKey === "mobile") {
                    $initialFocusMobileSegmentTrigger = $(this);
                    const $openedFlyout = $('.menu-items-container.opened');
                    if ($openedFlyout?.length) {
                        const $segmentBackButton = $('.flyout-container.open').find('.segment-back-btn.fgx-btn');
                        $segmentBackButton?.focus();
                    }
                }

                $('.' + getCategoryName).each(function() {
                    if ($(this).not('.sub_heading').find('ul').length > 0) {
                        $(this).removeClass('hide');
                        var className = $(this).attr('class').split(" "); // Get the class attribute
                        $(this).parent().find('.sub_heading.' + className[2] + ', .sub_heading_link.' + className[2]).removeClass('hide');
                    }
                });

                if (_layoutKey === 'desktop') {
                    // Move focus to first flyout link if flyout is open
                    const $openFlyoutButton = $('.button_flex_container.open');
                    $openFlyoutButton?.off('keydown').on('keydown', function(e) {
                        const isTabKeydown = e?.key === "Tab" || e?.keyCode === 9;
                        const isShiftKeydown = e?.shiftKey;
                        const $firstAnchorElemInOpenFlyout = $('.flyout-container.open .segment-menu-item-container.open').find('a').first();

                        if (isTabKeydown && !isShiftKeydown) {
                            if ($firstAnchorElemInOpenFlyout?.length) {
                                e?.preventDefault();
                                e?.stopPropagation();
                                $firstAnchorElemInOpenFlyout?.focus();
                            }
                        }
                    });
                }

                if (_layoutKey === 'desktop') {
                    // Return focus to flyout trigger if tab back from flyout
                    const $firstAnchorElemInOpenFlyout = $('.flyout-container.open .segment-menu-item-container.open').find('a').first();
                    $firstAnchorElemInOpenFlyout?.off('keydown').on('keydown', function(e) {
                        const isTabKeydown = e?.key === "Tab" || e?.keyCode === 9;
                        const isShiftKeydown = e?.shiftKey;

                        if (isTabKeydown && isShiftKeydown) {
                            e?.preventDefault();
                            e?.stopPropagation();

                            const $openFlyoutButton = $('.button_flex_container.open');
                            $openFlyoutButton?.focus();
                        }
                    });
                }

                $('.' + getCategoryName + ' .img-link .no-desktop_img_path,' +  '.' + getCategoryName +  '.img-link .no-mobile_img_path').removeClass("no-src");
                var intervalId = setInterval(function(){
                    $('.' + getCategoryName + ' .img-link .no-desktop_img_path img,' +  '.' + getCategoryName +  '.img-link .no-mobile_img_path img').each(function(index) {
                        if(!$(this).attr("src")){
                            $(this).parent().addClass("no-src");
                            (index === $('.' + getCategoryName + ' .img-link .no-desktop_img_path img,' +  '.' + getCategoryName +  '.img-link .no-mobile_img_path img').length - 1) && clearInterval(intervalId);
                        }
                    });
                }, 500);

                $('.fgx-mbl-lst-wrap').removeClass('megamenu-vehicle-style');
                $("#brand-nav-gm1-item .flyout-full-width.megaMenu-gm1-item, #brand-nav-gm2-item .flyout-full-width.megaMenu-gm1-item").find('.container_flex').addClass('bri-nav__col-1');
                $("#brand-nav-gm1-item .flyout-full-width, #brand-nav-gm2-item .flyout-full-width").removeClass('megaMenu-gm1-item');

                $('.' + getCategoryName + ' .img-link .no-desktop_img_path,' +  '.' + getCategoryName +  '.img-link .no-mobile_img_path').removeClass("no-src");
                var intervalId = setInterval(function(){
                    $('.' + getCategoryName + ' .img-link .no-desktop_img_path img,' +  '.' + getCategoryName +  '.img-link .no-mobile_img_path img').each(function(index) {
                        if(!$(this).attr("src")){
                            $(this).parent().addClass("no-src");
                            (index === $('.' + getCategoryName + ' .img-link .no-desktop_img_path img,' +  '.' + getCategoryName +  '.img-link .no-mobile_img_path img').length - 1) && clearInterval(intervalId);
                        }
                    });
                }, 500);
                $('.' + getCategoryName).closest(".megaMenu_sub_nav").find(".segment-menu-item-container").css("opacity",".99");
            }
            if(_layoutKey === 'mobile') {
                var mobileSubHeadingLink = $('#brand-nav-gm2-item .sub_menu_row_1').outerHeight() + 78;
                $("#brand-nav-gm2-item .sub_menu_row_1 .sub_heading_link").css('top', mobileSubHeadingLink + 'px');
            }
        });

        // Select all elements with class '.listId'
        $('.listId').each(function(index, element) {
            let columnContainerItems = $(this).next('ul');
            if(columnContainerItems.length > 0){
                let columnContainer = columnContainerItems.first().prop('outerHTML');
                columnContainerItems.first().remove();
                $(this).html(columnContainer);
                $(this).addClass('hide');
            }
        });

        // Initialize dynamic scrolling functionality when enabled
        if (_dynamDisplayOnScroll) {
            if (!(_alwaysNonSticky || _hasSecondaryNavR23)) {
                // we're on a brand page that doesn't have the secondary navigation, so setup the dynamic scrolling functionality.
                setupScrollHandling(window);
            }
            $(document).on('brandnav:nodynamicscroll', function(ev) {
                brand.Util.log("fordMainNavigation - brandnav:nodynamicscroll handler triggered");
                disableScrollListener(window);
                _forceNoDynamDisplay = true;
            });
        }

        // Initialize transparent background functionality when enabled
        if (_transparencyEnabled) {
            setupTransparency();
        }

        // Initialize interaction with secondaryNavR23 component
        if (_hasSecondaryNavR23 && _hasPreSubNavContent) {
            let _stickySecondaryObs = null;
            if ("IntersectionObserver" in win) {
                try {
                    _stickySecondaryObs = new IntersectionObserver((entries, observer) => {
                        entries.forEach((entry) => {
                            // entry will refer to the observed element (the secondaryNavigationR23 wrapper in this case.
                            let top = entry.boundingClientRect.top,
                                offset = Math.min((top - navHeight),0),
                                hasOpenFlyout = ((_layoutKey === 'mobile' && _mobileMenuOvr.isOpen) || (_layoutKey === 'desktop' && _flyoutData.isActive));

                            _isNonSticky = (top <= 0);
                            if (!_isNonSticky && $('.navbar-static-top', components).hasClass('nonsticky')) {
                                // Remove the nonsticky class from the navbar if it is currently added but we need to make the nav visible again.
                                $('.navbar-static-top', components).toggleClass('nonsticky', false);
                            }
                            // scroll-off-top class will force the 'top' property of the 'navbar' element to be set
                            // by the '--nav-top-scroll-offset' css property.
                            components.toggleClass('scroll-off-top', (!hasOpenFlyout && top <= navHeight));
                            // Set the correct top value in the nav-top-scroll-offset property based on the calculated offset.
                            // This value will only be used if scroll-off-top class is added above.
                            components[0].style.setProperty('--nav-top-scroll-offset', offset + 'px');
                        });
                    }, {rootMargin: "-56px 0px 0px 0px",threshold: [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0]});
                } catch(e) {
                    _stickySecondaryObs = null;
                }
            }
            if (_stickySecondaryObs) {
                components.toggleClass('scroll-off-top-trans', true);
                components[0].style.setProperty('--nav-top-scroll-offset', '0px');
                _stickySecondaryObs.observe($secondaryNavR23[0]);
            }
        }

        // Functions
        function isElValid($el) {
            return ($el && $el.length > 0) || false;
        }

        function updateFocus($focusEl) {
            if ($focusEl && $focusEl.length > 0) {
                $focusEl.focus();
            }
        }

        // Check various flags to determine if the non sticky class should be applied
        function nonStickyCheck() {
            return _alwaysNonSticky || _isNonSticky;
        }

        function setupOvrItem($el) {
            if (!$el || $el.length === 0) {
                return;
            }
            var _id = _dskOvrIdPrefix + ++_dskOvrIdx,
                $toggle = $el.attr(_dskOvrAttr, _id),
                $flyoutWrap = $toggle.closest('.flyout-item-wrap').attr(_dskOvrAttr, _id),
                _ovr = {
                    id: _id,
                    $el: $flyoutWrap,
                    lastFocus: $toggle,
                    focusElements: 'a:not([tabindex="-1"]):visible, input:visible, button:visible, [data-fgx-keypress]:visible',
                    skipLastFocus: false,
                    hide: function(...args) {
                        handleFlyoutToggle.call($toggle[0], ...args);
                    }
                };
            _dskOverlays[_ovr.id] = _ovr;
        }

        function handleBodyClick(ev) {
            // clicking outside the main nav or within the mainNav but outside of dropdown items should close nav dropdowns
            // and remove the overlay
            var $target = $(ev.target);
            if ($target.hasClass('fordMainNavOverlay') || ($target.closest('.fordMainNavigationR23').length && !$target.closest('.flyout-toggle, .flyout-container, .navbar-toggle').length)) {
                // Hide the current opened flyout
                closeFlyoutMenus();

                if (_layoutKey !== 'mobile') {
                    // on mobile this click handler can be called to close the flyouts without actually closing the mobile
                    // menu so we want to prevent the nonsticky class from being added in the case because it will override the
                    // position: fixed that is used for the mobile menu.
                    if (_isNonSticky) {
                        components.find('.navbar-static-top').toggleClass('nonsticky', true);
                    }

                    components.toggleClass('has-open-menu', false);
                }
            }
        }

        function toggleMobileMenu() {
            var $el = $(this),
                $container = $el.closest('.container-fluid'),
                $menuItems = $container.find('.menu-items-container'),
                isOpen = $menuItems.hasClass('opened');
            $el.toggleClass('opened', !isOpen);
            $el.attr('aria-expanded', !isOpen);
            $('body').toggleClass('no-scroll-sm', !isOpen);
            $('body').toggleClass('no-scroll-md', !isOpen);
            components.toggleClass('has-open-menu', !isOpen);

            $searchInput.parents('.fgx-search-wrapper').removeClass('mbl-show-transition').css('display', 'none');
            $('.fgx-search-wrapper.desktop-show .fgx-search-input').parents('.fgx-search-wrapper').removeClass('hidden').addClass('open');
            // clear any search input if it exists
            $searchInput.val('');
            $searchInput.focus();

            if (_isNonSticky) {
                $el.closest('.navbar-static-top').toggleClass('nonsticky', isOpen);
            }

            if (isOpen) {
                var $skipSubAnimEl = $menuItems.find('.fgx-mbl-lst-wrap');
                // Ignore animation events that are propogated up from child elements within the fgx-mbl-lst-wrap element.
                $skipSubAnimEl.off(events).on(events, function(ev) {
                    ev.stopPropagation();
                });
                $menuItems.off(events).one(events, function() {
                    var $el = $(this);

                    if (!$el.hasClass('opened') && !$el.hasClass('hidden-xs') && !$el.hasClass('hidden-sm')) {
                        $el.addClass('hidden-xs hidden-sm').off(events);
                    }
                    $skipSubAnimEl.off(events);
                }).removeClass('opened');

                // if isOpen is true here, then the mobile menu is actually being closed.
                closeFlyoutMenus();
                FD.Brand.Overlay.releaseFocus(_mobileMenuOvr);
            } else {
                $menuItems.toggleClass('hidden-xs hidden-sm', false).show().toggleClass('opened', !isOpen);
                FD.Brand.Overlay.trapFocus(_mobileMenuOvr, _mobileMenuOvr.focusElements, null, _mobileMenuOvr.lastFocus, false);
                if (_layoutKey === 'mobile'){
                    $('.fgx-search-wrapper .fgx-search-input').parents('.fgx-search-wrapper').removeClass('hidden').addClass('open');
                    $('.fgx-search-wrapper .fgx-search-input').addClass('focus');
                    $('.fgx-search-wrapper .fgx-search-input').parents('.fgx-search-wrapper').prev().find('.fgx-search-trigger').removeClass('open').addClass('hidden');
                }

                // commenting this line to get the shop & Support has a collapse accordion
                // handleFlyoutToggle.call(_mobileMenuOvr.$firstToggle[0]);
            }

            _mobileMenuOvr.isOpen = isOpen;
        }

        function handleFlyoutToggle() {
            var $el = $(this),
                $flyoutGroup = $el.closest('[data-fgx-flyout-group]');

            if (canActivateToggle($el)) {
                var layoutSelector = (_layoutKey === 'mobile') ? '' : ':not(.flyout-mbl-only)';
                var hSelector = '.flyout-toggle' + layoutSelector;
                var cSelector = '.flyout-container' + layoutSelector;

                //$(components).toggleClass('no-transition-dsk', dskPreventTransitionCheck($el));
                //Commenting out so we can determine if this transition works better for the R23 flavor of menus
                // ensure any open segment containers are closed
                _segController.closeAllSegments();

                if (_flyoutData.isActive && _layoutKey === 'desktop') {
                    var newId = $el.attr(_dskOvrAttr) || '',
                        activeOvr = _flyoutData.activeOvr || {};
                    if (newId && activeOvr && activeOvr.id && activeOvr.id !== newId) {
                        // If a different flyout is already open then releaseFocus from that flyout without updating the lastFocus
                        // position. Note, the accordion.update call below will actually handle the logic to close the active flyout.
                        activeOvr.skipLastFocus = true;
                        FD.Brand.Overlay.releaseFocus(activeOvr);
                        activeOvr.skipLastFocus = false;
                    }
                }

                brand.Util.accordion.update($el, $flyoutGroup, hSelector, cSelector, true, function() {
                    var $el = $(this),
                        $cEl = $el.next(cSelector),
                        isOpen = $el.hasClass('open'),
                        id = $el.attr(_dskOvrAttr) || '',
                        invisibleBg = isOpen && $el.hasClass('fgx-no-bg-ovr');

                    _flyoutData.isActive = (isOpen);
                    _flyoutData.activeType = (isOpen) ? ($el.attr('data-flyout-type') || '') : '';

                    var $segList = $('.segments-anchor-list', $cEl);
                    if (_layoutKey === 'desktop' && isOpen && $segList.length) {
                        // if we have a segment list, we're the vehicle menu...and if we made it here, we've been opened - trigger the click event on our first segment trigger if the item is not already expanded
                        var $firstBtn = $('.segment-anchor-list-item:first-child > button', $segList);
                        if (!$firstBtn.hasClass('open')) {
                            $firstBtn.trigger('click');
                        }
                    }

                    if (_layoutKey === 'desktop' && id && !brand.Util.isEmpty(_dskOverlays[id] || {})) {
                        var _ovr = _dskOverlays[id];
                        if (isOpen) {
                            FD.Brand.Overlay.trapFocus(_ovr, _ovr.focusElements, '.flyout-toggle', _ovr.lastFocus, false);
                            _flyoutData.activeOvr = Object.assign({}, _ovr || {});
                        } else {
                            _flyoutData.activeOvr = null;
                            FD.Brand.Overlay.releaseFocus(_ovr);
                        }
                    } else {
                        _flyoutData.activeOvr = null;
                    }

                    $bgOverlay.toggleClass('open', isOpen).toggleClass('fgx-invisible-bg', invisibleBg);

                    $body.off('click.fgxMainNav', handleBodyClick);
                    if (isOpen) {
                        $body.on('click.fgxMainNav', handleBodyClick);
                    }

                    if (_layoutKey !== 'mobile') {
                        components.toggleClass('has-open-menu', isOpen);

                        // On mobile the flyouts can be closed without actually closing the main mobile menu, so we want
                        // to prevent the nonsticky class from being added in that case because it will override the position: fixed
                        // that is used for the mobile menu.
                        if (nonStickyCheck()) {
                            $el.closest('.navbar-static-top').toggleClass('nonsticky', !isOpen);
                        }
                    }
                }, '', true, '.column-link-list, .segments-anchor-list, .segment-menu-item-container .column-wrap-container');
            }
        }

        function canActivateToggle($el) {
            return !!($el && $el.length > 0 && (!$el.hasClass('.flyout-mbl-only') || _layoutKey === 'mobile'));
        }

        function getActiveFocusTrappedOvr() {
            return _flyoutData.activeOvr || {};
        }

        function hasActiveFocusTrappedOvr() {
            return (_flyoutData.isActive && !brand.Util.isEmpty(getActiveFocusTrappedOvr()));
        }

        function updatePresentationElms() {
            var $presElms = $('.presentation-only-lg', components);
            var onDsk = (_layoutKey === 'desktop');
            var bpKey = (onDsk) ? 'dsk' : 'mbl';
            if ($presElms && $presElms.length) {
                $presElms.attr('role', (onDsk) ? 'presentation' : null);
            }
            $('[data-role-cfg]', components).each(function() {
                var $el = $(this),
                    roleCfg = null;
                try {
                    roleCfg = JSON.parse($el.attr('data-role-cfg') || '{ }');
                } catch(e) { }
                // logic below will set the role attribute to the provided value for the bp, or remove the role attribute if no value is provided.
                $el.attr('role', roleCfg && roleCfg[bpKey] || null);
            });
        }

        function updateFlyoutAttributes() {
            var onDsk = (_layoutKey === 'desktop'),
                hSelector = '.flyout-toggle.flyout-mbl-only',
                cSelector = '.flyout-container.flyout-mbl-only' + ((onDsk) ? '' : ':not(.open)');

            $(cSelector, components).toggleClass('hidden', !onDsk);

            if (onDsk) {
                $(hSelector, components).attr('aria-expanded', null);
            } else {
                $(hSelector, components).each(function() {
                    var $el = $(this);
                    $el.attr('aria-expanded', $el.hasClass('open') ? 'true' : 'false');
                });
            }
        }

        function closeFlyoutMenus() {
            var layoutSelector = (_layoutKey === 'mobile') ? '' : ':not(.flyout-mbl-only)';
            var hSelector = '.flyout-toggle.open' + layoutSelector;
            var cSelector = '.flyout-container.open' + layoutSelector;

            // ensure any open segment containers are closed - if none are open, this has no effect
            _segController.closeAllSegments();

            $(hSelector, components).removeClass('open').attr('aria-expanded', 'false');
            brand.Util.accordion.hideAnimContent($(cSelector, components), '.column-link-list, .segments-anchor-list, .segment-menu-item-container .column-wrap-container');

            if (hasActiveFocusTrappedOvr()) {
                FD.Brand.Overlay.releaseFocus(getActiveFocusTrappedOvr());
            }
            _flyoutData.activeOvr = null;
            _flyoutData.isActive = false;
            _flyoutData.activeType = '';
            $bgOverlay.toggleClass('open fgx-invisible-bg', false);
            $body.off('click.fgxMainNav', handleBodyClick);
        }

        // User Menu
        function setUserMenuState(authState) {
            // hide entire li element if auth is not loaded
            var $menuItem = $('.user-menu-item', components).toggleClass('hidden', !authState.loaded);
            var $authItems = $menuItem.find('[data-auth]').addClass('hidden');
            var $currentAuthItems = $authItems.filter('[data-auth~="' + authState.authType + '"]').toggleClass('hidden', false).not('[data-auth-icon]');

            if(authState && authState.authType == 'user') {
                user.profile.current().then(function(profileState) {
                    const firstName = profileState && profileState.firstName || '';

                    $('.user-menu-greeting').html(`Hi, ${firstName}`);
                    
                    $currentAuthItems.each(function() {
                        var $el = $(this),
                            itemTemplate = ($el.attr('data-fgx-item-template') || $el.text() || '').trim(),
                            val = itemTemplate.replace('{firstName}', firstName);
                        $el.find('.link-text').html(val);
                    });
                });
            }

            // There are two instances of the user menu in this nav, so divide the current auth items in half to get the
            // size of the list for each instance.
            var instSize = ($currentAuthItems.length / 2),
                instLastIdx = instSize - 1,
                itemIdx = 0;
            if (instSize > 0) {
                $currentAuthItems.each(function() {
                    this.style.setProperty('--bri-anim-idx', itemIdx);
                    if (itemIdx === instLastIdx) {
                        // This should be the last item in the current list, so add the necessary class and reset the
                        // item index to 0
                        $(this).addClass('last-link-item');
                        itemIdx = 0;
                    } else {
                        // increment the item index for this instance
                        itemIdx++;
                    }
                });
                $menuItem.find('.flyout-container').each(function() {
                    this.style.setProperty('--bri-anim-item-total', instSize);
                });
            }

            var $notificationListItems = $currentAuthItems.find('[data-notification-item]');
            checkNotifications($notificationListItems);
        }

        // Notifications
        function checkNotifications($listItems) {
            if (notificationsEnabled && isElValid($listItems)) {
                var $notifyGlobalItems = components.find('[data-notification-item="all"]'),
                    _promises = [],
                    hasNotification = false,
                    notifyItemsCfg = [{
                        $items: $listItems.filter('[data-notification-item="saved-vehicle"]'),
                        method: user.fps.notification.getAll,
                        showAlert: function(data) {
                            return !!(data && data.bsrCallSuccess && data.SavedVehicleCount && data.SavedVehicleCount.total > 0);
                        }
                    }, {
                        $items: $listItems.filter('[data-notification-item="reserve-order"]'),
                        method: rno.getOrderStatus,
                        showAlert: function(data) {
                            return !!(data && data.bsrCallSuccess && (['RCO', 'RNO', 'ONIP', 'OIP', 'SHIPPED', 'ARRIVED'].indexOf(data.statusCode || '') > -1));
                        }
                    }],
                    handleNotifyResp = function($items, showAlert) {
                        $items.toggleClass('hidden', !showAlert);
                        if (showAlert) {
                            hasNotification = true;
                        }
                    };

                notifyItemsCfg.forEach(function(item) {
                    if (item && isElValid(item.$items)) {
                        // Use Util.alwaysResolve method to ensure the promise returned by the API call is resolved (even
                        // if the call fails) so that the $.when logic below does not fail prematurely if one of the API calls fails.
                        _promises.push(brand.Util.alwaysResolve(item.method).then(function(data) {
                            handleNotifyResp(item.$items, item.showAlert(data));
                        }));
                    }
                });

                // Update the display of the global notification items after completing our check for notifications from all active types.
                $.when.apply($, _promises).always(function() {
                    $notifyGlobalItems.toggleClass('hidden', !hasNotification);
                });
            }
        }

        function setCartState() {
            var cartObj = {};
            try {
                var cartItem = window.localStorage.getItem('cartReferral');
                cartObj = (cartItem) ? JSON.parse(cartItem || '{ }') : {};
            } catch(e) { }

            var cartState = (!brand.Util.isEmpty(cartObj) && cartObj.cartId) ? 'full' : 'empty';
            components
                .find('[data-cart-link]')
                .toggleClass('hidden', true)
                .filter('[data-cart-link="' + cartState + '"]')
                .toggleClass('hidden', false);
        }

        function dskPreventTransitionCheck($el) {
            // If we're opening a flyout on desktop that's the same 'type' as the one that's already open, then prevent the animation from happening.
            return (_layoutKey === 'desktop' && _flyoutData.isActive && ($el.attr('data-flyout-type') || '') === _flyoutData.activeType && !$el.hasClass('open') && _flyoutData.activeType != '');
        }

        function handleResize(mql) {
            _layoutKey = (!mql.matches) ? 'mobile' : 'desktop';
            navHeight = components.outerHeight();
            updatePresentationElms();
            updateFlyoutAttributes();

            if (_layoutKey === 'desktop' && _mobileMenuOvr.isOpen) {
                // When resizing the screen from mobile to desktop we should close the mobile menu and release focus, but set
                // the skipLastFocus property on the mobileMenuOvr object to true first so focus isn't moved off the current element.
                _mobileMenuOvr.skipLastFocus = true;
                toggleMobileMenu.call($navbarToggle);
                // Reset to false after toggling the mobile menu
                _mobileMenuOvr.skipLastFocus = false;
            } else if (_layoutKey === 'mobile' && hasActiveFocusTrappedOvr()) {
                var activeOvr = getActiveFocusTrappedOvr(),
                    lastId = activeOvr.id;
                activeOvr.skipLastFocus = true;
                closeFlyoutMenus();
                // Need to reset the skipLastFocus in the actual overlay object itself because activeOvr will be set to null in the closeFlyoutMenus function.
                (_dskOverlays[lastId] || {}).skipLastFocus = false;
                components.toggleClass('has-open-menu', false);
            }
        }

        // Functions to setup and handle dynamic scrolling functionality when enabled
        function setupScrollHandling(el) {
            // wait for initial scroll event before setting up the logic to handle subsequent scrolls. Used in an attempt
            // to prevent the nav from unintentionally being hidden when reloading a page that has already been scrolled.
            $(el).one('scroll.fgxMainNav', function() { createScrollListener(el); });
        }
        function createScrollListener(el) {
            var $el = $(el),
                lastScrollPos = $el.scrollTop(),
                scrollLock = false;
            var handleScroll = function() {
                if (!scrollLock) {
                    scrollLock = true;
                    var scrollPos = $el.scrollTop(),
                        scrollDir = ((scrollPos - lastScrollPos) > 0) ? 'down' : 'up',
                        hasOpenFlyout = ((_layoutKey === 'mobile' && _mobileMenuOvr.isOpen) || (_layoutKey === 'desktop' && _flyoutData.isActive));
                    lastScrollPos = scrollPos;
                    // add or remove the 'hide-off-top' class from the main nav element as needed
                    components.toggleClass('hide-off-top', (!hasOpenFlyout && scrollPos > navHeight && scrollDir === 'down'));
                    // wait before releasing the scroll lock
                    window.setTimeout(function() {
                        scrollLock = false;
                    }, 100);
                } else {
                    lastScrollPos = $el.scrollTop();
                }
            };
            components.addClass('top-trans-enabled');
            if (!_forceNoDynamDisplay) {
                $el.on('scroll.fgxMainNav', handleScroll);
                components.on('focusin.fgxMainNav', function(ev) {
                    $(this).removeClass('hide-off-top');
                });
            }
        }
        function disableScrollListener(el) {
            $(el).off('scroll.fgxMainNav');
            components.removeClass('top-trans-enabled hide-off-top');
        }


        // Function to setup and handle transparent background functionality when enabled
        function setupTransparency() {
            if ("IntersectionObserver" in win) {
                try {
                    _transparentObs = new IntersectionObserver((entries, observer) => {
                        entries.forEach((entry) => {
                            // add or remove the 'force-opaque' class from the main nav element as needed
                            components.toggleClass('force-opaque', (!entry.isIntersecting));
                        });
                    }, {threshold: 0.5});
                } catch(e) {
                    _transparentObs = null;
                }
            }
            if (_transparentObs) {
                _transparentObs.observe(components[0]);
            } else {
                // Fallback to scroll event listener if intersection observer is not supported
                let $el = $(win),
                    lastScrollPos = $el.scrollTop(),
                    scrollLock = false,
                    transitionPoint = (navHeight * 0.75);
                let handleScroll = function() {
                    if (!scrollLock) {
                        scrollLock = true;
                        let scrollPos = $el.scrollTop();
                        lastScrollPos = scrollPos;
                        // add or remove the 'force-opaque' class from the main nav element as needed
                        components.toggleClass('force-opaque', (scrollPos > transitionPoint));
                        // wait before releasing the scroll lock
                        win.setTimeout(function() {
                            scrollLock = false;
                            // Add an extra check here to ensure the nav is transparent at the top. We were seeing instances
                            // where the nav would reach the top while the scrollLock was still true, so the nav was staying
                            // opaque. This should hopefully resolve that.
                            if (lastScrollPos < transitionPoint) {
                                components.toggleClass('force-opaque', false);
                            }
                        }, 100);
                    } else {
                        lastScrollPos = $el.scrollTop();
                    }
                };
                $el.on('scroll.fgxMainNav:transparent', handleScroll);
            }
        }


        function segmentController($triggers) {
            function segmentControllerHelper($triggers) {
                let _this = this,
                    _segOvrIdx = 0,
                    _segOvrAttr = 'data-fgx-fordMainNav-seg-flyout-id',
                    _segOvrIdPrefix = 'fgx-fordMainNav-seg-flyout-',
                    _segOverlays = {},
                    _linkSelectors = 'a:not([tabindex="-1"]):visible, input:visible, button:visible, [data-fgx-keypress]:visible',
                    _initialized = false;

                // Store common elements for easy access and reference later
                _this.$triggers = $triggers;
                _this.$triggersWrap = _this.$triggers.closest('.segments-anchor-list');
                _this.$container = _this.$triggers.closest('.flyout-container');
                _this.$segItems = _this.$container.find('.segment-menu-item-container');
                _this.$parentToggle = _this.$container.closest('.flyout-item-wrap').find('.flyout-toggle');

                // Initialize the segments. Create a config object for each segment and add it to the _segOverlays object if valid
                _this.$triggers.each(function() {
                    let ovrId = _segOvrIdPrefix + ++_segOvrIdx,
                        $toggle = $(this).attr(_segOvrAttr, ovrId),
                        segId = $toggle.attr('data-fgx-section-id') || '',
                        $segItem = segId && _this.$container.find('#' + segId).attr(_segOvrAttr, ovrId) || null,
                        itemIdx = _this.$triggers.index($toggle),
                        _ovr = {
                            id: ovrId,
                            index: itemIdx,
                            $el: $segItem,
                            lastFocus: $toggle,
                            focusElements: _linkSelectors,
                            skipLastFocus: false,
                            isOpen: false,
                            isFocusTrapped: false,
                            hide: function(...args) {
                                if (_layoutKey === 'mobile') {
                                    closeSegment($segItem);
                                }
                            }
                        };
                    if (_ovr.$el && _ovr.$el.length > 0) {
                        _segOverlays[_ovr.id] = _ovr;
                    }
                });

                // Expose functions as needed to make them available to call from outside of the segmentControllerHelper function.
                _this.openSegment = openSegment;
                _this.closeSegment = closeSegment;
                _this.closeAllSegments = closeAllSegments;

                // Functions
                function getSegmentConfig($el) {
                    const ovrId = $el && $el.attr(_segOvrAttr) || '';
                    return ovrId && _segOverlays && _segOverlays[ovrId] || {};
                }

                /**
                 * Remove the 'open' style and reset the aria-expanded and tabindex attributes for all segment triggers.
                 **/
                function resetAllTriggers() {
                    _this.$triggers.toggleClass('open', false).attr({'aria-expanded': 'false', 'tabindex': null});
                }

                /**
                 * Setup a keydown listener on the container and trigger the proper callback when necessary.
                 *
                 * @param $elm - {jQuery Element} - the container element that the keydown event should be tracked on. (required)
                 * @param selectors - {string} - a string of selectors representing the actionable elements that the keydown
                 *      listener should use to determine if the user is currently focused on the first or last element. (required)
                 * @param callbacks - {object} - an object containing different callback functions. These callback functions
                 *      will be passed the current event object and a jQuery object of the current target element, and they
                 *      should return a boolean which will be used to indicate whether the default behavior should be prevented
                 *      or not. The callback functions that are currently supported are: (optional)
                 *          1. firstItemTab - triggered if the first actionable item within the container has focus and the
                 *              user pushes shift + tab to navigate to the previous item.
                 *          2. lastItemTab - triggered if the last actionable item within the container has focus and the
                 *              user pushes the tab key to navigate to the next item.
                 **/
                function setupFocusManager($elm, selectors, callbacks) {
                    if (!$elm || $elm.length === 0) {
                        return;
                    }
                    let links = $elm.find(selectors);
                    $elm.on('keydown.fgxMainNav', function (e) {
                        let cancel = false;
                        if (e.ctrlKey || e.metaKey || e.altKey) {
                            return;
                        }
                        switch(e.which) {
                            case 9: // TAB
                                // refresh our links (contents change for type-ahead results, etc...)
                                links = $elm.find(selectors);
                                if (e.shiftKey) {
                                    if (e.target === links[0] && callbacks && callbacks.firstItemTab && typeof(callbacks.firstItemTab) == 'function') {
                                        try {
                                            cancel = callbacks.firstItemTab(e, $(e.target));
                                        } catch(ex) { cancel = false; }
                                    }
                                } else {
                                    if (e.target === links[links.length - 1] && callbacks && callbacks.lastItemTab && typeof(callbacks.lastItemTab) == 'function') {
                                        try {
                                            cancel = callbacks.lastItemTab(e, $(e.target));
                                        } catch(ex) { cancel = false; }
                                    }
                                }
                                break;
                        }
                        if (cancel) {
                            e.preventDefault();
                        }
                    });
                }

                /**
                 * Setup various event listeners the first time any of the segments are opened.
                 **/
                function initListeners() {
                    if (_initialized) {
                        return;
                    }
                    _initialized = true;
                    // On desktop, when an open segment trigger receives focus, set the tabindex of all segment triggers
                    // after it to -1 so that the next tab takes the user to the first actionable item in the segment container.
                    _this.$triggersWrap.on('focusin', '.segment-anchor-trigger.open', function(ev) {
                        if (_layoutKey === 'desktop') {
                            const openIdx = _this.$triggers.index($(this));
                            _this.$triggers.filter(function(idx) { return idx > openIdx; }).attr('tabindex', '-1');
                        }
                    });

                    // On desktop, set focus to the vehicles flyout toggle when the tab key is pressed while the last
                    // segment anchor trigger has focus and is not open.
                    setupFocusManager(_this.$triggersWrap, '.segment-anchor-trigger', {
                        lastItemTab: function(cbEv, $focused) {
                            if (_layoutKey === 'desktop' && $focused && !$focused.hasClass('open')) {
                                cbEv && cbEv.stopPropagation();
                                _this.$parentToggle = $('.flyout-toggle.open');
                                updateFocus(_this.$parentToggle);
                                return true;
                            }
                            return false;
                        }
                    });
                }

                /**
                 * Open the segment item
                 * @param $el - {jQuery Element} - The trigger element for the segment that should be opened. (required)
                 **/
                function openSegment($el) {
                    let segOvr = getSegmentConfig($el);
                    if (brand.Util.isEmpty(segOvr) || $el.hasClass('open')) {
                        return;
                    }
                    // initialize the listeners when the segment is opened. This will only have an impact the very first
                    // time a segment is opened
                    initListeners();
                    let onDsk = (_layoutKey === 'desktop'),
                        $segItem = segOvr.$el,
                        triggerIdx = segOvr.index;

                    // Reset all triggers and then update the current trigger to be open.
                    resetAllTriggers();
                    $el.addClass('open').attr({'aria-expanded': 'true'});
                    // On desktop, set the tabindex of all segment triggers after the current one to -1 so that the next
                    // tab takes the user to the first actionable item in the segment container.
                    if (onDsk && triggerIdx > -1 && triggerIdx < (_this.$triggers.length - 1)) {
                        _this.$triggers.filter(function(idx) { return idx > triggerIdx; }).attr('tabindex', '-1');
                    }

                    if ($segItem && $segItem.length > 0) {
                        let $prevSegItem = _this.$segItems.filter('.open');
                        let openSegItem = function() {
                            // call show() after the 'hidden' class is removed but before the 'open' class is added to help
                            // ensure the slide in animations are run
                            $segItem.removeClass('hidden').show().addClass('open');
                            segOvr.isOpen = true;
                            if (onDsk) {
                                setupFocusManager($segItem, _linkSelectors, {
                                    firstItemTab: function(cbEv, $focused) {
                                        // Callback triggered when the first item has focus and the user tries to tab backwards
                                        cbEv && cbEv.stopPropagation();
                                        // set focus to the trigger element
                                        updateFocus($el);
                                        return true;
                                    },
                                    lastItemTab: function(cbEv, $focused) {
                                        // Callback triggered when the last item has focus and the user tries to tab forwards
                                        cbEv && cbEv.stopPropagation();
                                        // set tabindex of all triggers to 0 and set focus to next trigger element
                                        // (if it exists), or back to the flyout toggle if not.
                                        _this.$triggers.attr('tabindex', '0');
                                        _this.$parentToggle = $('.flyout-toggle.open');
                                        var $focusEl = (triggerIdx > -1 && triggerIdx < (_this.$triggers.length - 1)) && !(_this.$triggers.eq(triggerIdx + 1).hasClass('button_flex_container')) ? _this.$triggers.eq(triggerIdx + 1) : _this.$parentToggle;
                                        updateFocus($focusEl);
                                        return true;
                                    }
                                });
                            } else {
                                // Trapping focus within a setTimeout to allow the animation to properly finish when opening the segment on mobile.
                                window.setTimeout(() => {
                                    FD.Brand.Overlay.trapFocus(segOvr, segOvr.focusElements, null, segOvr.lastFocus, true);
                                    segOvr.isFocusTrapped = true;
                                }, 400);
                            }
                        };
                        if ($prevSegItem.length) {
                            // Close the previous segment before opening the new one.
                            closeSegment($prevSegItem, function($respEl) {
                                openSegItem();
                            });
                        } else {
                            openSegItem();
                        }
                    }
                }

                /**
                 * Close the segment item
                 * @param $segItem - {jQuery Element} - The segment menu container element that should be closed. (required)
                 * @param callback - {function} - A callback function that should be triggered after the segment is closed. (optional)
                 **/
                function closeSegment($segItem, callback) {
                    let segOvr = getSegmentConfig($segItem),
                        onDsk = (_layoutKey === 'desktop');
                    if (brand.Util.isEmpty(segOvr)) {
                        return;
                    }

                    // Close the segment trigger and content, then update the isOpen property
                    segOvr.lastFocus.removeClass('open').attr('aria-expanded', 'false');
                    brand.Util.accordion.hideAnimContent($segItem, '.column-wrap-container', callback);
                    segOvr.isOpen = false;

                    if (onDsk) {
                        $segItem.off('keydown.fgxMainNav');
                    } else {
                        FD.Brand.Overlay.releaseFocus(segOvr);
                        segOvr.isFocusTrapped = false;
                    }
                }

                /**
                 * Close all segments
                 **/
                function closeAllSegments() {
                    resetAllTriggers();
                    _this.$segItems.off('keydown.fgxMainNav');
                    // ensure any open segment containers are closed - if none are open, this has no effect
                    brand.Util.accordion.hideAnimContent(_this.$segItems.filter('.open'), '.column-wrap-container');
                    // Ensure isOpen and isFocusTrapped are false for each segment.
                    Object.keys(_segOverlays).forEach(function (k) {
                        let segOvr = _segOverlays[k];
                        segOvr.isOpen = false;
                        if (segOvr.isFocusTrapped) {
                            segOvr.skipLastFocus = true;
                            FD.Brand.Overlay.releaseFocus(segOvr);
                            segOvr.skipLastFocus = false;
                            segOvr.isFocusTrapped = false;
                        }
                    });
                }

                return _this;
            }
            return new segmentControllerHelper($triggers);
        }


        function searchController($inputEl, formAction, id, searchLib) {

            function searchControllerHelper($input, id, searchLib) {
                var _this = this,
                    _id = id,
                    _searchLib = searchLib;

                _this.$input = $input;
                _this.$form = $input.closest('.fgx-search-form');
                _this.$searchFormWrapper = _this.$form.closest('.fgx-search-wrapper');
                _this.$formWrapper = _this.$form.find('.form-wrapper');
                _this.$resultsContainer = _this.$form.find(`${_layoutKey === 'desktop' ? '#search-suggestions-desktop' : '#search-suggestions-mobile'} ul.search-suggestions`);
                _this.$searchSubmit = _this.$form.find('.fgx-search-submit');
                _this.$searchClose = _this.$searchFormWrapper.find('.fgx-search-close');
                _this.$searchClear = _this.$form.find('.fgx-search-clear');
                _this.setAction = setFormAction;
                _this.setReferrerApp = setReferrerApp;
                _this.inputChange = handleInputChange;
                _this.hideResults = hideResults;
                _this.itemFocusOut = handleItemFocusOut;
                _this.submitForm = submitForm;
                _this.getId = getId;
                _this.showSearch = showSearch;
                _this.closeSearch = handleCloseSearch;
                //Event Listeners
                _this.$input
                    .on('input', handleInputChange)
                    .on('keydown', handleInputKeydown)
                    .on('blur', function() {
                        _this.itemFocusOut('input');
                    });

                //handling to ensure the type-ahead results container isn't hidden if the search suggestions scroll bar is clicked.
                _this.$resultsContainer
                    .on('mousedown', function() {
                        _this.$resultsContainer.addClass('fgx-is-scrolling');
                    })
                    .on('mouseup', function() {
                        _this.$input.focus();
                        _this.$resultsContainer.removeClass('fgx-is-scrolling');
                    })
                    .on('focusout', '.search-res-item', function() {
                        _this.itemFocusOut('result');
                    });

                _this.$searchSubmit.on('click', submitForm);

                _this.$searchClose.on('click', handleCloseSearch);

                _this.$searchClear.on('click', function(ev) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    _this.$input.val('');
                    _this.$input.focus();
                    _this.$searchClear.addClass('hidden')
                    if (!hasSearchHistory()) {
                        const $recentSearchesContainer = isDesktop ? $('.desktop-show', components).find('#recent-searches-desktop') : $('.mobile-show', components).find('#recent-searches-mobile');
                        $recentSearchesContainer.hide();
                        $searchListContainer.hide();
                    }
                });

                return _this;

                function setFormAction(action) {
                    _this.$form.attr("action", action || '');
                    return _this;
                }

                function setReferrerApp() {
                    if (_searchLib) {
                        _searchLib.setReferrerApp(_this.$formWrapper);
                    }
                    return _this;
                }

                function handleInputChange() {
                    var $this = $(this),
                        val = $this.val();
                    if(val.length === 0) {
                        _this.hideResults();
                    } else {
                        try {
                            _searchLib.typeAheadResults(val, _this.$resultsContainer, $this);
                        } catch(ex) { }
                    }
                }

                function handleInputKeydown(ev) {
                    if (ev.which === 40 && $(this).hasClass('fgx-list-shown')) {
                        // focus on the very first type-ahead result item
                        _this.$resultsContainer.find('li').first().focus();
                    }
                }

                function handleItemFocusOut(itmType) {
                    // setTimeout is needed because nothing has focus during 'focusout'
                    setTimeout(function() {
                        var active = $(document.activeElement),
                            itmTypeCond = !((itmType === 'result') ? active.hasClass('fgx-search-input') : _this.$resultsContainer.hasClass('fgx-is-scrolling'));

                        if (!active.hasClass('search-res-item') && itmTypeCond) {
                            _this.hideResults();
                        }
                    }, 100);
                }

                function hideResults() {
                    _this.$resultsContainer.parent().hide();
                    _this.$input.toggleClass('fgx-list-shown', false);//BRAND-12331
                    return _this;
                }

                function submitForm(e) {
                    if (!$input.val()) {
                        window.event.preventDefault();
                    } else {
                        handleAddToSearchHistory({event: e, searchTerm: $input.val()})
                        _this.$form.submit();
                    }
                }

                function getId() {
                    return _id;
                }

                // Calculate the current top offset of the search trigger and set it as the --bri-anim-search-offset-mbl
                // custom variable. This relies on _layoutKey and navHeight which are both set outside of the search controller logic
                function updateAnimOffsetMbl($el) {
                    if ($el && $el.length > 0 && _layoutKey === 'mobile') {
                        let $menuItems = $el.closest('.menu-items-container'),
                            menuItemsTopOff = $menuItems && $menuItems.offset().top || navHeight,
                            scrollOff = $menuItems && $menuItems.scrollTop() || 0,
                            topOff = ($el.offset().top || 0) + scrollOff - menuItemsTopOff;
                        if (topOff > 0) {
                            _this.$searchFormWrapper[0].style.setProperty('--bri-anim-search-offset-mbl', topOff + 'px');
                        }
                    }
                }

                function showSearch($el) {
                    updateAnimOffsetMbl($el);
                    // call show() after the 'hidden' class is removed but before the 'open' class is added to help
                    // ensure the animations are run
                    _this.$searchFormWrapper.removeClass('hidden').show().addClass('open');
                    if (_searchOvr) {
                        // Set a delay before setting focus to the search bar on mobile b/c we were seeing issues with
                        // the new search bar animation on physical mobile devices where the bar was displaying up off screen.
                        // This timeout should be temporary until we can find a more permanent solution for this issue.
                        const delay = (_layoutKey === 'mobile') ? 400 : 0;
                        window.setTimeout(() => {
                            FD.Brand.Overlay.trapFocus(_searchOvr, _searchOvr.focusElements, _this.$input, _searchOvr.lastFocus, false);
                        }, delay);
                    }
                }

                function closeSearchCb(ev) {
                    _this.$searchFormWrapper.off(animEvents, closeSearchCb).addClass('hidden');
                    if (_searchOvr) {
                        FD.Brand.Overlay.releaseFocus(_searchOvr);
                    }
                }

                function handleCloseSearch(ev) {
                    updateAnimOffsetMbl(_searchOvr && _searchOvr.lastFocus);
                    _this.$searchFormWrapper.one(animEvents, closeSearchCb).removeClass('open');
                }
            }

            var _sch = new searchControllerHelper($inputEl, id, searchLib);

            _sch.setAction(formAction)
                .setReferrerApp();

            return _sch;
        }
    }

    function setupMainNavScrollBehavior() {
        let lastScrollPos = 0;
        const $mainNav = $('.fordMainNavigationR23');
        const $secondaryNav = $('.secondaryNavigationR23');
        const secondaryNavTop = $secondaryNav.length ? $secondaryNav.offset().top : 0;
        const mainNavHeight = $mainNav.outerHeight();
    
        function handleScroll() {
            const scrollPos = $(window).scrollTop();
    
            const scrollDir = scrollPos > lastScrollPos ? 'down' : 'up';

            // Handle sticky behavior
            if (scrollPos > mainNavHeight) {
                if (scrollDir === 'down') {
                    if ($secondaryNav.length) {
                        $secondaryNav.css('top', '0');
                    }
                }

                if (scrollDir === 'up') {
                    if ($secondaryNav.length && scrollPos > secondaryNavTop - mainNavHeight) {
                        $secondaryNav.css('top', mainNavHeight + 'px');
                    } else if ($secondaryNav.length) {
                        $secondaryNav.css('top', '');
                    }
                }
            }
    
            lastScrollPos = scrollPos;
        }
    
        // Throttle the scroll event to improve performance
        let throttleTimer;
        $(window).on('scroll', function() {
            if (!throttleTimer) {
                throttleTimer = setTimeout(function() {
                    handleScroll();
                    throttleTimer = null;
                }, 50);
            }
        });
    }

})(jQuery, window, FD.Brand, FD.Brand.User, FD.Brand.Pricing, FD.Brand.Search, FD.Brand.Context, FD.Brand.NgpServices, FD.Brand.RnO);

// CODE ISOLATE FOR EXPOSED SEARCH BAR
const utils = (function($, search) {
    return function({ $searchListContainer, $searchInput, components }) {
        // Cache frequently used elements
        const $recentSearchesContainerDesktop = $('.desktop-show', components).find('#recent-searches-desktop');
        const $recentSearchesContainerMobile = $('.mobile-show', components).find('#recent-searches-mobile');
        const $searchHistoryContainerDesktop = $('.desktop-show', components).find('#search-history-desktop');
        const $searchHistoryContainerMobile = $('.mobile-show', components).find('#search-history-mobile');

        // exposed search bar functions
        function createRecentSearchesList({ isDesktop }) {
            const searchHistory = getSearchHistory();
            const recentHistory = searchHistory.slice(-5).reverse();
            const $recentSearchesContainer = isDesktop ? $recentSearchesContainerDesktop : $recentSearchesContainerMobile;
            const $recentHistoryItems = $('.recent-history-item', $recentSearchesContainer);

            // Compare existing items with recent history
            const existingRecentHistoryItems = $recentHistoryItems.map(function() {
                return $(this).find('span:last').text();
            }).toArray();

            const hasChanged = !arraysEqual(existingRecentHistoryItems, recentHistory);
            
            // Only manipulates the DOM when necessary
            if (hasChanged) {
                $recentSearchesContainer.children('ul').empty();

                const listItems = createListItemElements({
                    items: recentHistory,
                    className: 'search-res-item recent-history-item',
                    iconName: "linkIcon"
                });

                $recentSearchesContainer.children('ul').append(listItems);
            }
        }

        function createFilteredSearchHistoryList({searchInput, isDesktop}) {
            const searchHistory = getSearchHistory();
            const lowercaseInput = searchInput.toLowerCase();
            const filteredHistory = searchHistory
                .filter(historyItem => historyItem.toLowerCase().includes(lowercaseInput))
                .slice(0, 5);

            const $searchHistoryContainer = isDesktop ? $searchHistoryContainerDesktop : $searchHistoryContainerMobile;

            if (filteredHistory.length) {
                $searchHistoryContainer.children('ul').empty();
                const listItems = createListItemElements({
                    items: filteredHistory,
                    className: 'search-res-item filtered-history-item',
                    iconName: 'historyIcon'
                });

                $searchHistoryContainer.children('ul').append(listItems);
            }

            return filteredHistory;
        }

        function hasSearchHistory() {
            try {
                const searchHistory = getSearchHistory();
                return searchHistory.length > 0;
            } catch (e) {
                return false;
            }
        }

        function createListItemElements({ items, className, iconName }) {
            const iconClasses = {
                "linkIcon": "link-icon",
                "historyIcon": "history-icon"
            };
            
            const fragment = document.createDocumentFragment();
            
            items.forEach((item) => {
                const listItem = document.createElement('li');
                const highlightedText = search.highlightText(item, $searchInput);
                const icon = iconClasses[iconName] || "";

                listItem.className = className;
                listItem.innerHTML = `
                    <div style="display: flex; align-items: center;">
                        <span class="${icon}"></span>
                        <span>${highlightedText}</span>
                    </div>
                `;
                listItem.setAttribute('data-fgx-keypress', 'true');
                fragment.appendChild(listItem);
            });
            
            return fragment;
        }

        function clearHistory({ e, isDesktop }) {
            e.preventDefault();
            e.stopPropagation();
            window.localStorage.removeItem('searchHistory');
            const $recentSearchesContainer = isDesktop ? $recentSearchesContainerDesktop : $recentSearchesContainerMobile;
            $recentSearchesContainer.hide();
            $searchListContainer.hide(200);
        }

        function handleAddToSearchHistory({ event, searchTerm }) {
            event.preventDefault();

            const searchHistory = getSearchHistory();
            const trimmedSearchTerm = searchTerm.trim();
            const searchTermIdx = searchHistory.indexOf(trimmedSearchTerm);
            const isDuplicateSearch =  searchTermIdx > -1;

            if (isDuplicateSearch) {
                searchHistory.splice(searchTermIdx, 1);
            }

            searchHistory.push(trimmedSearchTerm);
            setSearchHistory(searchHistory);
        }

        function getURLParams(url) {
            return Object.fromEntries(new URL(url).searchParams.entries());
        }

        function arraysEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i].trim().toLowerCase() !== arr2[i].trim().toLowerCase()) return false;
            }
            return true;
        }

        function getSearchHistory() {
            return JSON.parse(window.localStorage.getItem('searchHistory') || '[]');
        }

        function setSearchHistory(searchHistory) {
            window.localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
        }
        // end of exposed search bar functions

        return {
            createRecentSearchesList,
            createFilteredSearchHistoryList,
            hasSearchHistory,
            handleAddToSearchHistory,
            clearHistory,
            getURLParams,
            getSearchHistory,
            setSearchHistory
        }
    }
})(jQuery, FD.Brand.Search);

const listenerHandlers = (function($, search) {
    return function({ $searchListContainer, $searchSuggestions, $searchInput, isAccessoriesPage, isAnyOtherPage, components, isDesktop, navHeight, utils }) {
        const { createRecentSearchesList, createFilteredSearchHistoryList, hasSearchHistory, handleAddToSearchHistory, clearHistory, getSearchHistory } = utils
        
        // Cache frequently used elements
        const $recentSearchesContainer = isDesktop ? $('.desktop-show', components).find('#recent-searches-desktop') : $('.mobile-show', components).find('#recent-searches-mobile');
        const $searchHistoryContainer = isDesktop ? $('.desktop-show', components).find('#search-history-desktop') : $('.mobile-show', components).find('#search-history-mobile');
        const $clearInputBtn = $searchInput.siblings('.fgx-search-clear');
        const $clearInputBtnIcon = $clearInputBtn.find('.fgx-icon');
        
        function handleSearchListContainerClick(ev) {
            const trimmedInputValue = $(this).text().trim();
            $searchInput.val(trimmedInputValue);
            handleAddToSearchHistory({ event: ev, searchTerm: $searchInput.val() })
            $searchListContainer.hide();
            $(this).closest('form').submit();
        }
        
        function handleSearchInputFocus(ev) {
            const searchInput = ev.target.value || '';
            
            if (!searchInput.length) {
                $clearInputBtn.addClass('hidden');
                $clearInputBtnIcon.css('display', 'none');
                if (hasSearchHistory()) {
                    createRecentSearchesList({ isDesktop });
                    $searchListContainer.show();
                    $recentSearchesContainer.show();
                    $searchHistoryContainer.hide();
                    $searchSuggestions.hide();
                }
            } 
            
            if (searchInput.length) {
                let hasSearchSuggestions = $searchSuggestions.find('ul > li').length > 0;
                if (!hasSearchSuggestions) {
                    search.typeAheadResults(searchInput, $searchSuggestions.find('ul.search-suggestions'), $(this));
                    hasSearchSuggestions = $searchSuggestions.find('ul > li').length > 0;
                }
                $clearInputBtn.removeClass('hidden');
                $clearInputBtnIcon.css('display', 'block');
                
                let hasFilteredSearchHistory = $searchHistoryContainer.find('ul > li').length > 0;
                
                if (hasSearchHistory() && !hasFilteredSearchHistory) {
                    createFilteredSearchHistoryList({ searchInput, isDesktop });
                    hasFilteredSearchHistory = $searchHistoryContainer.find('ul > li').length > 0;
                }
                
                $searchListContainer.show();
                $searchSuggestions.toggle(hasSearchSuggestions);
                $searchHistoryContainer.toggle(hasFilteredSearchHistory);
                $recentSearchesContainer.hide();
            }
        }
        
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        const debouncedSearchInputChange = debounce(function(ev) {
            const searchInput = ev?.target?.value || '';
            const hasSearchSuggestions = $searchSuggestions.find('ul > li').length > 0;
            
            if (searchInput.length) {
                $clearInputBtn.removeClass('hidden');
                $clearInputBtnIcon.css('display', 'block');
            } else {
                $clearInputBtn.addClass('hidden');
                $clearInputBtnIcon.css('display', 'none');
            }
            
            if (hasSearchHistory()) {
                if (searchInput.length) {
                    const filteredHistory = createFilteredSearchHistoryList({ searchInput, isDesktop });
                    const hasFilteredHistory = filteredHistory.length > 0;
                    $searchListContainer.toggle(hasSearchSuggestions || hasFilteredHistory);
                    $searchSuggestions.toggle(hasSearchSuggestions);
                    $searchHistoryContainer.toggle(hasFilteredHistory);
                    $recentSearchesContainer.hide();
                } 
                
                if (!searchInput.length) {
                    createRecentSearchesList({ isDesktop });
                    $searchListContainer.show();
                    $recentSearchesContainer.show();
                    $searchHistoryContainer.hide();
                    $searchSuggestions.hide();
                }
            } 
            
            if (!hasSearchHistory()) {
                if (searchInput.length) {
                    $searchListContainer.toggle(hasSearchSuggestions);
                    $searchSuggestions.toggle(hasSearchSuggestions);
                }
                if (!searchInput.length) {
                    $searchListContainer.hide();
                    $searchSuggestions.hide();
                }
            }
        }, 200);

        function handleSearchInputChange(ev) {
            debouncedSearchInputChange(ev);
        }
        
        function handleSearchInputBlur() {
            if (isDesktop) {
                $(document).one('click', function(e) {
                    if (!$(e.target).closest($searchInput).length &&
                    !$(e.target).closest($searchListContainer).length) {
                        $searchListContainer.hide();
                    }
                })
            }

            // on mobile we want to make sure the user stays focused on the input
            // when they click outside of any of the interacting elements
            if (!isDesktop) {
                $(document).one('click', function() {
                    $searchInput.focus()
                })
            }
        }
        
        function handleClearHistoryClick(e) {
            clearHistory({ e, isDesktop });
        }

        function closeListOnScroll() {
            if ($searchListContainer.css('display') === 'block') {
                $searchInput.blur();
                $searchListContainer.hide();
            }
        }

        function handleScrollClick(event) {
            if (!isDesktop) return;

            const $searchWrapper = $searchInput.parents('.fgx-search-wrapper');
            const $searchTrigger = $searchWrapper.next().find('.fgx-search-trigger');
            const isInputEmpty = !$searchInput.val();

            if (event.type === 'scroll') {
                closeListOnScroll();
                
                if (isAccessoriesPage && isInputEmpty) {
                    const scrollPos = $(window).scrollTop();
                    const transitionPoint = navHeight * 0.75;
                    
                    if (scrollPos < transitionPoint) {
                        $searchWrapper.removeClass('open').addClass('hidden');
                        $searchInput.removeClass('focus');
                        $searchTrigger.removeClass('hidden');
                    } 
                    
                    if (scrollPos > transitionPoint) {
                        $searchWrapper.removeClass('hidden').addClass('open');
                        $searchInput.addClass('focus');
                        $searchTrigger.removeClass('open').addClass('hidden');
                    }
                } 
                
                if (isAnyOtherPage && $searchWrapper.hasClass('open')) {
                    $searchWrapper.removeClass('open').addClass('hidden');
                    $searchInput.addClass('focus');
                    $searchTrigger.removeClass('hidden');
                }
            } 
            
            if (event.type === 'click') {
                const isClickWithinExposedSearch = $(event.target).closest('.icon-bri-search, .fgx-search-input, .fgx-search-trigger').length > 0;

                if (isClickWithinExposedSearch) {
                    $('.fordMainNavigationR23.fgx-theme-standard').addClass('force-opaque');
                } 

                if (!isClickWithinExposedSearch) {
                  if (isAnyOtherPage) {
                    $searchWrapper.removeClass('open').addClass('hidden');
                    $searchInput.removeClass('focus').blur();
                    $searchTrigger.removeClass('hidden');
                  }
                }
            }
        }

        return {
            handleSearchListContainerClick,
            handleSearchInputFocus,
            handleSearchInputChange,
            handleSearchInputBlur,
            handleClearHistoryClick,
            handleScrollClick
        }
    }
})(jQuery, FD.Brand.Search);

const listeners = (function() {
    const init = function({ $searchListContainer, $searchInput, components, listenerHandlers }) {
        const {
                handleSearchListContainerClick,
                handleSearchInputFocus,
                handleSearchInputChange,
                handleSearchInputBlur,
                handleClearHistoryClick,
                handleScrollClick
            } = listenerHandlers

        // exposed search bar listeners
        $searchListContainer.on('click', '.search-res-item', handleSearchListContainerClick)
        $searchInput.on('focus', handleSearchInputFocus);
        $searchInput.on('input', handleSearchInputChange);
        $searchInput.on('blur', handleSearchInputBlur);
        $('#clear-history-btn', components).on('click', handleClearHistoryClick)
        $(window).on('click scroll', handleScrollClick);
        // end of exposed search bar listeners
    }

    return { init }
})();

// Main IIFE
;(function ($, search) {
    function handleExposedSearchBar({ isDesktop, components, navHeight }) {
        const $searchListContainer = isDesktop ? $('.desktop-show', components).find('#search-list-container-desktop') : $('.mobile-show', components).find('#search-list-container-mobile');
        const $searchSuggestions = isDesktop ? $('.desktop-show', components).find('#search-suggestions-desktop') : $('.mobile-show', components).find('#search-suggestions-mobile');
        const $searchInput = isDesktop ? $('.desktop-show', components).find('#fgx-search-input-desktop') : $('.mobile-show', components).find('#fgx-search-input-mobile');

        const utilsInstance = utils({ $searchListContainer, $searchSuggestions, $searchInput, search, components })
        const { handleAddToSearchHistory, getURLParams, hasSearchHistory } = utilsInstance
        const params = getURLParams(window.location.href);
        const pathname = window.location.pathname;
        const isAccessoriesPage = pathname.includes('accessories');
        const isSearchPage = pathname.includes('search');
        const isPLPorPDPPage = pathname.includes('pdp') || pathname.includes('plp');
        const isAnyOtherPage = !isSearchPage && !isPLPorPDPPage;
        
        if (isSearchPage || isPLPorPDPPage) {
            // should always be expanded
            if (isDesktop) {
                $searchInput.parents('.fgx-search-wrapper').removeClass('hidden').addClass('open');
                $searchInput.addClass('focus');
                $searchInput.parents('.fgx-search-wrapper').next().find('.fgx-search-trigger').removeClass('open').addClass('hidden');
                $searchInput.val(params['f:searchInputString'] || '');
                $('.header-subtitle.page-comp, #g-search-input').hide();
            }
        }
        
        const listenerHandlersInstance = listenerHandlers({ 
            $searchListContainer,
            $searchSuggestions,
            $searchInput,
            isAccessoriesPage,
            isAnyOtherPage,
            components,
            isDesktop,
            navHeight,
            utils: utilsInstance
        })

        listeners.init({ $searchListContainer, $searchInput, components, listenerHandlers: listenerHandlersInstance });

        // variables / functions needed in outer js
        return { $searchListContainer, $searchInput, handleAddToSearchHistory, hasSearchHistory }
    }

    window.handleExposedSearchBar = handleExposedSearchBar;
})(jQuery, FD.Brand.Search);
// END OF CODE ISOLATE FOR EXPOSED SEARCH BAR
/*global FD*/
;(function (win, $, brand, overlay, search, ctx) {
    var ovr;

    brand.setInitHandler('[data-fgx-search-overlay]', init);

    /////////////
    function init(components) {
        var ovrTriggers = $('[data-fgx-search-overlay-trigger]'),
            defaultAction = (ctx.make === 'Ford') ? "//www.ford.com/search/" : "//www.lincoln.com/search/",
            formAction = ctx.settings['ngbsSearchUrl' + ctx.make + ctx.languageKey] || ctx.settings['ngbsSearchUrl' + ctx.make] || defaultAction,
            mtxActions = ctx && ctx.mtxActions,
            searchSubmitAction = mtxActions && mtxActions.searchSubmitAction || null,
            searchOverlayOpenAction = mtxActions && mtxActions.searchOverlayOpenAction || null;

        ovr = overlay.register('searchOverlay', components);
        $("form", components).attr("action", formAction);

        search.setReferrerApp($('.form-wrapper', components));

        ovrTriggers.each(function() {
            $(this).on('click', 'a', function(ev) {
                $(".navbar-static-top .drop-parent .dropdown-menu").hide();
                ev.preventDefault();
                $(window).scrollTop(0);
                ovr.show(true, $(this), '.search-overlay-input');
                // new metrics
                if (searchOverlayOpenAction) {
                    FD.Brand.Metrics.handler.direct(
                        searchOverlayOpenAction
                    );
                }
            });
        });
        
        // listen for form to submit so we can track on both the submit button click, or enter
        $("form", components).on('submit', function(){
            // new metrics
            if (searchSubmitAction) {
                FD.Brand.Metrics.handler.direct(
                    searchSubmitAction
                );
            }
        });

        $('.icon-close', components).on('click', function() {
            ovr.hide();
            //show main nav items slightly after hiding overlay, so they dont reappear until after overlay closes
            setTimeout(function(){ $(".navbar-static-top .drop-parent .dropdown-menu").show(); }, 350);
        });
        $('.search-overlay-submit', components).on('click', function(event) {
            const val = $('.search-overlay .search-overlay-input').val();
            if (!val) {
                event.preventDefault();
            } else {
                $(this).closest("form").submit();
            }
        });

        $(document).click(function(event) {
            //reveal dropdown menus when search overlay closed by clicking outside of search overlay template
            if( $(".search-overlay.template").is(":visible") && !$(event.target).closest('.search-overlay.template').length) {
                setTimeout(function(){ $(".navbar-static-top .drop-parent .dropdown-menu").show(); }, 350);
            }
        });
    }

})(window, jQuery, FD.Brand, FD.Brand.Overlay, FD.Brand.Search, FD.Brand.Context);

/*global FD*/
;(function ($, brand, util, overlay, context) {

    var ovr;
    brand.setInitHandler('[data-fgx-ratings-info]', init);

    /////////////

    function init(components) {
        if(components.length === 0) {
            return;
        }
        ovr = overlay.register('dealerRatingsInfo', components);
        $('.icon-close', components).on('click', function() {
            ovr.hide();
        });
        $('.icon-close-new', components).on('click', function() {
            ovr.hide();
        });
    }

})(jQuery, FD.Brand, FD.Brand.Util, FD.Brand.Overlay, FD.Brand.Context);


(function (brand) {
  brand.setInitHandler("[data-fgx-promo-banner]", init);

  function init(components) {
    if (components.length == 0) {
      return;
    }
    const slideCount = $(".promoBanner #slider ul li").length;
    if (slideCount > 1) {
      $(".promoBanner #slider ul li").first().addClass("firstItem activeItem");
      $(".promoBanner #slider ul li").last().addClass("lastItem");
    } else {
      $(".promoBanner #slider ul li").addClass("singleItem activeItem");
    }

    function disableElement($element) {
      if (!$element.length) return;
      $element.attr("tabindex", "-1");
      $element.attr("aria-disabled", "true");
      $element.css("pointer-events", "none");
      $element.children("a")?.each(function () {
        disableElement($(this));
      });
    }

    function enableElement($element) {
      if (!$element.length) return;
      $element.attr("tabindex", "0");
      $element.attr("aria-disabled", "false");
      $element.css("pointer-events", "auto");
      $element.children("a")?.each(function () {
        enableElement($(this));
      });
    }

    // isPromoBannerClickable
    function activeBannerHasDrawerContent() {
        const visibleBanner = $('.promoBanner__topBar__item.activeItem');
        const visibleBannerId = visibleBanner.attr('id');
        const mappedDrawers = {
            "bannerOne": "drawerItemOne",
            "bannerTwo": "drawerItemTwo",
            "bannerThree": "drawerItemThree",
        }
    
        const drawerItem = mappedDrawers[visibleBannerId];
        const $drawerItemElement = $(`#${drawerItem}`);
    
        return $drawerItemElement.length
    }

    function toggleCursorPointer() {
        const promoTicker = document.getElementById("promo_ticker");
        if (activeBannerHasDrawerContent()) {
            promoTicker.style.cursor = "pointer";
        } else {
            promoTicker.style.cursor = "default";
        }
    }

    toggleCursorPointer();

    if (slideCount > 1) {
      $(".promoBanner__topBar__item").each(function () {
        let item = $(this);
        if (item.hasClass("activeItem")) {
          enableElement(item);
        } else {
          disableElement(item);
        }
      });

      setInterval(function () {
        let activeItem = $(".promoBanner__topBar__item.activeItem");
        let nextItem = activeItem.next();
        if (activeItem.hasClass("lastItem")) {
          activeItem.removeClass("activeItem");
          disableElement(activeItem);
          setTimeout(function () {
            $(".promoBanner__topBar__item.firstItem").addClass("activeItem");
            activeItem = $(".promoBanner__topBar__item.activeItem");
            enableElement(activeItem);
            toggleCursorPointer();
          }, 1000);
        } else {
          activeItem.removeClass("activeItem");
          disableElement(activeItem);
          setTimeout(function () {
            nextItem.addClass("activeItem");
            enableElement(nextItem);
            toggleCursorPointer();
          }, 600);
        }
      }, 10000);
    }

    // Sticky Navbar Logic When Banner Is Visible
    if ($(".promoBanner").length) {
      $(".fordMainNavigationR23 .navbar").css("position", "relative");
    }
    window.addEventListener("scroll", (event) => {
      let scroll = this.scrollY;
      let navPosition = $(".fordMainNavigationR23 .navbar").offset();

      if (scroll >= navPosition.top) {
        $(".fordMainNavigationR23 .navbar").css("position", "fixed");
      }

      if (scroll <= 40) {
        $(".fordMainNavigationR23 .navbar").css("position", "relative");
      }
    });

    const drawerItems = $(".promoBanner__drawer__item").length;
    if (drawerItems == 1) {
      $(".promoBanner__drawer__item").addClass("singleItem");
    }

    const promoTicker = document.getElementById("promo_ticker");
    const tickerIcon = document.querySelectorAll(
      ".promoBanner__topBar__item i"
    );
    const promoDrawer = document.getElementById("promo_drawer");
    const closeMenu = document.getElementById("close_drawer");

    closeMenu.addEventListener("click", () => {
      promoDrawer.classList.add("hideDrawer");
      $(".promoBanner #slider ul li i").attr("aria-expanded", "false");
    });

    promoTicker.addEventListener("click", (event) => {
      const isAnAnchorLink = $(event.target).is("a");
      if (isAnAnchorLink) return;
      if (!activeBannerHasDrawerContent()) return;

      promoDrawer.classList.toggle("hideDrawer");
      $(".promoBanner #slider ul li i").attr("aria-expanded", "true");
      closeMenu.focus();
    });

    for (let i = 0; i < tickerIcon.length; i++) {
      tickerIcon[i].addEventListener("keypress", (e) => {
        if (e.key === "Enter" || e.key === " " || e.keyCode === 32) {
          e.preventDefault();
          promoDrawer.classList.toggle("hideDrawer");
          closeMenu.focus();
        }
      });
    }

    document.addEventListener("click", (event) => {
      if (!event.target?.className?.includes?.("fgx-tooltip-close")) {
        if (
          !promoDrawer.contains(event.target) &&
          !promoTicker.contains(event.target)
        ) {
          promoDrawer.classList.add("hideDrawer");
          $(".promoBanner #slider ul li i").attr("aria-expanded", "false");
        }
      }
    });
  }
})(FD.Brand);

